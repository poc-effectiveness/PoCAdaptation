diff --git a/.gitignore b/.gitignore
index e937dc30e7..acfd0ac0f5 100644
--- a/.gitignore
+++ b/.gitignore
@@ -25,3 +25,4 @@ buildNumber.properties
 # Ignore folders used to build binaries for old Java
 /pgjdbc-jre6
 /pgjdbc-jre7
+/eclipsebin/
diff --git a/.travis.yml b/.travis.yml
index b5ded328e0..725ed447ec 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -8,11 +8,13 @@ before_script:
   - echo "MAVEN_OPTS='-Xmx1g -Dgpg.skip=true'" > ~/.mavenrc
   - test "x$PG_VERSION" == 'x' || test $PG_VERSION == '8.4' || test $PG_VERSION == '9.0' || psql test -c 'CREATE EXTENSION hstore;' -U postgres
   - test "x$PG_VERSION" == 'x' || test $PG_VERSION != '8.4' || createlang -U postgres plpgsql test
+  - if [[ "x$JDK" == *'x9'* ]]; then remove_dir_from_path $JAVA_HOME/bin; export JAVA_HOME=/usr/lib/jvm/java-9-oracle; export PATH=$JAVA_HOME/bin:$PATH; java -Xmx32m -version; fi
 
 env:
   global:
     - secure: "3HRd+UJQzXoxmBAiJ8SLFuYK8NvMVgIs0erfcPdgvtfFGTPkH3XMONfNr2VE2uz6qwUB5GWkVzvS4c9CPbnnft9QhyYeeUINiqQMN5+6AN5re3C2D7VQMm3NSB+T2R6zS/18UZW5tIoTJILgl5oRCQFI7RSpqhvZ8nqPxJ4gptI="
     - secure: "VrNgbyKQi5HjSMZfkt/zwG+AHk1NW1b+f3Jo1ZH7DCqcgLApwvp4MNsw+XamqHxudjj3Z8+4bYBxG2H6zIOobIyYhBvxUwMq7HTjM4jH8m5phqvQIWZOzZzqguYNNS7JJQUpIMwR7wTuHqucVfMxljoSuXQbs+0BUxo4Eh+FScQ="
+    - secure: "NI+aqwRLLVt2feJdk/2ZEZnsaPyu+vOx8MahVxjz0UUVvRHVqxM5O1M0R53NJfEeIjflOzgZJwRLqgyl6dkdfjytRhaHWGptQdehV4cwNb+4epnn8WlpRzMac65zTQqnbGVtw9jissDQv6/Zl/+D+DMcU65BbFZkix40whILXG0="
 
 script:
   # make sure previous build artifacts are not used for subsequent builds
@@ -20,6 +22,8 @@ script:
   - export JDK6_HOME=$(jdk_switcher home openjdk6)
   - export JDK7_HOME=$(jdk_switcher home openjdk7)
   - export JDK8_HOME=$(jdk_switcher home oraclejdk8)
+  - export JDK9_HOME=/usr/lib/jvm/java-9-oracle
+  - test -d "${JDK9_HOME}" || export JDK9_HOME=$(jdk_switcher home oraclejdk8)
   - envsubst < toolchains.xml > ~/.m2/toolchains.xml
   - ./travis_build.sh
   # To avoid useless S3 cache updates (https://github.com/travis-ci/travis-ci/issues/1441#issuecomment-67607074)
@@ -41,6 +45,17 @@ cache:
 matrix:
   fast_finish: true
   include:
+    - env:
+        - FEDORA_CI=Y
+      services:
+        - docker
+    - jdk: oraclejdk8
+      sudo: required
+      dist: trusty
+      env:
+        - PG_VERSION=9.6
+        - XA=true
+        - COVERAGE=Y
     - jdk: oraclejdk8
       sudo: required
       dist: trusty
@@ -57,43 +72,48 @@ matrix:
         - COVERAGE=Y
     - jdk: oraclejdk8
       env: RUN_CHECKSTYLE=true
-      script: cd pgjdbc && mvn checkstyle:check
+      script: mvn checkstyle:check
     - jdk: oraclejdk8
       addons:
         postgresql: "9.4"
       env:
         - PG_VERSION=9.4
         - COVERAGE=Y
+        - MCENTRAL=Y
+        - JDOC=Y
     - jdk: openjdk7
       addons:
         postgresql: "9.4"
-      env: PG_VERSION=9.4
+      env:
+        - PG_VERSION=9.4
+        - MCENTRAL=Y
     - jdk: openjdk6
       addons:
         postgresql: "9.4"
-      env: PG_VERSION=9.4
+      env:
+        - PG_VERSION=9.4
+        - MCENTRAL=Y
+    - jdk: oraclejdk8 # this will be overwritten by before_install above
+      addons:
+        apt:
+          packages:
+            - oracle-java9-installer
+      env:
+        - PG_VERSION=9.5
+        - JDK=9
     - jdk: oraclejdk8
       addons:
-        postgresql: "9.3"
-      env: PG_VERSION=9.3
+        postgresql: "9.4"
+      env:
+        - PG_VERSION=9.4
+        - NO_WAFFLE_NO_OSGI=Y
+        - JDOC=Y
     - jdk: openjdk7
       addons:
         postgresql: "9.3"
       env:
         - PG_VERSION=9.3
         - COVERAGE=Y
-    - jdk: openjdk6
-      addons:
-        postgresql: "9.3"
-      env: PG_VERSION=9.3
-    - jdk: oraclejdk8
-      addons:
-        postgresql: "9.2"
-      env: PG_VERSION=9.2
-    - jdk: openjdk7
-      addons:
-        postgresql: "9.2"
-      env: PG_VERSION=9.2
     - jdk: openjdk6
       addons:
         postgresql: "9.2"
@@ -106,15 +126,7 @@ matrix:
       env:
         - PG_VERSION=9.1
         - COVERAGE=Y
-    - jdk: openjdk7
-      addons:
-        postgresql: "9.1"
-      env: PG_VERSION=9.1
-    - jdk: openjdk6
-      addons:
-        postgresql: "9.1"
-      env: PG_VERSION=9.1
 
 # Deploy snapshots to Maven Central
 after_success:
-  - "test $TRAVIS_PULL_REQUEST == 'false' && test $TRAVIS_BRANCH == 'master' && test $PG_VERSION == '9.4' && ./travis_deploy.sh"
+  - "test $MCENTRAL == 'Y' && ./travis_deploy.sh"
diff --git a/README.md b/README.md
index 8c41441710..17834b6ae4 100644
--- a/README.md
+++ b/README.md
@@ -20,41 +20,45 @@ For problems with this driver, refer to driver's [home page](http://jdbc.postgre
 Most people do not need to compile PgJDBC. You can download prebuilt versions of the driver 
 from the [Postgresql JDBC site](http://jdbc.postgresql.org/) or using your chosen dependency management tool:
 
+## Supported PostgreSQL versions
+
+Pgjdbc regression tests are run against PostgreSQL 8.4, 9.1, 9.2, 9.3, 9.4, 9.5, 9.6.
+
 ### Maven
 ```xml
 <dependency>
   <groupId>org.postgresql</groupId>
   <artifactId>postgresql</artifactId>
-  <version>9.4.1207</version> <!-- Java 8 -->
-  <version>9.4.1207.jre7</version> <!-- Java 7 -->
-  <version>9.4.1207.jre6</version> <!-- Java 6 -->
+  <version>9.4.1208</version> <!-- Java 8 -->
+  <version>9.4.1208.jre7</version> <!-- Java 7 -->
+  <version>9.4.1208.jre6</version> <!-- Java 6 -->
 </dependency>
 ```
 ### Gradle
 Java 8:
 ```
-'org.postgresql:postgresql:9.4.1207'
+'org.postgresql:postgresql:9.4.1208'
 ```
 Java 7:
 ```
-'org.postgresql:postgresql:9.4.1207.jre7'
+'org.postgresql:postgresql:9.4.1208.jre7'
 ```
 Java 6:
 ```
-'org.postgresql:postgresql:9.4.1207.jre6'
+'org.postgresql:postgresql:9.4.1208.jre6'
 ```
 ### Ivy
 Java 8:
 ```xml
-<dependency org="org.postgresql" name="postgresql" rev="9.4.1207"/>
+<dependency org="org.postgresql" name="postgresql" rev="9.4.1208"/>
 ```
 Java 7:
 ```xml
-<dependency org="org.postgresql" name="postgresql" rev="9.4.1207.jre7"/>
+<dependency org="org.postgresql" name="postgresql" rev="9.4.1208.jre7"/>
 ```
 Java 6:
 ```xml
-<dependency org="org.postgresql" name="postgresql" rev="9.4.1207.jre6"/>
+<dependency org="org.postgresql" name="postgresql" rev="9.4.1208.jre6"/>
 ```
 
 ### Development snapshots
@@ -64,12 +68,17 @@ Snapshot builds (builds from `master` branch) are deployed to Maven Central, so
 <dependency>
   <groupId>org.postgresql</groupId>
   <artifactId>postgresql</artifactId>
-  <version>9.4.1208-SNAPSHOT</version> <!-- Java 8 -->
-  <version>9.4.1208.jre7-SNAPSHOT</version> <!-- Java 7 -->
-  <version>9.4.1208.jre6-SNAPSHOT</version> <!-- Java 6 -->
+  <version>9.4.1209-SNAPSHOT</version> <!-- Java 8 -->
+  <version>9.4.1209.jre7-SNAPSHOT</version> <!-- Java 7 -->
+  <version>9.4.1209.jre6-SNAPSHOT</version> <!-- Java 6 -->
 </dependency>
 ```
 
+There are also available (snapshot) binary RPMs in Fedora's Copr repository, you
+can download them from:
+https://copr.fedorainfracloud.org/coprs/g/pgjdbc/pgjdbc-travis/
+
+
 ## Build requirements
 
 In order to build the source code for PgJDBC you will need the following tools:
@@ -192,6 +201,9 @@ Git repository typically contains -SNAPSHOT versions, so you can use the followi
 Prerequisites:
 - JDK 6, JDK 7, and JDK8 configured in `~/.m2/toolchains.xml`
 - a PostgreSQL instance for running tests
+- ensure that the RPM packaging CI isn't failing at
+  [copr web page](https://copr.fedorainfracloud.org/coprs/g/pgjdbc/pgjdbc-travis/builds/) -
+  possibly bump `parent poms` or `pgjdbc` versions in RPM [spec file](packaging/rpm/postgresql-jdbc.spec).
 
 Procedure:
 
diff --git a/build.properties b/build.properties
index e23f96a818..14c0e9eddf 100644
--- a/build.properties
+++ b/build.properties
@@ -9,6 +9,7 @@ username=test
 password=test
 privilegedUser=postgres
 privilegedPassword=
+sspiusername=testsspi
 preparethreshold=5
 loglevel=0
 protocolVersion=0
diff --git a/codecov.yml b/codecov.yml
new file mode 100644
index 0000000000..083a32cc25
--- /dev/null
+++ b/codecov.yml
@@ -0,0 +1,10 @@
+codecov:
+  notify:
+    after_n_builds: 7
+    require_ci_to_pass: false
+comment:
+  layout: header, changes, diff
+coverage:
+  status:
+    patch: false
+  range: "60...100"
diff --git a/packaging/rpm/.gitignore b/packaging/rpm/.gitignore
new file mode 100644
index 0000000000..033bcb4f58
--- /dev/null
+++ b/packaging/rpm/.gitignore
@@ -0,0 +1,5 @@
+*.tar.gz
+*.src.rpm
+*.spec
+copr-token
+copr_build_id
diff --git a/packaging/rpm/.srpmgen b/packaging/rpm/.srpmgen
new file mode 100644
index 0000000000..3ccc06d9f0
--- /dev/null
+++ b/packaging/rpm/.srpmgen
@@ -0,0 +1,9 @@
+git:
+  address: 'https://github.com/pgjdbc/pgjdbc.git'
+  rpmsources: packaging/rpm
+
+spec: postgresql-jdbc.spec
+
+source0:
+  git_archive:
+    prefix: postgresql-jdbc-9.5.git
diff --git a/packaging/rpm/copr-token.gpg b/packaging/rpm/copr-token.gpg
new file mode 100644
index 0000000000..e94c7dd8b7
Binary files /dev/null and b/packaging/rpm/copr-token.gpg differ
diff --git a/packaging/rpm/fedora-image/Dockerfile b/packaging/rpm/fedora-image/Dockerfile
new file mode 100644
index 0000000000..e156c91ab9
--- /dev/null
+++ b/packaging/rpm/fedora-image/Dockerfile
@@ -0,0 +1,21 @@
+FROM index.docker.io/fedora:23
+MAINTAINER pgjdbc team
+
+ENV HOME=/rpm
+ENV container="docker"
+
+RUN dnf -y --setopt=tsflags=nodocs install \
+        copr-cli \
+        git \
+        perl \
+        perl-YAML \
+        rpm-build \
+        rpmdevtools \
+    && dnf -y --setopt=tsflags=nodocs clean all --enablerepo='*' \
+    && dnf -y update copr-cli python-copr --enablerepo updates-testing
+
+ADD build_local copr-ci-git srpmgen /usr/bin/
+
+WORKDIR /rpm
+
+CMD ["bash"]
diff --git a/packaging/rpm/fedora-image/build_local b/packaging/rpm/fedora-image/build_local
new file mode 100755
index 0000000000..5a9c26d98f
--- /dev/null
+++ b/packaging/rpm/fedora-image/build_local
@@ -0,0 +1,43 @@
+#!/bin/bash
+
+test -z "$RPMBUILD" && RPMBUILD=rpmbuild
+
+ARR=( )
+
+for i in "$@"; do
+    case "$i" in
+        --copr)
+            ARR+=( --define "_source_filedigest_algorithm md5" )
+            ARR+=( --define "_binary_filedigest_algorithm md5" )
+            ARR+=( --define "dist %nil" )
+            ;;
+
+        *)
+            ARR+=( "$i" )
+            ;;
+    esac
+done
+
+run_rpmbuild()
+{
+    set -x
+    echo "$@"
+
+    $RPMBUILD \
+        --define "_sourcedir $PWD"      \
+        --define "_rpmdir $PWD"         \
+        --define "_specdir $PWD"        \
+        --define "_builddir $PWD"       \
+        --define "_srcrpmdir $PWD"      \
+        --buildroot "$PWD/buildroot"    \
+        "$@"
+}
+
+case "$0" in
+    *build_local_nocheck)
+        ARR+=( --define "runselftest 0" )
+        ARR+=( --without=check )
+        ;;
+esac
+
+run_rpmbuild "${ARR[@]}"
diff --git a/packaging/rpm/fedora-image/copr-ci-git b/packaging/rpm/fedora-image/copr-ci-git
new file mode 100755
index 0000000000..ccbb9b318b
--- /dev/null
+++ b/packaging/rpm/fedora-image/copr-ci-git
@@ -0,0 +1,71 @@
+#! /bin/bash -ex
+
+export TZ=UTC
+
+copr_fe_url=https://copr.fedorainfracloud.org/coprs/g/pgjdbc/pgjdbc-travis/build
+copr_be_link=https://copr-be.cloud.fedoraproject.org/results/@pgjdbc/pgjdbc-travis/fedora-rawhide-x86_64/
+status_file=copr_build_id
+
+copr_wrapper ()
+(
+    set +x
+    echo "running copr-cli wrapper"
+    str="Created builds: "
+
+    copr-cli "$@" 2>&1 | \
+    while read line
+    do
+        echo "$line"
+        case $line in
+        "$str"*)
+            echo "${line##$str}" > "$status_file"
+            ;;
+        esac
+    done
+)
+
+set -o pipefail
+cd "$1"
+git_rev=$(git rev-parse --short=7 HEAD)
+date_rev=$(date +%Y%m%d_%H%M%S)
+release=${date_rev}.git$git_rev
+sed "s!^Release:.*\$!Release: 1.$release%{?dist}!" "$2".spec.tpl > "$2".spec
+srpmgen
+build_local -bs "$2".spec --define "dist %nil"
+copr_wrapper --config "$1"/copr-token build --nowait @pgjdbc/pgjdbc-travis "$2-$3-1.$release.src.rpm"
+copr_build_id=$(cat "$status_file")
+
+concrete_copr_be_link=$copr_be_link$(printf "%08d" "$copr_build_id")-postgresql-jdbc/
+
+set +x
+echo "For build status, logs, etc. have a look at
+$copr_fe_url/$copr_build_id/
+
+Note that there might be multiple builds submitted, particularly if there copr
+is configured to build for multiple versions of Fedora distribution.  For
+concrete build results against latest Fedora version, have a look at:
+$concrete_copr_be_link"
+
+exit_cmd=:
+while :
+do
+    status_output=$(copr --config "$1"/copr-token status "$copr_build_id")
+    case $status_output in
+        succeeded)
+            break
+            ;;
+        failed)
+            exit_cmd=false
+            break
+            ;;
+        *)
+            echo " * build $copr_build_id is in \"$status_output\" state [$(date)]"
+            ;;
+    esac
+    sleep 30
+done
+
+echo " * getting the build log for rawhide chroot"
+curl $concrete_copr_be_link/build.log.gz | gunzip || :
+
+$exit_cmd
diff --git a/packaging/rpm/fedora-image/srpmgen b/packaging/rpm/fedora-image/srpmgen
new file mode 100755
index 0000000000..aa90334a96
--- /dev/null
+++ b/packaging/rpm/fedora-image/srpmgen
@@ -0,0 +1,63 @@
+#! /bin/perl
+
+use YAML;
+use File::Basename;
+
+open (my $config_file, "<", ".srpmgen") or die "Couldn't open file: $!"; 
+
+my ($config) = Load( join('', <$config_file>));
+
+sub info
+{
+    print (" * @_\n");
+}
+
+my @sources = `spectool $config->{spec} -S`;
+if ($? >> 8) {
+    die ("can't successfully run 'spectool'");
+}
+
+sub obtain_source
+{
+    my ($id, $config) = @_;
+
+    if (defined ($config->{git_archive})) {
+        $config = $config->{git_archive};
+        my $topleveldir = `git rev-parse --show-toplevel`;
+        if ($? >> 8) {
+            die ("can't get git top level directory");
+        }
+        chomp ($topleveldir);
+
+        my $pfx = $config->{prefix};
+        system ("git archive --remote $topleveldir --prefix $pfx/ HEAD | gzip > $pfx.tar.gz");
+        if ($? >> 8) {
+            die ("can't generate tarball $pfx.tar.gz");
+        }
+        return;
+    }
+
+    die ("no method specified to obtain sources for '$id'\n");
+}
+
+# Go through all 'SourceN' statements in spec file.
+for my $source_line (@sources)
+{
+    chomp $source_line;
+    my ($id, $source) = split (/ /, $source_line, 2);
+    $id =~ s/:$//;
+    $id = lc ($id);
+
+    if (defined ($config->{$id})) {
+        obtain_source ($id, $config->{$id});
+    }
+
+    my $src_basename = basename ($source);
+    if (! -f "$src_basename") {
+        info ("getting sources $source");
+        system ("wget", "$source");
+        if ($? >> 8) {
+            die ("can't wget $source");
+        }
+    }
+}
diff --git a/packaging/rpm/postgres-testing.sh b/packaging/rpm/postgres-testing.sh
new file mode 100644
index 0000000000..cdaf65b056
--- /dev/null
+++ b/packaging/rpm/postgres-testing.sh
@@ -0,0 +1,173 @@
+#! /bin/sh
+
+# Do some "integration" testing against running PostgreSQL server.
+
+# This file is to be sourced.
+
+: ${PGTESTS_DATADIR=`pwd`/datadir}
+: ${PGTESTS_ADMIN=`id -u -n`}
+: ${PGTESTS_ADMINDB=$PGTESTS_ADMIN}
+: ${PGTESTS_ADMINPASS=$PGTESTS_ADMIN}
+: ${PGTESTS_PORT=54321}
+: ${PGTESTS_SOCKETDIR=/tmp}
+: ${PGTESTS_USERS=test:test}
+: ${PGTESTS_DATABASES=test:test}
+
+# Stop the old cluster and/or remove it's data.
+: ${PGTESTS_STARTCLEANUP=:}
+
+# Cleanup once we exit the script.
+: ${PGTESTS_CLEANUP=:}
+
+# Cleanup once we exit the script.
+: ${PGTESTS_CLEANUP=:}
+
+export PGPORT=$PGTESTS_PORT
+export PGHOST=$PGTESTS_SOCKETDIR
+
+warning ()
+{
+    echo >&2 " ! $*"
+}
+
+
+__trap_cb ()
+{
+    IFS=' '
+    for __func in $__TRAP_ACTIONS
+    do
+        $__func
+    done
+}
+trap __trap_cb EXIT
+
+
+__pgtests_initdb ()
+{
+    initdb "$PGTESTS_DATADIR" -U "$PGTESTS_ADMIN" \
+        --auth-local=peer --auth-host=md5 \
+        ${PGTESTS_LOCALE+--locale="$PGTESTS_LOCALE"}
+}
+
+
+__pgtests_start ()
+{
+    pg_ctl -D "$PGTESTS_DATADIR" -l "$PGTESTS_DATADIR"/start.log start -o "-k $PGTESTS_SOCKETDIR -p $PGTESTS_PORT" -w
+}
+
+
+__pgtests_create_admins_db ()
+{
+    createdb -h "$PGTESTS_SOCKETDIR" "$PGTESTS_ADMINDB" --owner "$PGTESTS_ADMIN" -p "$PGTESTS_PORT"
+}
+
+
+__pgtests_passwd()
+{
+    psql -d postgres --set=user="$1" --set=pass="$2" -tA \
+        <<<"ALTER USER :\"user\" WITH ENCRYPTED PASSWORD :'pass';"
+}
+
+pgtests_start ()
+{
+    unset __TRAP_ACTIONS
+
+    if $PGTESTS_STARTCLEANUP; then
+        # We don't plan to be serious here.  This pgtests_* effort is just to
+        # ease _testing_ against running postgresql server without too much
+        # writing.
+        if test -f "$PGTESTS_DATADIR"/postmaster.pid; then
+            # Give it a try.
+            warning "Seems like server works, trying to stop."
+            pg_ctl stop -D "$PGTESTS_DATADIR" -w
+        fi
+
+        # Cleanup testing directory
+        if test -e "$PGTESTS_DATADIR"; then
+            warning "Removing old data directory."
+            rm -r "$PGTESTS_DATADIR"
+        fi
+    fi
+
+    __pgtests_initdb && __TRAP_ACTIONS="pgtests_cleanup $__TRAP_ACTIONS"
+    __pgtests_start  && __TRAP_ACTIONS="pgtests_stop $__TRAP_ACTIONS"
+    __pgtests_create_admins_db
+
+    __pgtests_passwd "$PGTESTS_ADMIN" "$PGTESTS_ADMINPASS"
+
+
+    for _pgt_user in $PGTESTS_USERS
+    do
+        save_IFS=$IFS
+        IFS=:
+        _user=
+        _pass=
+        for _part in $_pgt_user
+        do
+            if test -z "$_user"; then
+                _user=$_part
+            else
+                _pass=$_part
+            fi
+        done
+
+        createuser "$_user"
+        __pgtests_passwd "$_user" "$_pass"
+        IFS=$save_IFS
+    done
+
+
+    for _pgt_db in $PGTESTS_DATABASES
+    do
+        save_IFS=$IFS
+        IFS=:
+        _db=
+        _user=
+        for _part in $_pgt_db
+        do
+            if test -z "$_user"; then
+                _user=$_part
+            else
+                _db=$_part
+            fi
+        done
+
+        createdb "$_db" --owner "$_part"
+
+        IFS=$save_IFS
+    done
+}
+
+
+__clean_trap_action ()
+{
+    __new_actions=
+    for __action in $__TRAP_ACTIONS
+    do
+        if test "$__action" = "$1"; then
+            :
+        else
+            __new_actions="$__action $__new_actions"
+        fi
+    done
+
+    __TRAP_ACTIONS=$__new_actions
+}
+
+
+pgtests_cleanup ()
+{
+    if $PGTESTS_CLEANUP && $PGTESTS_AUTOSTOP; then
+        rm -r "$PGTESTS_DATADIR"
+    fi
+    __clean_trap_action pgtests_cleanup
+}
+
+
+pgtests_stop ()
+{
+    if $PGTESTS_AUTOSTOP; then
+        pg_ctl stop -D "$PGTESTS_DATADIR" -w
+    fi
+    __clean_trap_action pgtests_stop
+}
diff --git a/packaging/rpm/postgresql-jdbc.spec.tpl b/packaging/rpm/postgresql-jdbc.spec.tpl
new file mode 100644
index 0000000000..75f352e3d4
--- /dev/null
+++ b/packaging/rpm/postgresql-jdbc.spec.tpl
@@ -0,0 +1,377 @@
+# Copyright (c) 2000-2005, JPackage Project
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the
+#    distribution.
+# 3. Neither the name of the JPackage Project nor the names of its
+#    contributors may be used to endorse or promote products derived
+#    from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+# Configuration for rpmbuild, might be specified by options
+# like e.g. 'rpmbuild --define "runselftest 0"'.
+
+%{!?runselftest:%global runselftest 1}
+
+
+%global section		devel
+%global upstreamrel	git
+%global source_path	pgjdbc/src/main/java/org/postgresql
+%global parent_ver	1.0.8
+%global parent_poms_builddir	./pgjdbc-parent-poms
+
+%global pgjdbc_mvn_options -DwaffleEnabled=false -DosgiEnabled=false \\\
+    -DexcludePackageNames=org.postgresql.osgi:org.postgresql.sspi
+
+Summary:	JDBC driver for PostgreSQL
+Name:		postgresql-jdbc
+Version:	9.5.%{upstreamrel}
+Release:	1%{?dist}
+# ASL 2.0 applies only to postgresql-jdbc.pom file, the rest is BSD
+License:	BSD and ASL 2.0
+Group:		Applications/Databases
+URL:		http://jdbc.postgresql.org/
+
+SOURCE0:	%{name}-%{version}.tar.gz
+Source1:	postgres-testing.sh
+
+# Upstream moved parent pom.xml into separate project (even though there is only
+# one dependant project on it?).  Let's try to not complicate packaging by
+# having separate spec file for it, too.
+Source2:	https://github.com/pgjdbc/pgjdbc-parent-poms/archive/REL%parent_ver.tar.gz
+
+BuildArch:	noarch
+BuildRequires:	java-devel >= 1.8
+BuildRequires:	jpackage-utils
+BuildRequires:	maven-local
+BuildRequires:	java-comment-preprocessor
+BuildRequires:	properties-maven-plugin
+BuildRequires:	maven-enforcer-plugin
+BuildRequires:	maven-plugin-bundle
+BuildRequires:	maven-plugin-build-helper
+
+%if %runselftest
+BuildRequires:	postgresql-server
+BuildRequires:	postgresql-contrib
+%endif
+
+# gettext is only needed if we try to update translations
+#BuildRequires:	gettext
+Requires:	jpackage-utils
+Requires:	java-headless >= 1:1.8
+
+%description
+PostgreSQL is an advanced Object-Relational database management
+system. The postgresql-jdbc package includes the .jar files needed for
+Java programs to access a PostgreSQL database.
+
+
+%package	parent-poms
+Summary:	Build dependency management for pgjdbc.
+
+%description parent-poms
+Pom files bringing dependencies required for successful PostgreSQL JDBC driver
+build.
+
+
+%package javadoc
+Summary:	API docs for %{name}
+Group:		Documentation
+
+%description javadoc
+This package contains the API Documentation for %{name}.
+
+
+%prep
+%setup -c -q -a 2
+
+mv %name-%version/* .
+mv ./pgjdbc-parent-poms-REL%parent_ver %parent_poms_builddir
+
+# remove any binary libs
+find -name "*.jar" -or -name "*.class" | xargs rm -f
+
+
+%pom_disable_module ubenchmark
+
+# Hack #0!  For upstream it is to some extent important to have the parent-poms
+# project separated.  Having it like that on downstream level does not help at
+# all.  Note that we have to revert this patch before we do the installation.
+sed -i.hack-parent-poms \
+  's!<relativePath />!<relativePath>../pgjdbc-parent-poms/pgjdbc-core-parent/pom.xml</relativePath>!' \
+  pgjdbc/pom.xml
+sed -i.hack-parent-poms \
+  '/<artifactId>pgjdbc-versions/a <relativePath>pgjdbc-parent-poms/pgjdbc-versions/pom.xml</relativePath>' \
+  pom.xml
+
+# Hack #1!  This directory is missing for some reason, it is most probably some
+# misunderstanding between maven, maven-compiler-plugin and
+# java-comment-preprocessor?  Not solved yet.  See rhbz#1325060.
+mkdir -p pgjdbc/target/generated-sources/annotations
+
+
+%build
+# Ideally we would run "sh update-translations.sh" here, but that results
+# in inserting the build timestamp into the generated messages_*.class
+# files, which makes rpmdiff complain about multilib conflicts if the
+# different platforms don't build in the same minute.  For now, rely on
+# upstream to have updated the translations files before packaging.
+
+# Include PostgreSQL testing methods and variables.
+%if %runselftest
+. %{SOURCE1}
+
+PGTESTS_LOCALE=C.UTF-8
+
+cat <<EOF > build.local.properties
+server=localhost
+port=$PGTESTS_PORT
+database=test
+username=test
+password=test
+privilegedUser=$PGTESTS_ADMIN
+privilegedPassword=$PGTESTS_ADMINPASS
+preparethreshold=5
+loglevel=0
+protocolVersion=0
+EOF
+
+# Start the local PG cluster.
+pgtests_start
+%endif
+
+# First "build" the parent-poms ..
+cd %parent_poms_builddir
+%mvn_build -- %pgjdbc_mvn_options
+cd ..
+# .. and then build pgjdbc.
+
+%if %runselftest
+%mvn_build -- %pgjdbc_mvn_options
+%else
+%mvn_build -- %pgjdbc_mvn_options -Dmaven.test.skip=true
+%endif
+
+# Hack #0!  Revert the patch above.
+for i in `find -name '*.hack-parent-poms'`
+do
+	mv $i ${i%%%%.hack-parent-poms}
+done
+
+
+%install
+%mvn_install
+cd %parent_poms_builddir
+%mvn_install
+
+pushd $RPM_BUILD_ROOT%{_javadir}
+# Also, for backwards compatibility with our old postgresql-jdbc packages,
+# add these symlinks.  (Probably only the jdbc3 symlink really makes sense?)
+ln -s %{name}/postgresql.jar postgresql-jdbc.jar
+ln -s %{name}/postgresql.jar postgresql-jdbc2.jar
+ln -s %{name}/postgresql.jar postgresql-jdbc2ee.jar
+ln -s %{name}/postgresql.jar postgresql-jdbc3.jar
+popd
+
+
+%check
+
+
+%files -f .mfiles
+%license LICENSE
+%doc README.md
+%{_javadir}/%{name}.jar
+%{_javadir}/%{name}2.jar
+%{_javadir}/%{name}2ee.jar
+%{_javadir}/%{name}3.jar
+
+%files parent-poms -f %parent_poms_builddir/.mfiles
+
+%files javadoc
+%license LICENSE
+%doc %{_javadocdir}/%{name}
+
+
+%changelog
+* Wed Jun 01 2016 Pavel Raiskup <praiskup@redhat.com> - 9.5.git-1
+- update to work with tarball from git version of jdbc
+
+* Wed Apr 13 2016 Pavel Raiskup <praiskup@redhat.com> - 9.4.1208-8
+- merge parent-poms and pgjdbc downstream (having separate package does not seem
+  to be necessary at all)
+
+* Tue Apr 12 2016 Pavel Raiskup <praiskup@redhat.com> - 9.4.1208-7
+- fix testsuite for fedora 24
+
+* Tue Apr 12 2016 Pavel Kajaba <pkajaba@redhat.com> - 9.4.1208-6
+- Added script to enable testing
+
+* Fri Apr 08 2016 Pavel Raiskup <praiskup@redhat.com> - 9.4.1208-5
+- enable testsuite for each build, to-be-fixed-yet
+
+* Fri Apr 08 2016 Pavel Raiskup <praiskup@redhat.com> - 9.4.1208-4
+- apply the work-around for maven-compiler-plugin && jcp issue
+
+* Fri Apr 08 2016 Pavel Raiskup <praiskup@redhat.com> - 9.4.1208-3
+- bump
+
+* Thu Jun 18 2015 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 9.4.1200-2
+- Rebuilt for https://fedoraproject.org/wiki/Fedora_23_Mass_Rebuild
+
+* Wed Feb 04 2015 Pavel Raiskup <praiskup@redhat.com> - 9.4.1200-1
+- rebase to most recent version (#1188827)
+
+* Mon Jul 14 2014 Pavel Raiskup <praiskup@redhat.com> - 9.3.1102-1
+- Rebase to most recent version (#1118667)
+- revert back upstream commit for travis build
+
+* Sat Jun 07 2014 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 9.3.1101-4
+- Rebuilt for https://fedoraproject.org/wiki/Fedora_21_Mass_Rebuild
+
+* Mon May 19 2014 Pavel Raiskup <praiskup@redhat.com> - 9.3.1101-3
+- run upstream testsuite when '%%runselftest' defined
+
+* Wed Apr 23 2014 Mikolaj Izdebski <mizdebsk@redhat.com> - 9.3.1101-2
+- Add explicit requires on java-headless
+
+* Wed Apr 23 2014 Pavel Raiskup <praiskup@redhat.com> - 9.3.1101-1
+- Rebase to most recent version (#1090366)
+
+* Fri Mar 28 2014 Michael Simacek <msimacek@redhat.com> - 9.2.1002-5
+- Use Requires: java-headless rebuild (#1067528)
+
+* Tue Aug 06 2013 Pavel Raiskup <praiskup@redhat.com> - 9.2.1002-4
+- add javadoc subpackage
+
+* Tue Aug 06 2013 Pavel Raiskup <praiskup@redhat.com> - 9.2.1002-4
+- don't use removed macro %%add_to_maven_depmap (#992816)
+- lint: trim-lines, reuse %%{name} macro, fedora-review fixes
+- merge cleanup changes by Stano Ochotnicky
+
+* Sun Aug 04 2013 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 9.2.1002-3
+- Rebuilt for https://fedoraproject.org/wiki/Fedora_20_Mass_Rebuild
+
+* Thu Feb 14 2013 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 9.2.1002-2
+- Rebuilt for https://fedoraproject.org/wiki/Fedora_19_Mass_Rebuild
+
+* Wed Nov 14 2012 Tom Lane <tgl@redhat.com> 9.2.1002-1
+- Update to build 9.2-1002 (just to correct mispackaging of source tarball)
+
+* Tue Nov 13 2012 Tom Lane <tgl@redhat.com> 9.2.1001-1
+- Update to build 9.2-1001 for compatibility with PostgreSQL 9.2
+
+* Sun Jul 22 2012 Tom Lane <tgl@redhat.com> 9.1.902-1
+- Update to build 9.1-902
+
+* Sat Jul 21 2012 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 9.1.901-4
+- Rebuilt for https://fedoraproject.org/wiki/Fedora_18_Mass_Rebuild
+
+* Thu Feb 23 2012 Tom Lane <tgl@redhat.com> 9.1.901-3
+- Change BuildRequires: java-1.6.0-openjdk-devel to just java-devel.
+  As of 9.1-901, upstream has support for JDBC4.1, so we don't have to
+  restrict to JDK6 anymore, and Fedora is moving to JDK7
+Resolves: #796580
+
+* Sat Jan 14 2012 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 9.1.901-2
+- Rebuilt for https://fedoraproject.org/wiki/Fedora_17_Mass_Rebuild
+
+* Mon Sep 12 2011 Tom Lane <tgl@redhat.com> 9.1.901-1
+- Update to build 9.1-901 for compatibility with PostgreSQL 9.1
+
+* Mon Aug 15 2011 Tom Lane <tgl@redhat.com> 9.0.801-4
+- Add BuildRequires: java-1.6.0-openjdk-devel to ensure we have recent JDK
+Related: #730588
+- Remove long-obsolete minimum versions from BuildRequires
+
+* Sun Jul 17 2011 Tom Lane <tgl@redhat.com> 9.0.801-3
+- Switch to non-GCJ build, since GCJ is now deprecated in Fedora
+Resolves: #722247
+- Use %%{_mavendepmapfragdir} to fix FTBFS with maven 3
+
+* Wed Feb 09 2011 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 9.0.801-2
+- Rebuilt for https://fedoraproject.org/wiki/Fedora_15_Mass_Rebuild
+
+* Wed Dec 29 2010 Tom Lane <tgl@redhat.com> 9.0.801-1
+- Update to build 9.0-801
+
+* Mon May 31 2010 Tom Lane <tgl@redhat.com> 8.4.701-4
+- Update gcj_support sections to meet Packaging/GCJGuidelines;
+  fixes FTBFS in F-14 rawhide
+
+* Tue Nov 24 2009 Tom Lane <tgl@redhat.com> 8.4.701-3
+- Seems the .pom file *must* have a package version number in it, sigh
+Resolves: #538487
+
+* Mon Nov 23 2009 Tom Lane <tgl@redhat.com> 8.4.701-2
+- Add a .pom file to ease use by maven-based packages (courtesy Deepak Bhole)
+Resolves: #538487
+
+* Tue Aug 18 2009 Tom Lane <tgl@redhat.com> 8.4.701-1
+- Update to build 8.4-701
+
+* Sun Jul 26 2009 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 0:8.3.603-4
+- Rebuilt for https://fedoraproject.org/wiki/Fedora_12_Mass_Rebuild
+
+* Tue Apr 21 2009 Tom Lane <tgl@redhat.com> 8.3.603-3
+- Avoid multilib conflict caused by overeager attempt to rebuild translations
+
+* Thu Feb 26 2009 Fedora Release Engineering <rel-eng@lists.fedoraproject.org> - 0:8.3.603-2.1
+- Rebuilt for https://fedoraproject.org/wiki/Fedora_11_Mass_Rebuild
+
+* Wed Jul  9 2008 Tom "spot" Callaway <tcallawa@redhat.com> 8.3.603-1.1
+- drop repotag
+
+* Tue Feb 12 2008 Tom Lane <tgl@redhat.com> 8.3.603-1jpp
+- Update to build 8.3-603
+
+* Sun Aug 12 2007 Tom Lane <tgl@redhat.com> 8.2.506-1jpp
+- Update to build 8.2-506
+
+* Tue Apr 24 2007 Tom Lane <tgl@redhat.com> 8.2.505-1jpp
+- Update to build 8.2-505
+- Work around 1.4 vs 1.5 versioning inconsistency
+
+* Fri Dec 15 2006 Tom Lane <tgl@redhat.com> 8.2.504-1jpp
+- Update to build 8.2-504
+
+* Wed Aug 16 2006 Tom Lane <tgl@redhat.com> 8.1.407-1jpp.4
+- Fix Requires: for rebuild-gcj-db (bz #202544)
+
+* Wed Aug 16 2006 Fernando Nasser <fnasser@redhat.com> 8.1.407-1jpp.3
+- Merge with upstream
+
+* Sat Jul 22 2006 Jakub Jelinek <jakub@redhat.com> 8.1.407-1jpp.2
+- Rebuilt
+
+* Wed Jul 12 2006 Jesse Keating <jkeating@redhat.com> - 0:8.1.407-1jpp.1
+- rebuild
+
+* Wed Jun 14 2006 Tom Lane <tgl@redhat.com> 8.1.407-1jpp
+- Update to build 8.1-407
+
+* Mon Mar 27 2006 Tom Lane <tgl@redhat.com> 8.1.405-2jpp
+- Back-patch upstream fix to support unspecified-type strings.
+
+* Thu Feb 16 2006 Tom Lane <tgl@redhat.com> 8.1.405-1jpp
+- Split postgresql-jdbc into its own SRPM (at last).
+- Build it from source.  Add support for gcj compilation.
diff --git a/packaging/rpm_ci b/packaging/rpm_ci
new file mode 100755
index 0000000000..be6b892c23
--- /dev/null
+++ b/packaging/rpm_ci
@@ -0,0 +1,19 @@
+#! /bin/sh -xe
+
+# Go to correct directory.
+cd "$(dirname "$0")"
+
+# Decrypt copr token.  For security reasons, the security variable is not
+# exported in case of pull request -> thus this is going to fail.
+(
+    set +x +e # pssst!
+    echo "$copr_token_password" | gpg --batch --passphrase-fd 0 rpm/copr-token.gpg
+) || exit 0
+
+# If we have SELinux box, setup correct docker label
+if test -x /bin/chcon ; then
+    chcon -R -t svirt_sandbox_file_t ..
+fi
+
+docker run -e HOME=/git -u `id -u` -ti --rm -v `pwd`/..:/git praiskup/copr-and-jdbc-ci \
+    copr-ci-git /git/packaging/rpm postgresql-jdbc 9.5.git
diff --git a/pgjdbc/pom.xml b/pgjdbc/pom.xml
index 39c482fc2b..b3d5c54ac7 100644
--- a/pgjdbc/pom.xml
+++ b/pgjdbc/pom.xml
@@ -3,14 +3,14 @@
   <parent>
     <groupId>org.postgresql</groupId>
     <artifactId>pgjdbc-core-parent</artifactId>
-    <version>1.0.5</version>
+    <version>1.0.8</version>
     <relativePath />
   </parent>
 
   <artifactId>postgresql</artifactId>
   <packaging>bundle</packaging>
   <name>PostgreSQL JDBC Driver - JDBC 4.2</name>
-  <version>9.4.1208</version>
+  <version>9.4.1209</version>
   <description>Java JDBC 4.2 (JRE 8+) driver for PostgreSQL database</description>
   <url>https://github.com/pgjdbc/pgjdbc</url>
 
@@ -113,6 +113,128 @@
         </plugins>
       </build>
     </profile>
+
+    <profile>
+      <id>excludeWaffleFiles</id>
+      <activation>
+        <property>
+          <name>waffleEnabled</name>
+          <value>false</value>
+        </property>
+      </activation>
+      <build>
+        <plugins>
+          <plugin>
+            <groupId>org.apache.maven.plugins</groupId>
+            <artifactId>maven-compiler-plugin</artifactId>
+            <configuration>
+              <excludes combine.children="append">
+                <exclude>org/postgresql/sspi/NTDSAPI.java</exclude>
+                <exclude>org/postgresql/sspi/NTDSAPIWrapper.java</exclude>
+                <exclude>org/postgresql/sspi/SSPIClient.java</exclude>
+              </excludes>
+              <testExcludes>
+                <exclude>org/postgresql/test/sspi/*.java</exclude>
+              </testExcludes>
+            </configuration>
+          </plugin>
+        </plugins>
+      </build>
+    </profile>
+
+    <profile>
+      <id>excludeOsgiFiles</id>
+      <activation>
+        <property>
+          <name>osgiEnabled</name>
+          <value>false</value>
+        </property>
+      </activation>
+      <build>
+        <plugins>
+          <plugin>
+            <groupId>org.apache.maven.plugins</groupId>
+            <artifactId>maven-compiler-plugin</artifactId>
+            <configuration>
+              <excludes combine.children="append">
+                <exclude>org/postgresql/osgi/PGBundleActivator.java</exclude>
+                <exclude>org/postgresql/osgi/PGDataSourceFactory.java</exclude>
+              </excludes>
+              <testExcludes combine.children="append">
+                <exclude>**/PGDataSourceFactoryTest.java</exclude>
+                <exclude>**/OsgiTestSuite.java</exclude>
+              </testExcludes>
+            </configuration>
+          </plugin>
+          <plugin>
+            <groupId>org.apache.maven.plugins</groupId>
+            <artifactId>maven-surefire-plugin</artifactId>
+            <configuration>
+              <excludes>
+                <exclude>**/OsgiTestSuite.java</exclude>
+                <exclude>**/PGDataSourceFactoryTest.java</exclude>
+              </excludes>
+            </configuration>
+          </plugin>
+        </plugins>
+      </build>
+    </profile>
+
+    <profile>
+      <id>jdk9-workarounds</id>
+      <!-- see https://github.com/pgjdbc/pgjdbc/pull/565 -->
+      <activation>
+        <property>
+          <name>javac.target</name>
+          <value>1.9</value>
+        </property>
+      </activation>
+      <build>
+        <pluginManagement>
+          <plugins>
+            <plugin>
+              <groupId>org.apache.maven.plugins</groupId>
+              <artifactId>maven-source-plugin</artifactId>
+              <dependencies>
+                <dependency>
+                  <groupId>org.codehaus.plexus</groupId>
+                  <artifactId>plexus-archiver</artifactId>
+                  <version>2.4.4</version>
+                  <!-- newer versions fail as described in http://stackoverflow.com/a/36605759/1261287
+                       Caused by: java.lang.ArrayIndexOutOfBoundsException: 1
+                        at org.codehaus.plexus.archiver.zip.AbstractZipArchiver.<clinit>(AbstractZipArchiver.java:116)
+                  -->
+                </dependency>
+              </dependencies>
+            </plugin>
+            <plugin>
+              <groupId>org.apache.maven.plugins</groupId>
+              <artifactId>maven-jar-plugin</artifactId>
+              <dependencies>
+                <dependency>
+                  <groupId>org.codehaus.plexus</groupId>
+                  <artifactId>plexus-archiver</artifactId>
+                  <version>2.4.4</version>
+                </dependency>
+              </dependencies>
+            </plugin>
+            <plugin>
+              <groupId>org.apache.maven.plugins</groupId>
+              <artifactId>maven-assembly-plugin</artifactId>
+              <version>2.4.1</version> <!-- override version to older one -->
+              <dependencies>
+                <dependency>
+                  <groupId>org.codehaus.plexus</groupId>
+                  <artifactId>plexus-archiver</artifactId>
+                  <version>2.4.4</version>
+                </dependency>
+              </dependencies>
+            </plugin>
+          </plugins>
+        </pluginManagement>
+      </build>
+    </profile>
+
   </profiles>
 
   <build>
@@ -155,6 +277,6 @@
   </build>
 
   <scm>
-    <tag>REL9.4.1208</tag>
+    <tag>REL9.4.1209</tag>
   </scm>
 </project>
diff --git a/pgjdbc/src/main/java/org/postgresql/Driver.java b/pgjdbc/src/main/java/org/postgresql/Driver.java
index 7e30803817..1d372a599c 100644
--- a/pgjdbc/src/main/java/org/postgresql/Driver.java
+++ b/pgjdbc/src/main/java/org/postgresql/Driver.java
@@ -19,6 +19,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
+import java.net.URLDecoder;
 import java.security.AccessController;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
@@ -416,10 +417,7 @@ private static Connection makeConnection(String url, Properties props) throws SQ
    * @see java.sql.Driver#acceptsURL
    */
   public boolean acceptsURL(String url) {
-    if (parseURL(url, null) == null) {
-      return false;
-    }
-    return true;
+    return parseURL(url, null) != null;
   }
 
   /**
@@ -497,8 +495,6 @@ public boolean jdbcCompliant() {
     return false;
   }
 
-  static private String[] protocols = {"jdbc", "postgresql"};
-
   /**
    * Constructs a new DriverURL, splitting the specified URL into its component parts
    *
@@ -529,7 +525,7 @@ public static Properties parseURL(String url, Properties defaults) {
       if (slash == -1) {
         return null;
       }
-      urlProps.setProperty("PGDBNAME", l_urlServer.substring(slash + 1));
+      urlProps.setProperty("PGDBNAME", URLDecoder.decode(l_urlServer.substring(slash + 1)));
 
       String[] addresses = l_urlServer.substring(0, slash).split(",");
       StringBuilder hosts = new StringBuilder();
@@ -541,7 +537,9 @@ public static Properties parseURL(String url, Properties defaults) {
         if (portIdx != -1 && address.lastIndexOf(']') < portIdx) {
           String portStr = address.substring(portIdx + 1);
           try {
-            Integer.parseInt(portStr);
+            // squid:S2201 The return value of "parseInt" must be used.
+            // The side effect is NumberFormatException, thus ignore sonar error here
+            Integer.parseInt(portStr); //NOSONAR
           } catch (NumberFormatException ex) {
             return null;
           }
@@ -561,21 +559,20 @@ public static Properties parseURL(String url, Properties defaults) {
     } else {
       urlProps.setProperty("PGPORT", "/*$mvn.project.property.template.default.pg.port$*/");
       urlProps.setProperty("PGHOST", "localhost");
-      urlProps.setProperty("PGDBNAME", l_urlServer);
+      urlProps.setProperty("PGDBNAME", URLDecoder.decode(l_urlServer));
     }
 
     // parse the args part of the url
     String[] args = l_urlArgs.split("&");
-    for (int i = 0; i < args.length; ++i) {
-      String token = args[i];
-      if (token.length() == 0) {
+    for (String token : args) {
+      if (token.isEmpty()) {
         continue;
       }
       int l_pos = token.indexOf('=');
       if (l_pos == -1) {
         urlProps.setProperty(token, "");
       } else {
-        urlProps.setProperty(token.substring(0, l_pos), token.substring(l_pos + 1));
+        urlProps.setProperty(token.substring(0, l_pos), URLDecoder.decode(token.substring(l_pos + 1)));
       }
     }
 
diff --git a/pgjdbc/src/main/java/org/postgresql/PGConnection.java b/pgjdbc/src/main/java/org/postgresql/PGConnection.java
index f3289e376a..b83a0bcf5e 100644
--- a/pgjdbc/src/main/java/org/postgresql/PGConnection.java
+++ b/pgjdbc/src/main/java/org/postgresql/PGConnection.java
@@ -29,7 +29,7 @@ public interface PGConnection {
    * @throws SQLException if something wrong happens
    * @since 7.3
    */
-  public PGNotification[] getNotifications() throws SQLException;
+  PGNotification[] getNotifications() throws SQLException;
 
   /**
    * This returns the COPY API for the current connection.
@@ -38,7 +38,7 @@ public interface PGConnection {
    * @throws SQLException if something wrong happens
    * @since 8.4
    */
-  public CopyManager getCopyAPI() throws SQLException;
+  CopyManager getCopyAPI() throws SQLException;
 
   /**
    * This returns the LargeObject API for the current connection.
@@ -47,7 +47,7 @@ public interface PGConnection {
    * @throws SQLException if something wrong happens
    * @since 7.3
    */
-  public LargeObjectManager getLargeObjectAPI() throws SQLException;
+  LargeObjectManager getLargeObjectAPI() throws SQLException;
 
   /**
    * This returns the Fastpath API for the current connection.
@@ -56,7 +56,7 @@ public interface PGConnection {
    * @throws SQLException if something wrong happens
    * @since 7.3
    */
-  public Fastpath getFastpathAPI() throws SQLException;
+  Fastpath getFastpathAPI() throws SQLException;
 
   /**
    * This allows client code to add a handler for one of org.postgresql's more unique data types. It
@@ -69,7 +69,7 @@ public interface PGConnection {
    *             does not work correctly for registering classes that cannot be directly loaded by
    *             the JDBC driver's classloader.
    */
-  public void addDataType(String type, String className);
+  void addDataType(String type, String className);
 
   /**
    * This allows client code to add a handler for one of org.postgresql's more unique data types.
@@ -100,7 +100,7 @@ public interface PGConnection {
    * @see org.postgresql.util.PGobject
    * @since 8.0
    */
-  public void addDataType(String type, Class<? extends PGobject> klass) throws SQLException;
+  void addDataType(String type, Class<? extends PGobject> klass) throws SQLException;
 
   /**
    * Set the default statement reuse threshold before enabling server-side prepare. See
@@ -109,7 +109,7 @@ public interface PGConnection {
    * @param threshold the new threshold
    * @since build 302
    */
-  public void setPrepareThreshold(int threshold);
+  void setPrepareThreshold(int threshold);
 
   /**
    * Get the default server-side prepare reuse threshold for statements created from this
@@ -118,7 +118,7 @@ public interface PGConnection {
    * @return the current threshold
    * @since build 302
    */
-  public int getPrepareThreshold();
+  int getPrepareThreshold();
 
   /**
    * Set the default fetch size for statements created from this connection
@@ -127,7 +127,7 @@ public interface PGConnection {
    * @throws SQLException if specified negative <code>fetchSize</code> parameter
    * @see Statement#setFetchSize(int)
    */
-  public void setDefaultFetchSize(int fetchSize) throws SQLException;
+  void setDefaultFetchSize(int fetchSize) throws SQLException;
 
 
   /**
@@ -137,14 +137,14 @@ public interface PGConnection {
    * @see PGProperty#DEFAULT_ROW_FETCH_SIZE
    * @see Statement#getFetchSize()
    */
-  public int getDefaultFetchSize();
+  int getDefaultFetchSize();
 
   /**
    * Return the process ID (PID) of the backend server process handling this connection.
    *
    * @return PID of backend server process.
    */
-  public int getBackendPID();
+  int getBackendPID();
 
   /**
    * Return the given string suitably quoted to be used as an identifier in an SQL statement string.
@@ -155,7 +155,7 @@ public interface PGConnection {
    * @return the escaped identifier
    * @throws SQLException if something goes wrong
    */
-  public String escapeIdentifier(String identifier) throws SQLException;
+  String escapeIdentifier(String identifier) throws SQLException;
 
   /**
    * Return the given string suitably quoted to be used as a string literal in an SQL statement
@@ -166,5 +166,5 @@ public interface PGConnection {
    * @return the quoted literal
    * @throws SQLException if something goes wrong
    */
-  public String escapeLiteral(String literal) throws SQLException;
+  String escapeLiteral(String literal) throws SQLException;
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/PGNotification.java b/pgjdbc/src/main/java/org/postgresql/PGNotification.java
index f02e886ff1..ef31e4d038 100644
--- a/pgjdbc/src/main/java/org/postgresql/PGNotification.java
+++ b/pgjdbc/src/main/java/org/postgresql/PGNotification.java
@@ -18,7 +18,7 @@ public interface PGNotification {
    * @return name of this notification
    * @since 7.3
    */
-  public String getName();
+  String getName();
 
   /**
    * Returns the process id of the backend process making this notification
@@ -26,7 +26,7 @@ public interface PGNotification {
    * @return process id of the backend process making this notification
    * @since 7.3
    */
-  public int getPID();
+  int getPID();
 
   /**
    * Returns additional information from the notifying process. This feature has only been
@@ -36,5 +36,5 @@ public interface PGNotification {
    * @return additional information from the notifying process
    * @since 8.0
    */
-  public String getParameter();
+  String getParameter();
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/PGProperty.java b/pgjdbc/src/main/java/org/postgresql/PGProperty.java
index 42a5864238..9270902870 100644
--- a/pgjdbc/src/main/java/org/postgresql/PGProperty.java
+++ b/pgjdbc/src/main/java/org/postgresql/PGProperty.java
@@ -83,6 +83,18 @@ public enum PGProperty {
   PREPARED_STATEMENT_CACHE_SIZE_MIB("preparedStatementCacheSizeMiB", "5",
       "Specifies the maximum size (in megabytes) of a per-connection prepared statement cache. A value of {@code 0} disables the cache."),
 
+  /**
+   * Specifies the maximum number of fields to be cached per connection. A value of {@code 0} disables the cache.
+   */
+  DATABASE_METADATA_CACHE_FIELDS("databaseMetadataCacheFields", "65536",
+          "Specifies the maximum number of fields to be cached per connection. A value of {@code 0} disables the cache."),
+
+  /**
+   * Specifies the maximum number of fields to be cached per connection. A value of {@code 0} disables the cache.
+   */
+  DATABASE_METADATA_CACHE_FIELDS_MIB("databaseMetadataCacheFieldsMiB", "5",
+          "Specifies the maximum size (in megabytes) of fields to be cached per connection. A value of {@code 0} disables the cache."),
+
   /**
    * Default parameter for {@link java.sql.Statement#getFetchSize()}. A value of {@code 0} means
    * that need fetch all rows at once
@@ -228,7 +240,7 @@ public enum PGProperty {
    * <p>
    * The timeout is specified in seconds and a value of zero means that it is disabled.
    */
-  CONNECT_TIMEOUT("connectTimeout", "0", "The timeout value used for socket connect operations."),
+  CONNECT_TIMEOUT("connectTimeout", "10", "The timeout value used for socket connect operations."),
 
   /**
    * The timeout value used for socket read operations. If reading from the server takes longer than
@@ -238,6 +250,14 @@ public enum PGProperty {
    */
   SOCKET_TIMEOUT("socketTimeout", "0", "The timeout value used for socket read operations."),
 
+  /**
+   * Cancel command is sent out of band over its own connection, so cancel message can itself get
+   * stuck.
+   * This property controls "connect timeout" and "socket timeout" used for cancel commands.
+   * The timeout is specified in seconds. Default value is 10 seconds.
+   */
+  CANCEL_SIGNAL_TIMEOUT("cancelSignalTimeout", "10", "The timeout that is used for sending cancel command."),
+
   /**
    * Socket factory used to create socket. A null value, which is the default, means system default.
    */
@@ -334,7 +354,13 @@ public enum PGProperty {
       "If disabled hosts are connected in the given order. If enabled hosts are chosen randomly from the set of suitable candidates"),
 
   HOST_RECHECK_SECONDS("hostRecheckSeconds", "10",
-      "Specifies period (seconds) after host statuses are checked again in case they have changed");
+      "Specifies period (seconds) after host statuses are checked again in case they have changed"),
+
+  /**
+   * Configure optimization to enable batch insert re-writing.
+   */
+  REWRITE_BATCHED_INSERTS ("reWriteBatchedInserts", "false",
+      "Enable optimization to rewrite and collapse compatible INSERT statements that are batched.");
 
   private String _name;
   private String _defaultValue;
diff --git a/pgjdbc/src/main/java/org/postgresql/PGRefCursorResultSet.java b/pgjdbc/src/main/java/org/postgresql/PGRefCursorResultSet.java
index 1ea9d86e64..0bd80282a0 100644
--- a/pgjdbc/src/main/java/org/postgresql/PGRefCursorResultSet.java
+++ b/pgjdbc/src/main/java/org/postgresql/PGRefCursorResultSet.java
@@ -22,5 +22,5 @@ public interface PGRefCursorResultSet {
    * @deprecated As of 8.0, replaced with calling getString() on the ResultSet that this ResultSet
    *             was obtained from.
    */
-  public String getRefCursor();
+  String getRefCursor();
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/PGResultSetMetaData.java b/pgjdbc/src/main/java/org/postgresql/PGResultSetMetaData.java
index b3e94adbfd..54a9360cd2 100644
--- a/pgjdbc/src/main/java/org/postgresql/PGResultSetMetaData.java
+++ b/pgjdbc/src/main/java/org/postgresql/PGResultSetMetaData.java
@@ -22,7 +22,7 @@ public interface PGResultSetMetaData {
    * @throws SQLException if something wrong happens
    * @since 8.0
    */
-  public String getBaseColumnName(int column) throws SQLException;
+  String getBaseColumnName(int column) throws SQLException;
 
   /**
    * Returns the underlying table name of query result, or "" if it is unable to be determined.
@@ -32,7 +32,7 @@ public interface PGResultSetMetaData {
    * @throws SQLException if something wrong happens
    * @since 8.0
    */
-  public String getBaseTableName(int column) throws SQLException;
+  String getBaseTableName(int column) throws SQLException;
 
   /**
    * Returns the underlying schema name of query result, or "" if it is unable to be determined.
@@ -42,7 +42,7 @@ public interface PGResultSetMetaData {
    * @throws SQLException if something wrong happens
    * @since 8.0
    */
-  public String getBaseSchemaName(int column) throws SQLException;
+  String getBaseSchemaName(int column) throws SQLException;
 
   /**
    * Is a column Text or Binary?
@@ -54,5 +54,5 @@ public interface PGResultSetMetaData {
    * @see Field#TEXT_FORMAT
    * @since 9.4
    */
-  public int getFormat(int column) throws SQLException;
+  int getFormat(int column) throws SQLException;
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/PGStatement.java b/pgjdbc/src/main/java/org/postgresql/PGStatement.java
index d7f69cbc15..637840f111 100644
--- a/pgjdbc/src/main/java/org/postgresql/PGStatement.java
+++ b/pgjdbc/src/main/java/org/postgresql/PGStatement.java
@@ -21,10 +21,10 @@ public interface PGStatement {
   // The follow values are the nearest MAX/MIN values with hour,
   // minute, second, millisecond set to 0 - this is used for
   // -infinity / infinity representation in Java
-  public static final long DATE_POSITIVE_INFINITY = 9223372036825200000L;
-  public static final long DATE_NEGATIVE_INFINITY = -9223372036832400000L;
-  public static final long DATE_POSITIVE_SMALLER_INFINITY = 185543533774800000L;
-  public static final long DATE_NEGATIVE_SMALLER_INFINITY = -185543533774800000L;
+  long DATE_POSITIVE_INFINITY = 9223372036825200000L;
+  long DATE_NEGATIVE_INFINITY = -9223372036832400000L;
+  long DATE_POSITIVE_SMALLER_INFINITY = 185543533774800000L;
+  long DATE_NEGATIVE_SMALLER_INFINITY = -185543533774800000L;
 
 
   /**
@@ -34,7 +34,7 @@ public interface PGStatement {
    * @throws SQLException if something goes wrong
    * @since 7.3
    */
-  public long getLastOID() throws SQLException;
+  long getLastOID() throws SQLException;
 
   /**
    * Turn on the use of prepared statements in the server (server side prepared statements are
@@ -46,7 +46,7 @@ public interface PGStatement {
    * @since 7.3
    * @deprecated As of build 302, replaced by {@link #setPrepareThreshold(int)}
    */
-  public void setUseServerPrepare(boolean flag) throws SQLException;
+  void setUseServerPrepare(boolean flag) throws SQLException;
 
   /**
    * Checks if this statement will be executed as a server-prepared statement. A return value of
@@ -55,7 +55,7 @@ public interface PGStatement {
    *
    * @return true if the next reuse of this statement will use a server-prepared statement
    */
-  public boolean isUseServerPrepare();
+  boolean isUseServerPrepare();
 
   /**
    * Sets the reuse threshold for using server-prepared statements.
@@ -72,7 +72,7 @@ public interface PGStatement {
    * @throws SQLException if an exception occurs while changing the threshold
    * @since build 302
    */
-  public void setPrepareThreshold(int threshold) throws SQLException;
+  void setPrepareThreshold(int threshold) throws SQLException;
 
   /**
    * Gets the server-side prepare reuse threshold in use for this statement.
@@ -81,5 +81,5 @@ public interface PGStatement {
    * @see #setPrepareThreshold(int)
    * @since build 302
    */
-  public int getPrepareThreshold();
+  int getPrepareThreshold();
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/copy/CopyIn.java b/pgjdbc/src/main/java/org/postgresql/copy/CopyIn.java
index e472ba0026..fd2dfcdb3f 100644
--- a/pgjdbc/src/main/java/org/postgresql/copy/CopyIn.java
+++ b/pgjdbc/src/main/java/org/postgresql/copy/CopyIn.java
@@ -41,5 +41,5 @@ public interface CopyIn extends CopyOperation {
    * @return number of updated rows for server 8.2 or newer (see getHandledRowCount())
    * @throws SQLException if the operation fails.
    */
-  public long endCopy() throws SQLException;
+  long endCopy() throws SQLException;
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/copy/CopyManager.java b/pgjdbc/src/main/java/org/postgresql/copy/CopyManager.java
index e75b3990a8..bfd31e964c 100644
--- a/pgjdbc/src/main/java/org/postgresql/copy/CopyManager.java
+++ b/pgjdbc/src/main/java/org/postgresql/copy/CopyManager.java
@@ -48,26 +48,24 @@ public CopyManager(BaseConnection connection) throws SQLException {
   }
 
   public CopyIn copyIn(String sql) throws SQLException {
-    CopyOperation op = null;
-    try {
-      op = queryExecutor.startCopy(sql, connection.getAutoCommit());
+    CopyOperation op = queryExecutor.startCopy(sql, connection.getAutoCommit());
+    if (op == null || op instanceof CopyIn) {
       return (CopyIn) op;
-    } catch (ClassCastException cce) {
+    } else {
       op.cancelCopy();
       throw new PSQLException(GT.tr("Requested CopyIn but got {0}", op.getClass().getName()),
-          PSQLState.WRONG_OBJECT_TYPE, cce);
+              PSQLState.WRONG_OBJECT_TYPE);
     }
   }
 
   public CopyOut copyOut(String sql) throws SQLException {
-    CopyOperation op = null;
-    try {
-      op = queryExecutor.startCopy(sql, connection.getAutoCommit());
+    CopyOperation op = queryExecutor.startCopy(sql, connection.getAutoCommit());
+    if (op == null || op instanceof CopyOut) {
       return (CopyOut) op;
-    } catch (ClassCastException cce) {
+    } else {
       op.cancelCopy();
       throw new PSQLException(GT.tr("Requested CopyOut but got {0}", op.getClass().getName()),
-          PSQLState.WRONG_OBJECT_TYPE, cce);
+              PSQLState.WRONG_OBJECT_TYPE);
     }
   }
 
diff --git a/pgjdbc/src/main/java/org/postgresql/copy/CopyOperation.java b/pgjdbc/src/main/java/org/postgresql/copy/CopyOperation.java
index 07a6e34a60..99dcc24d12 100644
--- a/pgjdbc/src/main/java/org/postgresql/copy/CopyOperation.java
+++ b/pgjdbc/src/main/java/org/postgresql/copy/CopyOperation.java
@@ -50,5 +50,5 @@ public interface CopyOperation {
    *
    * @return number of handled rows or -1
    */
-  public long getHandledRowCount();
+  long getHandledRowCount();
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/BaseConnection.java b/pgjdbc/src/main/java/org/postgresql/core/BaseConnection.java
index 891ea7540a..fce4dbd648 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/BaseConnection.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/BaseConnection.java
@@ -9,7 +9,9 @@
 package org.postgresql.core;
 
 import org.postgresql.PGConnection;
+import org.postgresql.jdbc.FieldMetadata;
 import org.postgresql.jdbc.TimestampUtils;
+import org.postgresql.util.LruCache;
 
 import java.sql.Connection;
 import java.sql.ResultSet;
@@ -25,7 +27,7 @@ public interface BaseConnection extends PGConnection, Connection {
    *
    * @throws SQLException if something goes wrong.
    */
-  public void cancelQuery() throws SQLException;
+  void cancelQuery() throws SQLException;
 
   /**
    * Execute a SQL query that returns a single resultset. Never causes a new transaction to be
@@ -35,9 +37,9 @@ public interface BaseConnection extends PGConnection, Connection {
    * @return the (non-null) returned resultset
    * @throws SQLException if something goes wrong.
    */
-  public ResultSet execSQLQuery(String s) throws SQLException;
+  ResultSet execSQLQuery(String s) throws SQLException;
 
-  public ResultSet execSQLQuery(String s, int resultSetType, int resultSetConcurrency)
+  ResultSet execSQLQuery(String s, int resultSetType, int resultSetConcurrency)
       throws SQLException;
 
   /**
@@ -47,14 +49,14 @@ public ResultSet execSQLQuery(String s, int resultSetType, int resultSetConcurre
    * @param s the query to execute
    * @throws SQLException if something goes wrong.
    */
-  public void execSQLUpdate(String s) throws SQLException;
+  void execSQLUpdate(String s) throws SQLException;
 
   /**
    * Get the QueryExecutor implementation for this connection.
    *
    * @return the (non-null) executor
    */
-  public QueryExecutor getQueryExecutor();
+  QueryExecutor getQueryExecutor();
 
   /**
    * Construct and return an appropriate object for the given type and value. This only considers
@@ -70,11 +72,11 @@ public ResultSet execSQLQuery(String s, int resultSetType, int resultSetConcurre
    * @return an appropriate object; never null.
    * @throws SQLException if something goes wrong
    */
-  public Object getObject(String type, String value, byte[] byteValue) throws SQLException;
+  Object getObject(String type, String value, byte[] byteValue) throws SQLException;
 
-  public Encoding getEncoding() throws SQLException;
+  Encoding getEncoding() throws SQLException;
 
-  public TypeInfo getTypeInfo();
+  TypeInfo getTypeInfo();
 
   /**
    * Check if we should use driver behaviour introduced in a particular driver version. This
@@ -89,7 +91,7 @@ public ResultSet execSQLQuery(String s, int resultSetType, int resultSetConcurre
    * @deprecated Avoid using this in new code that can require PgJDBC 9.4.
    */
   @Deprecated
-  public boolean haveMinimumCompatibleVersion(String ver);
+  boolean haveMinimumCompatibleVersion(String ver);
 
   /**
    * Check if we should use driver behaviour introduced in a particular driver version.
@@ -109,7 +111,7 @@ public ResultSet execSQLQuery(String s, int resultSetType, int resultSetConcurre
    * @param ver the driver version to check, eg 90401 for 9.4.1
    * @return true if the driver's behavioural version is at least "ver".
    */
-  public boolean haveMinimumCompatibleVersion(int ver);
+  boolean haveMinimumCompatibleVersion(int ver);
 
   /**
    * Check if we should use driver behaviour introduced in a particular driver version.
@@ -120,7 +122,7 @@ public ResultSet execSQLQuery(String s, int resultSetType, int resultSetConcurre
    * @param ver the driver version to check
    * @return true if the driver's behavioural version is at least "ver".
    */
-  public boolean haveMinimumCompatibleVersion(Version ver);
+  boolean haveMinimumCompatibleVersion(Version ver);
 
   /**
    * Check if we have at least a particular server version.
@@ -130,7 +132,7 @@ public ResultSet execSQLQuery(String s, int resultSetType, int resultSetConcurre
    * @deprecated Use haveMinimumServerVersion(int) instead
    */
   @Deprecated
-  public boolean haveMinimumServerVersion(String ver);
+  boolean haveMinimumServerVersion(String ver);
 
   /**
    * Check if we have at least a particular server version.
@@ -141,7 +143,7 @@ public ResultSet execSQLQuery(String s, int resultSetType, int resultSetConcurre
    * @param ver the server version to check, of the form xxyyzz eg 90401
    * @return true if the server version is at least "ver".
    */
-  public boolean haveMinimumServerVersion(int ver);
+  boolean haveMinimumServerVersion(int ver);
 
   /**
    * Check if we have at least a particular server version.
@@ -152,7 +154,7 @@ public ResultSet execSQLQuery(String s, int resultSetType, int resultSetConcurre
    * @param ver the server version to check
    * @return true if the server version is at least "ver".
    */
-  public boolean haveMinimumServerVersion(Version ver);
+  boolean haveMinimumServerVersion(Version ver);
 
   /**
    * Encode a string using the database's client_encoding (usually UTF8, but can vary on older
@@ -163,7 +165,7 @@ public ResultSet execSQLQuery(String s, int resultSetType, int resultSetConcurre
    * @return an encoded representation of the string
    * @throws SQLException if something goes wrong.
    */
-  public byte[] encodeString(String str) throws SQLException;
+  byte[] encodeString(String str) throws SQLException;
 
   /**
    * Escapes a string for use as string-literal within an SQL command. The method chooses the
@@ -173,7 +175,7 @@ public ResultSet execSQLQuery(String s, int resultSetType, int resultSetConcurre
    * @return the escaped representation of the string
    * @throws SQLException if the string contains a <tt>\0</tt> character
    */
-  public String escapeString(String str) throws SQLException;
+  String escapeString(String str) throws SQLException;
 
   /**
    * Returns whether the server treats string-literals according to the SQL standard or if it uses
@@ -184,23 +186,23 @@ public ResultSet execSQLQuery(String s, int resultSetType, int resultSetConcurre
    * @return true if the server treats string literals according to the SQL standard
    * @see ProtocolConnection#getStandardConformingStrings()
    */
-  public boolean getStandardConformingStrings();
+  boolean getStandardConformingStrings();
 
   // Ew. Quick hack to give access to the connection-specific utils implementation.
-  public TimestampUtils getTimestampUtils();
+  TimestampUtils getTimestampUtils();
 
   // Get the per-connection logger.
-  public Logger getLogger();
+  Logger getLogger();
 
   // Get the bind-string-as-varchar config flag
-  public boolean getStringVarcharFlag();
+  boolean getStringVarcharFlag();
 
   /**
    * Get the current transaction state of this connection.
    *
    * @return a ProtocolConnection.TRANSACTION_* constant.
    */
-  public int getTransactionState();
+  int getTransactionState();
 
   /**
    * Returns true if value for the given oid should be sent using binary transfer. False if value
@@ -209,14 +211,14 @@ public ResultSet execSQLQuery(String s, int resultSetType, int resultSetConcurre
    * @param oid The oid to check.
    * @return True for binary transfer, false for text transfer.
    */
-  public boolean binaryTransferSend(int oid);
+  boolean binaryTransferSend(int oid);
 
   /**
    * Return whether to disable column name sanitation.
    *
    * @return true column sanitizer is disabled
    */
-  public boolean isColumnSanitiserDisabled();
+  boolean isColumnSanitiserDisabled();
 
   /**
    * Schedule a TimerTask for later execution. The task will be scheduled with the shared Timer for
@@ -225,10 +227,23 @@ public ResultSet execSQLQuery(String s, int resultSetType, int resultSetConcurre
    * @param timerTask timer task to schedule
    * @param milliSeconds delay in milliseconds
    */
-  public void addTimerTask(TimerTask timerTask, long milliSeconds);
+  void addTimerTask(TimerTask timerTask, long milliSeconds);
 
   /**
    * Invoke purge() on the underlying shared Timer so that internal resources will be released.
    */
-  public void purgeTimerTasks();
+  void purgeTimerTasks();
+
+  /**
+   * To be used for checking if the batched insert re-write optimization is enabled.
+   * @return true if re-write feature is enabled
+   */
+  boolean isReWriteBatchedInsertsEnabled();
+
+  /**
+   * Return metadata cache for given connection
+   *
+   * @return metadata cache
+   */
+  LruCache<FieldMetadata.Key, FieldMetadata> getFieldMetadataCache();
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/BaseStatement.java b/pgjdbc/src/main/java/org/postgresql/core/BaseStatement.java
index 1eeeda1f5c..7e387c949d 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/BaseStatement.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/BaseStatement.java
@@ -27,7 +27,7 @@ public interface BaseStatement extends PGStatement, Statement {
    * @return the new ResultSet
    * @throws SQLException if something goes wrong
    */
-  public ResultSet createDriverResultSet(Field[] fields, List<byte[][]> tuples) throws SQLException;
+  ResultSet createDriverResultSet(Field[] fields, List<byte[][]> tuples) throws SQLException;
 
   /**
    * Create a resultset from data retrieved from the server.
@@ -41,7 +41,7 @@ public interface BaseStatement extends PGStatement, Statement {
    * @return the new ResultSet
    * @throws SQLException if something goes wrong
    */
-  public ResultSet createResultSet(Query originalQuery, Field[] fields, List<byte[][]> tuples,
+  ResultSet createResultSet(Query originalQuery, Field[] fields, List<byte[][]> tuples,
       ResultCursor cursor) throws SQLException;
 
   /**
@@ -53,7 +53,7 @@ public ResultSet createResultSet(Query originalQuery, Field[] fields, List<byte[
    * @return true if there is a result set
    * @throws SQLException if something goes wrong.
    */
-  public boolean executeWithFlags(String p_sql, int flags) throws SQLException;
+  boolean executeWithFlags(String p_sql, int flags) throws SQLException;
 
   /**
    * Execute a prepared query, passing additional query flags.
@@ -63,5 +63,5 @@ public ResultSet createResultSet(Query originalQuery, Field[] fields, List<byte[
    * @return true if there is a result set
    * @throws SQLException if something goes wrong.
    */
-  public boolean executeWithFlags(int flags) throws SQLException;
+  boolean executeWithFlags(int flags) throws SQLException;
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/CachedQuery.java b/pgjdbc/src/main/java/org/postgresql/core/CachedQuery.java
index a8efc3402d..52a327983a 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/CachedQuery.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/CachedQuery.java
@@ -60,6 +60,6 @@ public int getExecuteCount() {
   public long getSize() {
     int queryLength = String.valueOf(key).length() * 2 /* 2 bytes per char */;
     return queryLength * 2 /* original query and native sql */
-        + 100 /* entry in hash map, CachedQuery wrapper, etc */;
+        + 100L /* entry in hash map, CachedQuery wrapper, etc */;
   }
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/Encoding.java b/pgjdbc/src/main/java/org/postgresql/core/Encoding.java
index 00c7074023..d001dbebb4 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/Encoding.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/Encoding.java
@@ -245,7 +245,7 @@ public static Encoding defaultEncoding() {
    */
   private static boolean isAvailable(String encodingName) {
     try {
-      "DUMMY".getBytes(encodingName);
+      "DUMMY".getBytes(encodingName); //NOSONAR
       return true;
     } catch (java.io.UnsupportedEncodingException e) {
       return false;
diff --git a/pgjdbc/src/main/java/org/postgresql/core/Field.java b/pgjdbc/src/main/java/org/postgresql/core/Field.java
index 0d804b99c0..5278bf0d4a 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/Field.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/Field.java
@@ -8,7 +8,7 @@
 
 package org.postgresql.core;
 
-import java.sql.ResultSetMetaData;
+import org.postgresql.jdbc.FieldMetadata;
 
 /*
  */
@@ -21,7 +21,6 @@ public class Field {
   private final int oid; // OID of the type
   private final int mod; // type modifier of this field
   private final String columnLabel; // Column label
-  private String columnName; // Column name
 
   private int format = TEXT_FORMAT; // In the V3 protocol each field has a format
   // 0 = text, 1 = binary
@@ -34,10 +33,8 @@ public class Field {
 
   // Cache fields filled in by AbstractJdbc2ResultSetMetaData.fetchFieldMetaData.
   // Don't use unless that has been called.
-  private String tableName = "";
-  private String schemaName = "";
-  private int nullable = ResultSetMetaData.columnNullableUnknown;
-  private boolean autoIncrement = false;
+  private FieldMetadata metadata;
+
   private int sqlType;
   private String pgType = NOT_YET_LOADED;
 
@@ -53,7 +50,7 @@ public class Field {
    * @param mod modifier
    */
   public Field(String name, int oid, int length, int mod) {
-    this(name, name, oid, length, mod, 0, 0);
+    this(name, oid, length, mod, 0, 0);
   }
 
   /**
@@ -68,25 +65,22 @@ public Field(String name, int oid) {
 
   /**
    * Construct a field based on the information fed to it.
-   *
    * @param columnLabel the column label of the field
-   * @param columnName the column label the name of the field
    * @param oid the OID of the field
    * @param length the length of the field
    * @param mod modifier
    * @param tableOid the OID of the columns' table
-   * @param positionInTable the position of column in the table (first column is 1, second column is
-   *        2, etc...)
+   * @param positionInTable the position of column in the table (first column is 1, second column is 2, etc...)
    */
-  public Field(String columnLabel, String columnName, int oid, int length, int mod, int tableOid,
+  public Field(String columnLabel, int oid, int length, int mod, int tableOid,
       int positionInTable) {
     this.columnLabel = columnLabel;
-    this.columnName = columnName;
     this.oid = oid;
     this.length = length;
     this.mod = mod;
     this.tableOid = tableOid;
     this.positionInTable = positionInTable;
+    this.metadata = tableOid == 0 ? new FieldMetadata(columnLabel) : null;
   }
 
   /**
@@ -142,48 +136,16 @@ public int getPositionInTable() {
     return positionInTable;
   }
 
-  public void setNullable(int nullable) {
-    this.nullable = nullable;
-  }
-
-  public int getNullable() {
-    return nullable;
-  }
-
-  public void setAutoIncrement(boolean autoIncrement) {
-    this.autoIncrement = autoIncrement;
-  }
-
-  public boolean getAutoIncrement() {
-    return autoIncrement;
-  }
-
-  public void setColumnName(String columnName) {
-    this.columnName = columnName;
-  }
-
-  public String getColumnName() {
-    return columnName;
-  }
-
-  public void setTableName(String tableName) {
-    this.tableName = tableName;
-  }
-
-  public String getTableName() {
-    return tableName;
-  }
-
-  public void setSchemaName(String schemaName) {
-    this.schemaName = schemaName;
+  public FieldMetadata getMetadata() {
+    return metadata;
   }
 
-  public String getSchemaName() {
-    return schemaName;
+  public void setMetadata(FieldMetadata metadata) {
+    this.metadata = metadata;
   }
 
   public String toString() {
-    return "Field(" + (columnName != null ? columnName : "")
+    return "Field(" + (columnLabel != null ? columnLabel : "")
         + "," + Oid.toString(oid)
         + "," + length
         + "," + (format == TEXT_FORMAT ? 'T' : 'B')
diff --git a/pgjdbc/src/main/java/org/postgresql/core/Keyword.java b/pgjdbc/src/main/java/org/postgresql/core/Keyword.java
new file mode 100644
index 0000000000..318f7fa823
--- /dev/null
+++ b/pgjdbc/src/main/java/org/postgresql/core/Keyword.java
@@ -0,0 +1,34 @@
+/*-------------------------------------------------------------------------
+ *
+ * Copyright (c) 2003-2016, PostgreSQL Global Development Group
+ *
+ *
+ *-------------------------------------------------------------------------
+ */
+
+package org.postgresql.core;
+
+/**
+ * Reserved SQL keywords.
+ * @author Jeremy Whiting jwhiting@redhat.com
+ *
+ */
+public enum Keyword {
+  RETURNING("RETURNING"), INTO("INTO"), VALUES("VALUES"), GROUP_BY("GROUP BY");
+  /* add when needed: FROM, WHERE, HAVING, ONLY, ORDER, JOIN, INNER
+  , LEFT, RIGHT, OUTER, LIMIT, OFFSET;*/
+
+  Keyword(String upperCaseWord) {
+    keyword = upperCaseWord;
+  }
+
+  public String asLowerCase() {
+    return keyword.toLowerCase();
+  }
+
+  public String toString() {
+    return keyword;
+  }
+
+  private final String keyword;
+}
diff --git a/pgjdbc/src/main/java/org/postgresql/core/NativeQuery.java b/pgjdbc/src/main/java/org/postgresql/core/NativeQuery.java
index 5f534327b8..0d0daa2f8f 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/NativeQuery.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/NativeQuery.java
@@ -14,11 +14,12 @@
  * replaced with $1, $2, etc.
  */
 public class NativeQuery {
-  private final static String[] BIND_NAMES = new String[128];
+  private final static String[] BIND_NAMES = new String[128 * 10];
   private final static int[] NO_BINDS = new int[0];
 
   public final String nativeSql;
   public final int[] bindPositions;
+  public final SqlCommand command;
 
   static {
     for (int i = 1; i < BIND_NAMES.length; i++) {
@@ -26,14 +27,15 @@ public class NativeQuery {
     }
   }
 
-  public NativeQuery(String nativeSql) {
-    this(nativeSql, NO_BINDS);
+  public NativeQuery(String nativeSql, SqlCommand dml) {
+    this(nativeSql, NO_BINDS, dml);
   }
 
-  public NativeQuery(String nativeSql, int[] bindPositions) {
+  public NativeQuery(String nativeSql, int[] bindPositions, SqlCommand dml) {
     this.nativeSql = nativeSql;
     this.bindPositions =
         bindPositions == null || bindPositions.length == 0 ? NO_BINDS : bindPositions;
+    this.command = dml;
   }
 
   /**
@@ -76,4 +78,40 @@ public String toString(ParameterList parameters) {
   public static String bindName(int index) {
     return index < BIND_NAMES.length ? BIND_NAMES[index] : "$" + index;
   }
+
+  public static StringBuilder appendBindName(StringBuilder sb, int index) {
+    if (index < BIND_NAMES.length) {
+      return sb.append(bindName(index));
+    }
+    sb.append('$');
+    sb.append(index);
+    return sb;
+  }
+
+  /**
+   * Calculate the text length required for the given number of bind variables
+   * including dollars.
+   * Do this to avoid repeated calls to
+   * AbstractStringBuilder.expandCapacity(...) and Arrays.copyOf
+   *
+   * @param bindCount total number of parameters in a query
+   * @return int total character length for $xyz kind of binds
+   */
+  public static int calculateBindLength(int bindCount) {
+    int res = 0;
+    int bindLen = 2; // $1
+    int maxBindsOfLen = 9; // $0 .. $9
+    while (bindCount > 0) {
+      int numBinds = Math.min(maxBindsOfLen, bindCount);
+      bindCount -= numBinds;
+      res += bindLen * numBinds;
+      bindLen++;
+      maxBindsOfLen *= 10; // $0..$9 (9 items) -> $10..$99 (90 items)
+    }
+    return res;
+  }
+
+  public SqlCommand getCommand() {
+    return command;
+  }
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/ParameterList.java b/pgjdbc/src/main/java/org/postgresql/core/ParameterList.java
index 23f8414858..6d3ba7a9db 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/ParameterList.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/ParameterList.java
@@ -58,7 +58,7 @@ public interface ParameterList {
    *
    * @return oids of the parameters
    */
-  public int[] getTypeOIDs();
+  int[] getTypeOIDs();
 
   /**
    * Binds an integer value to a parameter. The type of the parameter is implicitly 'int4'.
@@ -170,4 +170,17 @@ public interface ParameterList {
    * @return a string representation of the parameter.
    */
   String toString(int index);
+
+  /**
+   * Use this operation to append more parameters to the current list.
+   * @param list of parameters to append with.
+   * @throws SQLException fault raised if driver or back end throw an exception
+   */
+  void appendAll(ParameterList list) throws SQLException ;
+
+  /**
+   * Returns the bound parameter values.
+   * @return Object array containing the parameter values.
+   */
+  Object[] getValues();
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/Parser.java b/pgjdbc/src/main/java/org/postgresql/core/Parser.java
index 2cd8de5237..6469d6af68 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/Parser.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/Parser.java
@@ -21,6 +21,7 @@
  * Basic query parser infrastructure.
  *
  * @author Michael Paesold (mpaesold@gmx.at)
+ * @author Christopher Deckers (chrriis@gmail.com)
  */
 public class Parser {
   private final static int[] NO_BINDS = new int[0];
@@ -34,12 +35,16 @@ public class Parser {
    *                                  in single quote literals
    * @param withParameters            whether to replace ?, ? with $1, $2, etc
    * @param splitStatements           whether to split statements by semicolon
+   * @param isAutoCommit              whether autocommit is enabled
+   * @param isBatchedReWriteConfigured whether re-write optimization is enabled
    * @return list of native queries
    */
   public static List<NativeQuery> parseJdbcSql(String query, boolean standardConformingStrings,
-      boolean withParameters, boolean splitStatements) {
+      boolean withParameters, boolean splitStatements, boolean isAutoCommit,
+      boolean isBatchedReWriteConfigured) {
     if (!withParameters && !splitStatements) {
-      return Collections.singletonList(new NativeQuery(query));
+      return Collections.singletonList(new NativeQuery(query,
+        SqlCommand.createStatementTypeInfo(SqlCommandType.BLANK)));
     }
 
     int fragmentStart = 0;
@@ -50,10 +55,20 @@ public static List<NativeQuery> parseJdbcSql(String query, boolean standardConfo
     StringBuilder nativeSql = new StringBuilder(query.length() + 10);
     List<Integer> bindPositions = null; // initialized on demand
     List<NativeQuery> nativeQueries = null;
+    boolean isCurrentReWriteCompatible = false;
+    boolean isValuesFound = false;
+    int valuesBraceOpenPosition = -1;
+    int valuesBraceClosePosition = -1;
+    boolean isInsertPresent = false;
+    boolean isReturningPresent = false;
+    SqlCommandType currentCommandType = SqlCommandType.BLANK;
 
     boolean whitespaceOnly = true;
+    int keyWordCount = 0;
+    int keywordStart = -1;
     for (int i = 0; i < aChars.length; ++i) {
       char aChar = aChars[i];
+      boolean isKeyWordChar = false;
       // ';' is ignored as it splits the queries
       whitespaceOnly &= aChar == ';' || Character.isWhitespace(aChar);
       switch (aChar) {
@@ -77,12 +92,15 @@ public static List<NativeQuery> parseJdbcSql(String query, boolean standardConfo
           i = Parser.parseDollarQuotes(aChars, i);
           break;
 
-        case '(':
-          inParen++;
-          break;
+        // case '(' moved below to parse "values(" properly
 
         case ')':
           inParen--;
+          if (inParen == 0 && isValuesFound) {
+            // If original statement is multi-values like VALUES (...), (...), ... then
+            // search for the latest closing paren
+            valuesBraceClosePosition = nativeSql.length() + i - fragmentStart;
+          }
           break;
 
         case '?':
@@ -117,19 +135,71 @@ public static List<NativeQuery> parseJdbcSql(String query, boolean standardConfo
                 nativeQueries = new ArrayList<NativeQuery>();
               }
 
-              nativeQueries.add(new NativeQuery(nativeSql.toString(), toIntArray(bindPositions)));
+              nativeQueries.add(new NativeQuery(nativeSql.toString(),
+                  toIntArray(bindPositions), SqlCommand.createStatementTypeInfo(
+                      currentCommandType, isBatchedReWriteConfigured, valuesBraceOpenPosition,
+                      valuesBraceClosePosition,
+                  isReturningPresent, nativeQueries.size())));
             }
             // Prepare for next query
             if (bindPositions != null) {
               bindPositions.clear();
             }
             nativeSql.setLength(0);
+            currentCommandType = SqlCommandType.BLANK;
+            isReturningPresent = false;
+            valuesBraceOpenPosition = -1;
+            valuesBraceClosePosition = -1;
           }
           break;
 
         default:
+          isKeyWordChar =
+              aChars[i] >= 'a' && aChars[i] <= 'z' || aChars[i] >= 'A' && aChars[i] <= 'Z';
+          if (isKeyWordChar && keywordStart < 0) {
+            keywordStart = i;
+          }
           break;
       }
+      if (keywordStart >= 0 && (i == aChars.length - 1 || !isKeyWordChar)) {
+        int wordLength = (isKeyWordChar ? i + 1 : i) - keywordStart;
+        if (wordLength == 6 && parseUpdateKeyword(aChars, keywordStart)) {
+          currentCommandType = SqlCommandType.UPDATE;
+        } else if (wordLength == 6 && parseDeleteKeyword(aChars, keywordStart)) {
+          currentCommandType = SqlCommandType.DELETE;
+        } else if (wordLength == 4 && parseMoveKeyword(aChars, keywordStart)) {
+          currentCommandType = SqlCommandType.MOVE;
+        } else if (wordLength == 6 && parseInsertKeyword(aChars, keywordStart)) {
+          if (!isInsertPresent && (nativeQueries == null || nativeQueries.isEmpty())) {
+            // Only allow rewrite for insert command starting with the insert keyword.
+            // Else, too many risks of wrong interpretation.
+            isCurrentReWriteCompatible = keyWordCount == 0;
+            isInsertPresent = true;
+            currentCommandType = SqlCommandType.INSERT;
+          } else {
+            isCurrentReWriteCompatible = false;
+          }
+        } else if (wordLength == 9 && parseReturningKeyword(aChars, keywordStart)) {
+          isReturningPresent = true;
+        } else if (wordLength == 6 && parseValuesKeyword(aChars, keywordStart)) {
+          isValuesFound = true;
+        }
+        keywordStart = -1;
+        keyWordCount++;
+      }
+      if (aChar == '(') {
+        inParen++;
+        if (inParen == 1 && isValuesFound && valuesBraceOpenPosition == -1) {
+          valuesBraceOpenPosition = nativeSql.length() + i - fragmentStart;
+        }
+      }
+    }
+    if (!isValuesFound || bindPositions == null) {
+      isCurrentReWriteCompatible = false;
+    }
+    if (!isCurrentReWriteCompatible) {
+      valuesBraceOpenPosition = -1;
+      valuesBraceClosePosition = -1;
     }
 
     if (fragmentStart < aChars.length && !whitespaceOnly) {
@@ -140,7 +210,10 @@ public static List<NativeQuery> parseJdbcSql(String query, boolean standardConfo
       return nativeQueries != null ? nativeQueries : Collections.<NativeQuery>emptyList();
     }
 
-    NativeQuery lastQuery = new NativeQuery(nativeSql.toString(), toIntArray(bindPositions));
+    NativeQuery lastQuery = new NativeQuery(nativeSql.toString(),
+        toIntArray(bindPositions), SqlCommand.createStatementTypeInfo(currentCommandType,
+            isBatchedReWriteConfigured, valuesBraceOpenPosition, valuesBraceClosePosition,
+            isReturningPresent, (nativeQueries == null ? 0 : nativeQueries.size())));
 
     if (nativeQueries == null) {
       return Collections.singletonList(lastQuery);
@@ -338,6 +411,128 @@ public static int parseBlockComment(final char[] query, int offset) {
     return offset;
   }
 
+  /**
+   * Parse string to check presence of DELETE keyword regardless of case. The initial character is
+   * assumed to have been matched.
+   *
+   * @param query char[] of the query statement
+   * @param offset position of query to start checking
+   * @return boolean indicates presence of word
+   */
+  public static boolean parseDeleteKeyword(final char[] query, int offset) {
+    if (query.length < (offset + 6)) {
+      return false;
+    }
+
+    return (query[offset] | 32) == 'd'
+        && (query[offset + 1] | 32) == 'e'
+        && (query[offset + 2] | 32) == 'l'
+        && (query[offset + 3] | 32) == 'e'
+        && (query[offset + 4] | 32) == 't'
+        && (query[offset + 5] | 32) == 'e';
+  }
+
+  /**
+   * Parse string to check presence of INSERT keyword regardless of case.
+   *
+   * @param query char[] of the query statement
+   * @param offset position of query to start checking
+   * @return boolean indicates presence of word
+   */
+  public static boolean parseInsertKeyword(final char[] query, int offset) {
+    if (query.length < (offset + 7)) {
+      return false;
+    }
+
+    return (query[offset] | 32) == 'i'
+        && (query[offset + 1] | 32) == 'n'
+        && (query[offset + 2] | 32) == 's'
+        && (query[offset + 3] | 32) == 'e'
+        && (query[offset + 4] | 32) == 'r'
+        && (query[offset + 5] | 32) == 't';
+  }
+
+  /**
+   * Parse string to check presence of MOVE keyword regardless of case.
+   *
+   * @param query char[] of the query statement
+   * @param offset position of query to start checking
+   * @return boolean indicates presence of word
+   */
+  public static boolean parseMoveKeyword(final char[] query, int offset) {
+    if (query.length < (offset + 4)) {
+      return false;
+    }
+
+    return (query[offset] | 32) == 'm'
+        && (query[offset + 1] | 32) == 'o'
+        && (query[offset + 2] | 32) == 'v'
+        && (query[offset + 3] | 32) == 'e';
+  }
+
+  /**
+   * Parse string to check presence of RETURNING keyword regardless of case.
+   *
+   * @param query char[] of the query statement
+   * @param offset position of query to start checking
+   * @return boolean indicates presence of word
+   */
+  public static boolean parseReturningKeyword(final char[] query, int offset) {
+    if (query.length < (offset + 9)) {
+      return false;
+    }
+
+    return (query[offset] | 32) == 'r'
+        && (query[offset + 1] | 32) == 'e'
+        && (query[offset + 2] | 32) == 't'
+        && (query[offset + 3] | 32) == 'u'
+        && (query[offset + 4] | 32) == 'r'
+        && (query[offset + 5] | 32) == 'n'
+        && (query[offset + 6] | 32) == 'i'
+        && (query[offset + 7] | 32) == 'n'
+        && (query[offset + 8] | 32) == 'g';
+  }
+
+  /**
+   * Parse string to check presence of UPDATE keyword regardless of case.
+   *
+   * @param query char[] of the query statement
+   * @param offset position of query to start checking
+   * @return boolean indicates presence of word
+   */
+  public static boolean parseUpdateKeyword(final char[] query, int offset) {
+    if (query.length < (offset + 6)) {
+      return false;
+    }
+
+    return (query[offset] | 32) == 'u'
+        && (query[offset + 1] | 32) == 'p'
+        && (query[offset + 2] | 32) == 'd'
+        && (query[offset + 3] | 32) == 'a'
+        && (query[offset + 4] | 32) == 't'
+        && (query[offset + 5] | 32) == 'e';
+  }
+
+  /**
+   * Parse string to check presence of VALUES keyword regardless of case.
+   *
+   * @param query char[] of the query statement
+   * @param offset position of query to start checking
+   * @return boolean indicates presence of word
+   */
+  public static boolean parseValuesKeyword(final char[] query, int offset) {
+    if (query.length < (offset + 6)) {
+      return false;
+    }
+
+    return (query[offset] | 32) == 'v'
+        && (query[offset + 1] | 32) == 'a'
+        && (query[offset + 2] | 32) == 'l'
+        && (query[offset + 3] | 32) == 'u'
+        && (query[offset + 4] | 32) == 'e'
+        && (query[offset + 5] | 32) == 's';
+  }
+
   /**
    * @param c character
    * @return true if the character is a whitespace character as defined in the backend's parser
diff --git a/pgjdbc/src/main/java/org/postgresql/core/ProtocolConnection.java b/pgjdbc/src/main/java/org/postgresql/core/ProtocolConnection.java
index 4974e0e9f7..2f9663e4c8 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/ProtocolConnection.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/ProtocolConnection.java
@@ -15,6 +15,7 @@
 import java.sql.SQLException;
 import java.sql.SQLWarning;
 import java.util.Set;
+import java.util.TimeZone;
 
 /**
  * Provides access to protocol-level connection operations.
@@ -26,19 +27,19 @@ public interface ProtocolConnection {
    * Constant returned by {@link #getTransactionState} indicating that no transaction is currently
    * open.
    */
-  static final int TRANSACTION_IDLE = 0;
+  int TRANSACTION_IDLE = 0;
 
   /**
    * Constant returned by {@link #getTransactionState} indicating that a transaction is currently
    * open.
    */
-  static final int TRANSACTION_OPEN = 1;
+  int TRANSACTION_OPEN = 1;
 
   /**
    * Constant returned by {@link #getTransactionState} indicating that a transaction is currently
    * open, but it has seen errors and will refuse subsequent queries until a ROLLBACK.
    */
-  static final int TRANSACTION_FAILED = 2;
+  int TRANSACTION_FAILED = 2;
 
   /**
    * @return the host and port this connection is connected to.
@@ -146,31 +147,49 @@ public interface ProtocolConnection {
   /**
    * @return the version of the implementation
    */
-  public int getProtocolVersion();
+  int getProtocolVersion();
 
   /**
    * Sets the oids that should be received using binary encoding.
    *
    * @param useBinaryForOids The oids to request with binary encoding.
    */
-  public void setBinaryReceiveOids(Set<Integer> useBinaryForOids);
+  void setBinaryReceiveOids(Set<Integer> useBinaryForOids);
 
   /**
    * Returns true if server uses integer instead of double for binary date and time encodings.
    *
    * @return the server integer_datetime setting.
    */
-  public boolean getIntegerDateTimes();
+  boolean getIntegerDateTimes();
 
   /**
    * Return the process ID (PID) of the backend server process handling this connection.
    *
    * @return process ID (PID) of the backend server process handling this connection
    */
-  public int getBackendPID();
+  int getBackendPID();
 
   /**
    * Abort at network level without sending the Terminate message to the backend.
    */
-  public void abort();
+  void abort();
+
+  /**
+   * Return TimestampUtils that is aware of connection-specific {@code TimeZone} value.
+   *
+   * @return timestampUtils instance
+   */
+
+  /**
+   * Returns backend timezone in java format.
+   * @return backend timezone in java format.
+   */
+  TimeZone getTimeZone();
+
+  /**
+   * Returns application_name connection property.
+   * @return application_name connection property
+   */
+  String getApplicationName();
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/Provider.java b/pgjdbc/src/main/java/org/postgresql/core/Provider.java
new file mode 100644
index 0000000000..8280fcd41c
--- /dev/null
+++ b/pgjdbc/src/main/java/org/postgresql/core/Provider.java
@@ -0,0 +1,16 @@
+package org.postgresql.core;
+
+/**
+ * Represents a provider of results.
+ *
+ * @param <T> the type of results provided by this provider
+ */
+public interface Provider<T> {
+
+  /**
+   * Gets a result.
+   *
+   * @return a result
+   */
+  T get();
+}
diff --git a/pgjdbc/src/main/java/org/postgresql/core/Query.java b/pgjdbc/src/main/java/org/postgresql/core/Query.java
index 6f63a482f2..e1df5c1f92 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/Query.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/Query.java
@@ -51,4 +51,10 @@ public interface Query {
   boolean isStatementDescribed();
 
   boolean isEmpty();
+
+  /**
+   * Get the number of times this Query has been batched.
+   * @return number of times <code>addBatch()</code> has been called.
+   */
+  int getBatchSize();
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/QueryExecutor.java b/pgjdbc/src/main/java/org/postgresql/core/QueryExecutor.java
index d47a436cd1..ab36c4f163 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/QueryExecutor.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/QueryExecutor.java
@@ -48,50 +48,50 @@ public interface QueryExecutor {
   /**
    * Flag for query execution that indicates the given Query object is unlikely to be reused.
    */
-  static int QUERY_ONESHOT = 1;
+  int QUERY_ONESHOT = 1;
 
   /**
    * Flag for query execution that indicates that resultset metadata isn't needed and can be safely
    * omitted.
    */
-  static int QUERY_NO_METADATA = 2;
+  int QUERY_NO_METADATA = 2;
 
   /**
    * Flag for query execution that indicates that a resultset isn't expected and the query executor
    * can safely discard any rows (although the resultset should still appear to be from a
    * resultset-returning query).
    */
-  static int QUERY_NO_RESULTS = 4;
+  int QUERY_NO_RESULTS = 4;
 
   /**
    * Flag for query execution that indicates a forward-fetch-capable cursor should be used if
    * possible.
    */
-  static int QUERY_FORWARD_CURSOR = 8;
+  int QUERY_FORWARD_CURSOR = 8;
 
   /**
    * Flag for query execution that indicates the automatic BEGIN on the first statement when outside
    * a transaction should not be done.
    */
-  static int QUERY_SUPPRESS_BEGIN = 16;
+  int QUERY_SUPPRESS_BEGIN = 16;
 
   /**
    * Flag for query execution when we don't really want to execute, we just want to get the
    * parameter metadata for the statement.
    */
-  static int QUERY_DESCRIBE_ONLY = 32;
+  int QUERY_DESCRIBE_ONLY = 32;
 
   /**
    * Flag for query execution used by generated keys where we want to receive both the ResultSet and
    * associated update count from the command status.
    */
-  static int QUERY_BOTH_ROWS_AND_STATUS = 64;
+  int QUERY_BOTH_ROWS_AND_STATUS = 64;
 
   /**
    * Force this query to be described at each execution. This is done in pipelined batches where we
    * might need to detect mismatched result types.
    */
-  static int QUERY_FORCE_DESCRIBE_PORTAL = 512;
+  int QUERY_FORCE_DESCRIBE_PORTAL = 512;
 
   /**
    * Flag to disable batch execution when we expect results (generated keys) from a statement.
@@ -99,18 +99,18 @@ public interface QueryExecutor {
    * @deprecated in PgJDBC 9.4 as we now auto-size batches.
    */
   @Deprecated
-  static int QUERY_DISALLOW_BATCHING = 128;
+  int QUERY_DISALLOW_BATCHING = 128;
 
   /**
    * Flag for query execution to avoid using binary transfer.
    */
-  static int QUERY_NO_BINARY_TRANSFER = 256;
+  int QUERY_NO_BINARY_TRANSFER = 256;
 
   /**
    * Execute a Query, passing results to a provided ResultHandler.
    *
    * @param query the query to execute; must be a query returned from calling
-   *        {@link #createSimpleQuery(String)} or {@link #createParameterizedQuery(String)} on this
+   *        {@link #createSimpleQuery(String, boolean)} or {@link #createParameterizedQuery(String, boolean)} on this
    *        QueryExecutor object.
    * @param parameters the parameters for the query. Must be non-<code>null</code> if the query
    *        takes parameters. Must be a parameter object returned by
@@ -129,8 +129,8 @@ void execute(Query query, ParameterList parameters, ResultHandler handler, int m
    * Execute several Query, passing results to a provided ResultHandler.
    *
    * @param queries the queries to execute; each must be a query returned from calling
-   *        {@link #createSimpleQuery(String)} or {@link #createParameterizedQuery(String)} on this
-   *        QueryExecutor object.
+   *        {@link #createSimpleQuery(String, boolean)} or {@link #createParameterizedQuery(String, boolean)}
+   *         on this QueryExecutor object.
    * @param parameterLists the parameter lists for the queries. The parameter lists correspond 1:1
    *        to the queries passed in the <code>queries</code> array. Each must be non-
    *        <code>null</code> if the corresponding query takes parameters, and must be a parameter
@@ -163,9 +163,10 @@ void execute(Query[] queries, ParameterList[] parameterLists, BatchResultHandler
    * ParameterList.
    *
    * @param sql the SQL for the query to create
+   * @param autocommit indicating when connection has autocommit enabled.
    * @return a new Query object
    */
-  Query createSimpleQuery(String sql);
+  Query createSimpleQuery(String sql, boolean autocommit);
 
   /**
    * Create a parameterized Query object suitable for execution by this QueryExecutor. The provided
@@ -174,9 +175,10 @@ void execute(Query[] queries, ParameterList[] parameterLists, BatchResultHandler
    * ParameterList.
    *
    * @param sql the SQL for the query to create, with '?' placeholders for parameters.
+   * @param autocommit indicating when connection has autocommit enabled.
    * @return a new Query object
    */
-  Query createParameterizedQuery(String sql); // Parsed for parameter placeholders ('?')
+  Query createParameterizedQuery(String sql, boolean autocommit); // Parsed for parameter placeholders ('?')
 
   /**
    * Prior to attempting to retrieve notifications, we need to pull any recently received
diff --git a/pgjdbc/src/main/java/org/postgresql/core/ServerVersion.java b/pgjdbc/src/main/java/org/postgresql/core/ServerVersion.java
index e99ff80825..56a84e39f2 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/ServerVersion.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/ServerVersion.java
@@ -26,7 +26,9 @@ public enum ServerVersion implements Version {
   v9_2("9.2.0"),
   v9_3("9.3.0"),
   v9_4("9.4.0"),
-  v9_5("9.5.0"),;
+  v9_5("9.5.0"),
+  v9_6("9.6.0"),
+  ;
 
   private final int version;
 
diff --git a/pgjdbc/src/main/java/org/postgresql/core/SetupQueryRunner.java b/pgjdbc/src/main/java/org/postgresql/core/SetupQueryRunner.java
index 1101a334b1..63488323c4 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/SetupQueryRunner.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/SetupQueryRunner.java
@@ -26,10 +26,8 @@ public class SetupQueryRunner {
   private static class SimpleResultHandler implements ResultHandler {
     private SQLException error;
     private List<byte[][]> tuples;
-    private final ProtocolConnection protoConnection;
 
-    SimpleResultHandler(ProtocolConnection protoConnection) {
-      this.protoConnection = protoConnection;
+    SimpleResultHandler() {
     }
 
     List<byte[][]> getResults() {
@@ -67,8 +65,8 @@ public void handleCompletion() throws SQLException {
   public static byte[][] run(ProtocolConnection protoConnection, String queryString,
       boolean wantResults) throws SQLException {
     QueryExecutor executor = protoConnection.getQueryExecutor();
-    Query query = executor.createSimpleQuery(queryString);
-    SimpleResultHandler handler = new SimpleResultHandler(protoConnection);
+    Query query = executor.createSimpleQuery(queryString, false);
+    SimpleResultHandler handler = new SimpleResultHandler();
 
     int flags = QueryExecutor.QUERY_ONESHOT | QueryExecutor.QUERY_SUPPRESS_BEGIN;
     if (!wantResults) {
diff --git a/pgjdbc/src/main/java/org/postgresql/core/SqlCommand.java b/pgjdbc/src/main/java/org/postgresql/core/SqlCommand.java
new file mode 100644
index 0000000000..bf1d3b7f8a
--- /dev/null
+++ b/pgjdbc/src/main/java/org/postgresql/core/SqlCommand.java
@@ -0,0 +1,77 @@
+/*-------------------------------------------------------------------------
+ *
+ * Copyright (c) 2003-2016, PostgreSQL Global Development Group
+ *
+ *
+ *-------------------------------------------------------------------------
+ */
+
+package org.postgresql.core;
+
+import static org.postgresql.core.SqlCommandType.INSERT;
+
+/**
+ * Data Modification Language inspection support.
+ *
+ * @author Jeremy Whiting jwhiting@redhat.com
+ * @author Christopher Deckers (chrriis@gmail.com)
+ *
+ */
+public class SqlCommand {
+
+  public boolean isBatchedReWriteCompatible() {
+    return valuesBraceOpenPosition >= 0;
+  }
+
+  public int getBatchRewriteValuesBraceOpenPosition() {
+    return valuesBraceOpenPosition;
+  }
+
+  public int getBatchRewriteValuesBraceClosePosition() {
+    return valuesBraceClosePosition;
+  }
+
+  public SqlCommandType getType() {
+    return commandType;
+  }
+
+  public boolean isReturningKeywordPresent() {
+    return parsedSQLhasRETURNINGKeyword;
+  }
+
+  public static SqlCommand createStatementTypeInfo(SqlCommandType type,
+      boolean isBatchedReWritePropertyConfigured,
+      int valuesBraceOpenPosition, int valuesBraceClosePosition, boolean isRETURNINGkeywordPresent,
+      int priorQueryCount) {
+    return new SqlCommand(type, isBatchedReWritePropertyConfigured,
+        valuesBraceOpenPosition, valuesBraceClosePosition, isRETURNINGkeywordPresent,
+        priorQueryCount);
+  }
+
+  public static SqlCommand createStatementTypeInfo(SqlCommandType type) {
+    return new SqlCommand(type, false, -1, -1, false, 0);
+  }
+
+  public static SqlCommand createStatementTypeInfo(SqlCommandType type,
+      boolean isRETURNINGkeywordPresent) {
+    return new SqlCommand(type, false, -1, -1, isRETURNINGkeywordPresent, 0);
+  }
+
+  private SqlCommand(SqlCommandType type, boolean isBatchedReWriteConfigured,
+      int valuesBraceOpenPosition, int valuesBraceClosePosition, boolean isPresent,
+      int priorQueryCount) {
+    commandType = type;
+    parsedSQLhasRETURNINGKeyword = isPresent;
+    boolean batchedReWriteCompatible = (type == INSERT) && isBatchedReWriteConfigured
+        && valuesBraceOpenPosition >= 0 && valuesBraceClosePosition > valuesBraceOpenPosition
+        && !isPresent && priorQueryCount == 0;
+    this.valuesBraceOpenPosition = batchedReWriteCompatible ? valuesBraceOpenPosition : -1;
+    this.valuesBraceClosePosition = batchedReWriteCompatible ? valuesBraceClosePosition : -1;
+  }
+
+  private final SqlCommandType commandType;
+  private final boolean parsedSQLhasRETURNINGKeyword;
+  private final int valuesBraceOpenPosition;
+  private final int valuesBraceClosePosition;
+
+}
diff --git a/pgjdbc/src/main/java/org/postgresql/core/SqlCommandType.java b/pgjdbc/src/main/java/org/postgresql/core/SqlCommandType.java
new file mode 100644
index 0000000000..e45b6aa506
--- /dev/null
+++ b/pgjdbc/src/main/java/org/postgresql/core/SqlCommandType.java
@@ -0,0 +1,42 @@
+/*-------------------------------------------------------------------------
+ *
+ * Copyright (c) 2003-2016, PostgreSQL Global Development Group
+ *
+ *
+ *-------------------------------------------------------------------------
+ */
+
+package org.postgresql.core;
+
+/**
+ * Type information inspection support.
+ * @author Jeremy Whiting jwhiting@redhat.com
+ *
+ */
+
+public enum SqlCommandType {
+
+  INSERT(true),
+  /**
+   * Use BLANK for empty sql queries or when parsing the sql string is not
+   * necessary.
+   */
+  BLANK(false),
+  MOVE(false),
+  UPDATE(false),
+  DELETE(false);
+
+  /* to be added when needed SELECT(false), DELETE(false), UPDATE(false),
+  * COMMIT(false), ROLLBACK(false); */
+
+  public boolean canSupportBatchedReWrite() {
+    return canSupportBatchedReWrite;
+  }
+
+  private final boolean canSupportBatchedReWrite;
+
+  private SqlCommandType(boolean reWriteSupport) {
+    canSupportBatchedReWrite = reWriteSupport;
+  }
+
+}
diff --git a/pgjdbc/src/main/java/org/postgresql/core/TypeInfo.java b/pgjdbc/src/main/java/org/postgresql/core/TypeInfo.java
index cbbbd01f70..4d108bf285 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/TypeInfo.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/TypeInfo.java
@@ -14,10 +14,10 @@
 import java.util.Iterator;
 
 public interface TypeInfo {
-  public void addCoreType(String pgTypeName, Integer oid, Integer sqlType, String javaClass,
+  void addCoreType(String pgTypeName, Integer oid, Integer sqlType, String javaClass,
       Integer arrayOid);
 
-  public void addDataType(String type, Class<? extends PGobject> klass) throws SQLException;
+  void addDataType(String type, Class<? extends PGobject> klass) throws SQLException;
 
   /**
    * Look up the SQL typecode for a given type oid.
@@ -26,7 +26,7 @@ public void addCoreType(String pgTypeName, Integer oid, Integer sqlType, String
    * @return the SQL type code (a constant from {@link java.sql.Types}) for the type
    * @throws SQLException if an error occurs when retrieving sql type
    */
-  public int getSQLType(int oid) throws SQLException;
+  int getSQLType(int oid) throws SQLException;
 
   /**
    * Look up the SQL typecode for a given postgresql type name.
@@ -35,7 +35,7 @@ public void addCoreType(String pgTypeName, Integer oid, Integer sqlType, String
    * @return the SQL type code (a constant from {@link java.sql.Types}) for the type
    * @throws SQLException if an error occurs when retrieving sql type
    */
-  public int getSQLType(String pgTypeName) throws SQLException;
+  int getSQLType(String pgTypeName) throws SQLException;
 
   /**
    * Look up the oid for a given postgresql type name. This is the inverse of
@@ -45,7 +45,7 @@ public void addCoreType(String pgTypeName, Integer oid, Integer sqlType, String
    * @return the type's OID, or 0 if unknown
    * @throws SQLException if an error occurs when retrieving PG type
    */
-  public int getPGType(String pgTypeName) throws SQLException;
+  int getPGType(String pgTypeName) throws SQLException;
 
   /**
    * Look up the postgresql type name for a given oid. This is the inverse of
@@ -55,7 +55,7 @@ public void addCoreType(String pgTypeName, Integer oid, Integer sqlType, String
    * @return the server type name for that OID or null if unknown
    * @throws SQLException if an error occurs when retrieving PG type
    */
-  public String getPGType(int oid) throws SQLException;
+  String getPGType(int oid) throws SQLException;
 
   /**
    * Look up the oid of an array's base type given the array's type oid.
@@ -64,7 +64,7 @@ public void addCoreType(String pgTypeName, Integer oid, Integer sqlType, String
    * @return the base type's OID, or 0 if unknown
    * @throws SQLException if an error occurs when retrieving array element
    */
-  public int getPGArrayElement(int oid) throws SQLException;
+  int getPGArrayElement(int oid) throws SQLException;
 
   /**
    * Determine the oid of the given base postgresql type's array type
@@ -73,7 +73,7 @@ public void addCoreType(String pgTypeName, Integer oid, Integer sqlType, String
    * @return the array type's OID, or 0 if unknown
    * @throws SQLException if an error occurs when retrieving array type
    */
-  public int getPGArrayType(String elementTypeName) throws SQLException;
+  int getPGArrayType(String elementTypeName) throws SQLException;
 
   /**
    * Determine the delimiter for the elements of the given array type oid.
@@ -82,28 +82,37 @@ public void addCoreType(String pgTypeName, Integer oid, Integer sqlType, String
    * @return the base type's array type delimiter
    * @throws SQLException if an error occurs when retrieving array delimiter
    */
-  public char getArrayDelimiter(int oid) throws SQLException;
+  char getArrayDelimiter(int oid) throws SQLException;
 
-  public Iterator<String> getPGTypeNamesWithSQLTypes();
+  Iterator<String> getPGTypeNamesWithSQLTypes();
 
-  public Class<? extends PGobject> getPGobject(String type);
+  Class<? extends PGobject> getPGobject(String type);
 
-  public String getJavaClass(int oid) throws SQLException;
+  String getJavaClass(int oid) throws SQLException;
 
-  public String getTypeForAlias(String alias);
+  String getTypeForAlias(String alias);
 
-  public int getPrecision(int oid, int typmod);
+  int getPrecision(int oid, int typmod);
 
-  public int getScale(int oid, int typmod);
+  int getScale(int oid, int typmod);
 
-  public boolean isCaseSensitive(int oid);
+  boolean isCaseSensitive(int oid);
 
-  public boolean isSigned(int oid);
+  boolean isSigned(int oid);
 
-  public int getDisplaySize(int oid, int typmod);
+  int getDisplaySize(int oid, int typmod);
 
-  public int getMaximumPrecision(int oid);
+  int getMaximumPrecision(int oid);
 
-  public boolean requiresQuoting(int oid) throws SQLException;
+  boolean requiresQuoting(int oid) throws SQLException;
 
+  /**
+   * Returns true if particular sqlType requires quoting.
+   * This method is used internally by the driver, so it might disappear without notice.
+   *
+   * @param sqlType sql type as in java.sql.Types
+   * @return true if the type requires quoting
+   * @throws SQLException if something goes wrong
+   */
+  boolean requiresQuotingSqlType(int sqlType) throws SQLException;
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v2/ConnectionFactoryImpl.java b/pgjdbc/src/main/java/org/postgresql/core/v2/ConnectionFactoryImpl.java
index de318f3ddc..edf4a52993 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v2/ConnectionFactoryImpl.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v2/ConnectionFactoryImpl.java
@@ -61,7 +61,8 @@ public ProtocolConnection openConnectionImpl(HostSpec[] hostSpecs, String user,
     boolean trySSL;
     String sslmode = PGProperty.SSL_MODE.get(info);
     if (sslmode == null) { // Fall back to the ssl property
-      requireSSL = trySSL = PGProperty.SSL.getBoolean(info);
+      // assume "true" if the property is set but empty
+      requireSSL = trySSL = PGProperty.SSL.getBoolean(info) || "".equals(PGProperty.SSL.get(info));
     } else {
       if ("disable".equals(sslmode)) {
         requireSSL = trySSL = false;
@@ -131,9 +132,12 @@ public ProtocolConnection openConnectionImpl(HostSpec[] hostSpecs, String user,
         // Do authentication (until AuthenticationOk).
         doAuthentication(newStream, user, PGProperty.PASSWORD.get(info), logger);
 
+        int cancelSignalTimeout = PGProperty.CANCEL_SIGNAL_TIMEOUT.getInt(info) * 1000;
+
         // Do final startup.
         ProtocolConnectionImpl protoConnection =
-            new ProtocolConnectionImpl(newStream, user, database, logger, connectTimeout);
+            new ProtocolConnectionImpl(newStream, user, database, logger,
+                cancelSignalTimeout);
         readStartupMessages(newStream, protoConnection, logger);
 
         // Check Master or Slave
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v2/FastpathParameterList.java b/pgjdbc/src/main/java/org/postgresql/core/v2/FastpathParameterList.java
index b0d9283963..cc1a9e6987 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v2/FastpathParameterList.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v2/FastpathParameterList.java
@@ -182,5 +182,22 @@ public void setBinaryParameter(int index, byte[] value, int oid) {
   }
 
   private final Object[] paramValues;
+
+  public Object[] getValues() {
+    return this.paramValues;
+  }
+
+  /**
+   * Append parameters to the list.
+   */
+  public void appendAll(ParameterList list) throws SQLException {
+    if (list instanceof SimpleParameterList ) {
+      // only v2.SimpleParameterList is compatible with this type
+      SimpleParameterList spl = (SimpleParameterList) list;
+      int count = spl.getInParameterCount();
+      System.arraycopy(spl.getValues(), 0, paramValues,
+          getInParameterCount() - count, count);
+    }
+  }
 }
 
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v2/ProtocolConnectionImpl.java b/pgjdbc/src/main/java/org/postgresql/core/v2/ProtocolConnectionImpl.java
index 6b24cefde7..de15e7f68d 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v2/ProtocolConnectionImpl.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v2/ProtocolConnectionImpl.java
@@ -23,6 +23,7 @@
 import java.sql.SQLWarning;
 import java.util.ArrayList;
 import java.util.Set;
+import java.util.TimeZone;
 
 /**
  * V2 implementation of ProtocolConnection.
@@ -31,13 +32,13 @@
  */
 class ProtocolConnectionImpl implements ProtocolConnection {
   ProtocolConnectionImpl(PGStream pgStream, String user, String database, Logger logger,
-      int connectTimeout) {
+      int cancelSignalTimeout) {
     this.pgStream = pgStream;
     this.user = user;
     this.database = database;
     this.logger = logger;
     this.executor = new QueryExecutorImpl(this, pgStream, logger);
-    this.connectTimeout = connectTimeout;
+    this.cancelSignalTimeout = cancelSignalTimeout;
   }
 
   public HostSpec getHostSpec() {
@@ -101,7 +102,10 @@ public void sendQueryCancel() throws SQLException {
       }
 
       cancelStream =
-          new PGStream(pgStream.getSocketFactory(), pgStream.getHostSpec(), connectTimeout);
+          new PGStream(pgStream.getSocketFactory(), pgStream.getHostSpec(), cancelSignalTimeout);
+      if (cancelSignalTimeout > 0) {
+        cancelStream.getSocket().setSoTimeout(cancelSignalTimeout);
+      }
       cancelStream.SendInteger4(16);
       cancelStream.SendInteger2(1234);
       cancelStream.SendInteger2(5678);
@@ -109,8 +113,6 @@ public void sendQueryCancel() throws SQLException {
       cancelStream.SendInteger4(cancelKey);
       cancelStream.flush();
       cancelStream.ReceiveEOF();
-      cancelStream.close();
-      cancelStream = null;
     } catch (IOException e) {
       // Safe to ignore.
       if (logger.logDebug()) {
@@ -228,6 +230,16 @@ public void abort() {
     closed = true;
   }
 
+  @Override
+  public TimeZone getTimeZone() {
+    return TimeZone.getDefault();
+  }
+
+  @Override
+  public String getApplicationName() {
+    return "";
+  }
+
   private String serverVersion;
   private int serverVersionNum = 0;
   private int cancelPid;
@@ -246,6 +258,5 @@ public void abort() {
   private final String database;
   private final QueryExecutorImpl executor;
   private final Logger logger;
-
-  private final int connectTimeout;
+  private final int cancelSignalTimeout;
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v2/QueryExecutorImpl.java b/pgjdbc/src/main/java/org/postgresql/core/v2/QueryExecutorImpl.java
index 040dedc9c7..5d7c87d5f6 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v2/QueryExecutorImpl.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v2/QueryExecutorImpl.java
@@ -48,11 +48,11 @@ public QueryExecutorImpl(ProtocolConnectionImpl protoConnection, PGStream pgStre
   // Query parsing
   //
 
-  public Query createSimpleQuery(String sql) {
+  public Query createSimpleQuery(String sql, boolean autocommit) {
     return new V2Query(sql, false, protoConnection);
   }
 
-  public Query createParameterizedQuery(String sql) {
+  public Query createParameterizedQuery(String sql, boolean autocommit) {
     return new V2Query(sql, true, protoConnection);
   }
 
@@ -120,7 +120,7 @@ public void handleCompletion() throws SQLException {
 
       try {
         // Create and issue a dummy query to use the existing prefix infrastructure
-        V2Query query = (V2Query) createSimpleQuery("");
+        V2Query query = (V2Query) createSimpleQuery("", false);
         SimpleParameterList params = (SimpleParameterList) query.createParameterList();
         sendQuery(query, params, "BEGIN");
         processResults(query, handler, 0, 0);
@@ -573,7 +573,7 @@ private Field[] receiveFields() throws IOException {
       int typeOid = pgStream.ReceiveInteger4();
       int typeLength = pgStream.ReceiveInteger2();
       int typeModifier = pgStream.ReceiveInteger4();
-      fields[i] = new Field(columnLabel, columnLabel, typeOid, typeLength, typeModifier, 0, 0);
+      fields[i] = new Field(columnLabel, typeOid, typeLength, typeModifier, 0, 0);
     }
 
     return fields;
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v2/SimpleParameterList.java b/pgjdbc/src/main/java/org/postgresql/core/v2/SimpleParameterList.java
index 088b58e5eb..bfa177520c 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v2/SimpleParameterList.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v2/SimpleParameterList.java
@@ -208,6 +208,42 @@ public void setBinaryParameter(int index, byte[] value, int oid) {
     throw new UnsupportedOperationException();
   }
 
+  public Object[] getValues() {
+    return paramValues;
+  }
+
+  /**
+   * Append parameters to the list.
+   */
+  public void appendAll(ParameterList list) throws SQLException {
+    if (list instanceof SimpleParameterList ) {
+      /* only v2.SimpleParameterList is compatible with this type. The list
+      of parameters is expected to already be cloned from the values
+      passed by application. */
+      SimpleParameterList spl = (SimpleParameterList) list;
+      int count = spl.getInParameterCount();
+      System.arraycopy(spl.getValues(), 0, paramValues,
+          getInParameterCount() - count,
+          count);
+    }
+  }
+
+  /**
+   * Provide a useful implementation to aid debugging/testing.
+   * @return String representation of the values in the list
+   */
+  public String toString() {
+    StringBuilder ts = new StringBuilder("<[");
+    if (paramValues.length > 0) {
+      ts.append(toString(1));
+      for (int c = 2; c <= paramValues.length; c++) {
+        ts.append(" ,").append(toString(c));
+      }
+    }
+    ts.append("]>");
+    return ts.toString();
+  }
+
   private final Object[] paramValues;
 
   private final boolean useEStringSyntax;
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v2/V2Query.java b/pgjdbc/src/main/java/org/postgresql/core/v2/V2Query.java
index f8b2b9f9f8..ee0967714d 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v2/V2Query.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v2/V2Query.java
@@ -14,6 +14,8 @@
 import org.postgresql.core.Parser;
 import org.postgresql.core.ProtocolConnection;
 import org.postgresql.core.Query;
+import org.postgresql.core.SqlCommand;
+import org.postgresql.core.SqlCommandType;
 
 import java.util.List;
 
@@ -26,11 +28,12 @@ class V2Query implements Query {
     useEStringSyntax = pconn.getServerVersionNum() >= 80100;
     boolean stdStrings = pconn.getStandardConformingStrings();
 
-    List<NativeQuery> queries = Parser.parseJdbcSql(query, stdStrings, withParameters, false);
+    List<NativeQuery> queries = Parser.parseJdbcSql(query, stdStrings, withParameters, false, true, false);
     assert queries.size() <= 1 : "Exactly one query expected in V2. " + queries.size()
         + " queries given.";
 
-    nativeQuery = queries.isEmpty() ? new NativeQuery("") : queries.get(0);
+    nativeQuery = queries.isEmpty() ? new NativeQuery("", SqlCommand.createStatementTypeInfo(
+        SqlCommandType.BLANK)) : queries.get(0);
   }
 
   public ParameterList createParameterList() {
@@ -60,6 +63,10 @@ public boolean isEmpty() {
     return nativeQuery.nativeSql.isEmpty();
   }
 
+  public int getBatchSize() {
+    return 1;
+  }
+
   private static final ParameterList NO_PARAMETERS = new SimpleParameterList(0, false);
 
   private final NativeQuery nativeQuery;
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v3/BatchedQuery.java b/pgjdbc/src/main/java/org/postgresql/core/v3/BatchedQuery.java
new file mode 100644
index 0000000000..a1c6ad2f10
--- /dev/null
+++ b/pgjdbc/src/main/java/org/postgresql/core/v3/BatchedQuery.java
@@ -0,0 +1,152 @@
+/*-------------------------------------------------------------------------
+ *
+ * Copyright (c) 2003-2016, PostgreSQL Global Development Group
+ *
+ *
+ *-------------------------------------------------------------------------
+ */
+
+package org.postgresql.core.v3;
+
+import org.postgresql.core.NativeQuery;
+
+
+/**
+ * Purpose of this object is to support batched query re write behaviour. Responsibility for
+ * tracking the batch size and implement the clean up of the query fragments after the batch execute
+ * is complete. Intended to be used to wrap a Query that is present in the batchStatements
+ * collection.
+ *
+ * @author Jeremy Whiting jwhiting@redhat.com
+ * @author Christopher Deckers (chrriis@gmail.com)
+ *
+ */
+public class BatchedQuery extends SimpleQuery {
+
+  private String sql;
+  private final int valuesBraceOpenPosition;
+  private final int valuesBraceClosePosition;
+  private final int batchSize;
+  private BatchedQuery[] blocks;
+
+  public BatchedQuery(NativeQuery query, ProtocolConnectionImpl protoConnection,
+      int valuesBraceOpenPosition,
+      int valuesBraceClosePosition) {
+    super(query, protoConnection);
+    this.valuesBraceOpenPosition = valuesBraceOpenPosition;
+    this.valuesBraceClosePosition = valuesBraceClosePosition;
+    this.batchSize = 1;
+  }
+
+  private BatchedQuery(BatchedQuery src, int batchSize) {
+    super(src);
+    this.valuesBraceOpenPosition = src.valuesBraceOpenPosition;
+    this.valuesBraceClosePosition = src.valuesBraceClosePosition;
+    this.batchSize = batchSize;
+  }
+
+  public BatchedQuery deriveForMultiBatch(int valueBlock) {
+    if (getBatchSize() != 1) {
+      throw new IllegalStateException("Only the original decorator can be derived.");
+    }
+    if (valueBlock == 1) {
+      return this;
+    }
+    int index = Integer.numberOfTrailingZeros(valueBlock) - 1;
+    if (valueBlock > 128 || valueBlock != (1 << (index + 1))) {
+      throw new IllegalArgumentException(
+          "Expected value block should be a power of 2 smaller or equal to 128. Actual block is "
+              + valueBlock);
+    }
+    if (blocks == null) {
+      blocks = new BatchedQuery[7];
+    }
+    BatchedQuery bq = blocks[index];
+    if (bq == null) {
+      bq = new BatchedQuery(this, valueBlock);
+      blocks[index] = bq;
+    }
+    return bq;
+  }
+
+  @Override
+  public int getBatchSize() {
+    return batchSize;
+  }
+
+  /**
+   * Method to return the sql based on number of batches. Skipping the initial
+   * batch.
+   */
+  @Override
+  String getNativeSql() {
+    if (sql != null) {
+      return sql;
+    }
+    // dynamically build sql with parameters for batches
+    String nativeSql = super.getNativeSql();
+    int batchSize = getBatchSize();
+    if (batchSize < 2) {
+      sql = nativeSql;
+      return sql;
+    }
+    if (nativeSql == null) {
+      sql = "";
+      return sql;
+    }
+    int valuesBlockCharCount = 0;
+    // Split the values section around every dynamic parameter.
+    int[] bindPositions = getNativeQuery().bindPositions;
+    int[] chunkStart = new int[1 + bindPositions.length];
+    int[] chunkEnd = new int[1 + bindPositions.length];
+    chunkStart[0] = valuesBraceOpenPosition;
+    chunkEnd[0] = bindPositions[0];
+    // valuesBlockCharCount += chunks[0].length;
+    valuesBlockCharCount += chunkEnd[0] - chunkStart[0];
+    for (int i = 0; i < bindPositions.length; i++) {
+      int startIndex = bindPositions[i] + 2;
+      int endIndex =
+          i < bindPositions.length - 1 ? bindPositions[i + 1] : valuesBraceClosePosition + 1;
+      for (; startIndex < endIndex; startIndex++) {
+        if (!Character.isDigit(nativeSql.charAt(startIndex))) {
+          break;
+        }
+      }
+      chunkStart[i + 1] = startIndex;
+      chunkEnd[i + 1] = endIndex;
+      // valuesBlockCharCount += chunks[i + 1].length;
+      valuesBlockCharCount += chunkEnd[i + 1] - chunkStart[i + 1];
+    }
+    int length = nativeSql.length();
+    //valuesBraceOpenPosition + valuesBlockCharCount;
+    length += NativeQuery.calculateBindLength(bindPositions.length * batchSize);
+    length -= NativeQuery.calculateBindLength(bindPositions.length);
+    length += (valuesBlockCharCount + 1 /*comma*/) * (batchSize - 1 /* initial sql */);
+
+    StringBuilder s = new StringBuilder(length);
+    // Add query until end of values parameter block.
+    s.append(nativeSql, 0, valuesBraceClosePosition + 1);
+    int pos = bindPositions.length + 1;
+    for (int i = 2; i <= batchSize; i++) {
+      s.append(',');
+      s.append(nativeSql, chunkStart[0], chunkEnd[0]);
+      for (int j = 1; j < chunkStart.length; j++) {
+        NativeQuery.appendBindName(s, pos++);
+        s.append(nativeSql, chunkStart[j], chunkEnd[j]);
+      }
+    }
+    // Add trailing content: final query is like original with multi values.
+    // This could contain "--" comments, so it is important to add them at end.
+    s.append(nativeSql, valuesBraceClosePosition + 1, nativeSql.length());
+    sql = s.toString();
+    assert s.length() == length
+        : "Predicted length != actual: " + length + " !=" + s.length();
+    return sql;
+  }
+
+  @Override
+  public String toString() {
+    return getNativeSql();
+  }
+
+}
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v3/CompositeParameterList.java b/pgjdbc/src/main/java/org/postgresql/core/v3/CompositeParameterList.java
index a2fce1f586..4fbfade4ef 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v3/CompositeParameterList.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v3/CompositeParameterList.java
@@ -150,6 +150,26 @@ public void checkAllParametersSet() throws SQLException {
     }
   }
 
+  public byte[][] getEncoding() {
+    return null; // unsupported
+  }
+
+  public byte[] getFlags() {
+    return null; // unsupported
+  }
+
+  public int[] getParamTypes() {
+    return null; // unsupported
+  }
+
+  public Object[] getValues() {
+    return null; // unsupported
+  }
+
+  public void appendAll(ParameterList list) throws SQLException {
+    // no-op, unsupported
+  }
+
   public void convertFunctionOutParameters() {
     for (SimpleParameterList subparam : subparams) {
       subparam.convertFunctionOutParameters();
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v3/CompositeQuery.java b/pgjdbc/src/main/java/org/postgresql/core/v3/CompositeQuery.java
index 2abad2ae3c..3a5bc668d7 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v3/CompositeQuery.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v3/CompositeQuery.java
@@ -73,6 +73,10 @@ public boolean isEmpty() {
     return true;
   }
 
+  public int getBatchSize() {
+    return 0; // no-op, unsupported
+  }
+
   private final SimpleQuery[] subqueries;
   private final int[] offsets;
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v3/ConnectionFactoryImpl.java b/pgjdbc/src/main/java/org/postgresql/core/v3/ConnectionFactoryImpl.java
index fec5bb0a37..5c445836c3 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v3/ConnectionFactoryImpl.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v3/ConnectionFactoryImpl.java
@@ -1,6 +1,6 @@
 /*-------------------------------------------------------------------------
 *
-* Copyright (c) 2003-2014, PostgreSQL Global Development Group
+* Copyright (c) 2003-2016, PostgreSQL Global Development Group
 * Copyright (c) 2004, Open Cloud Limited.
 *
 *
@@ -24,7 +24,7 @@
 import org.postgresql.hostchooser.HostChooserFactory;
 import org.postgresql.hostchooser.HostRequirement;
 import org.postgresql.hostchooser.HostStatus;
-import org.postgresql.sspi.SSPIClient;
+import org.postgresql.sspi.ISSPIClient;
 import org.postgresql.util.GT;
 import org.postgresql.util.HostSpec;
 import org.postgresql.util.MD5Digest;
@@ -68,6 +68,22 @@ public class ConnectionFactoryImpl extends ConnectionFactory {
   private static class UnsupportedProtocolException extends IOException {
   }
 
+  private ISSPIClient createSSPI(PGStream pgStream,
+      String spnServiceClass,
+      boolean enableNegotiate,
+      Logger logger) {
+    try {
+      Class c = Class.forName("org.postgresql.sspi.SSPIClient");
+      Class[] cArg = new Class[]{PGStream.class, String.class, boolean.class, Logger.class};
+      return (ISSPIClient) c.getDeclaredConstructor(cArg)
+          .newInstance(pgStream, spnServiceClass, enableNegotiate, logger);
+    } catch (Exception e) {
+      // This catched quite a lot exceptions, but until Java 7 there is no ReflectiveOperationException
+      throw new IllegalStateException("Unable to load org.postgresql.sspi.SSPIClient."
+          + " Please check that SSPIClient is included in your pgjdbc distribution.", e);
+    }
+  }
+
   public ProtocolConnection openConnectionImpl(HostSpec[] hostSpecs, String user, String database,
       Properties info, Logger logger) throws SQLException {
     // Extract interesting values from the info properties:
@@ -76,7 +92,8 @@ public ProtocolConnection openConnectionImpl(HostSpec[] hostSpecs, String user,
     boolean trySSL;
     String sslmode = PGProperty.SSL_MODE.get(info);
     if (sslmode == null) { // Fall back to the ssl property
-      requireSSL = trySSL = PGProperty.SSL.getBoolean(info);
+      // assume "true" if the property is set but empty
+      requireSSL = trySSL = PGProperty.SSL.getBoolean(info) || "".equals(PGProperty.SSL.get(info));
     } else {
       if ("disable".equals(sslmode)) {
         requireSSL = trySSL = false;
@@ -200,16 +217,17 @@ public ProtocolConnection openConnectionImpl(HostSpec[] hostSpecs, String user,
           paramList.add(new String[]{"search_path", currentSchema});
         }
 
-        String[][] params = paramList.toArray(new String[][]{});
-
-        sendStartupPacket(newStream, params, logger);
+        sendStartupPacket(newStream, paramList, logger);
 
         // Do authentication (until AuthenticationOk).
         doAuthentication(newStream, hostSpec.getHost(), user, info, logger);
 
+        int cancelSignalTimeout = PGProperty.CANCEL_SIGNAL_TIMEOUT.getInt(info) * 1000;
+
         // Do final startup.
         ProtocolConnectionImpl protoConnection =
-            new ProtocolConnectionImpl(newStream, user, database, info, logger, connectTimeout);
+            new ProtocolConnectionImpl(newStream, user, database, info, logger,
+                cancelSignalTimeout);
         readStartupMessages(newStream, protoConnection, logger);
 
         // Check Master or Slave
@@ -357,27 +375,27 @@ private PGStream enableSSL(PGStream pgStream, boolean requireSSL, Properties inf
     }
   }
 
-  private void sendStartupPacket(PGStream pgStream, String[][] params, Logger logger)
+  private void sendStartupPacket(PGStream pgStream, List<String[]> params, Logger logger)
       throws IOException {
     if (logger.logDebug()) {
       StringBuilder details = new StringBuilder();
-      for (int i = 0; i < params.length; ++i) {
+      for (int i = 0; i < params.size(); ++i) {
         if (i != 0) {
           details.append(", ");
         }
-        details.append(params[i][0]);
+        details.append(params.get(i)[0]);
         details.append("=");
-        details.append(params[i][1]);
+        details.append(params.get(i)[1]);
       }
       logger.debug(" FE=> StartupPacket(" + details + ")");
     }
 
     // Precalculate message length and encode params.
     int length = 4 + 4;
-    byte[][] encodedParams = new byte[params.length * 2][];
-    for (int i = 0; i < params.length; ++i) {
-      encodedParams[i * 2] = params[i][0].getBytes("UTF-8");
-      encodedParams[i * 2 + 1] = params[i][1].getBytes("UTF-8");
+    byte[][] encodedParams = new byte[params.size() * 2][];
+    for (int i = 0; i < params.size(); ++i) {
+      encodedParams[i * 2] = params.get(i)[0].getBytes("UTF-8");
+      encodedParams[i * 2 + 1] = params.get(i)[1].getBytes("UTF-8");
       length += encodedParams[i * 2].length + 1 + encodedParams[i * 2 + 1].length + 1;
     }
 
@@ -404,7 +422,7 @@ private void doAuthentication(PGStream pgStream, String host, String user, Prope
     String password = PGProperty.PASSWORD.get(info);
 
     /* SSPI negotiation state, if used */
-    SSPIClient sspiClient = null;
+    ISSPIClient sspiClient = null;
 
     try {
       authloop: while (true) {
@@ -563,7 +581,7 @@ private void doAuthentication(PGStream pgStream, String host, String user, Prope
                       "Using JSSE GSSAPI, gssapi requested by server and gsslib=sspi not forced");
                 } else {
                   /* Determine if SSPI is supported by the client */
-                  sspiClient = new SSPIClient(pgStream, PGProperty.SSPI_SERVICE_CLASS.get(info),
+                  sspiClient = createSSPI(pgStream, PGProperty.SSPI_SERVICE_CLASS.get(info),
                       /* Use negotiation for SSPI, or if explicitly requested for GSS */
                       areq == AUTH_REQ_SSPI || (areq == AUTH_REQ_GSS && usespnego), logger);
 
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v3/DescribeRequest.java b/pgjdbc/src/main/java/org/postgresql/core/v3/DescribeRequest.java
index 6ee0daac36..65777dffac 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v3/DescribeRequest.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v3/DescribeRequest.java
@@ -17,11 +17,13 @@ class DescribeRequest {
   public final SimpleQuery query;
   public final SimpleParameterList parameterList;
   public final boolean describeOnly;
+  public final String statementName;
 
   public DescribeRequest(SimpleQuery query, SimpleParameterList parameterList,
-      boolean describeOnly) {
+      boolean describeOnly, String statementName) {
     this.query = query;
     this.parameterList = parameterList;
     this.describeOnly = describeOnly;
+    this.statementName = statementName;
   }
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v3/ProtocolConnectionImpl.java b/pgjdbc/src/main/java/org/postgresql/core/v3/ProtocolConnectionImpl.java
index bed54739bc..3ea152e879 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v3/ProtocolConnectionImpl.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v3/ProtocolConnectionImpl.java
@@ -25,6 +25,7 @@
 import java.util.HashSet;
 import java.util.Properties;
 import java.util.Set;
+import java.util.TimeZone;
 
 
 /**
@@ -34,7 +35,7 @@
  */
 class ProtocolConnectionImpl implements ProtocolConnection {
   ProtocolConnectionImpl(PGStream pgStream, String user, String database, Properties info,
-      Logger logger, int connectTimeout) {
+      Logger logger, int cancelSignalTimeout) {
     this.pgStream = pgStream;
     this.user = user;
     this.database = database;
@@ -42,7 +43,7 @@ class ProtocolConnectionImpl implements ProtocolConnection {
     this.executor = new QueryExecutorImpl(this, pgStream, info, logger);
     // default value for server versions that don't report standard_conforming_strings
     this.standardConformingStrings = false;
-    this.connectTimeout = connectTimeout;
+    this.cancelSignalTimeout = cancelSignalTimeout;
   }
 
   public HostSpec getHostSpec() {
@@ -102,7 +103,10 @@ public void sendQueryCancel() throws SQLException {
       }
 
       cancelStream =
-          new PGStream(pgStream.getSocketFactory(), pgStream.getHostSpec(), connectTimeout);
+          new PGStream(pgStream.getSocketFactory(), pgStream.getHostSpec(), cancelSignalTimeout);
+      if (cancelSignalTimeout > 0) {
+        cancelStream.getSocket().setSoTimeout(cancelSignalTimeout);
+      }
       cancelStream.SendInteger4(16);
       cancelStream.SendInteger2(1234);
       cancelStream.SendInteger2(5678);
@@ -110,8 +114,6 @@ public void sendQueryCancel() throws SQLException {
       cancelStream.SendInteger4(cancelKey);
       cancelStream.flush();
       cancelStream.ReceiveEOF();
-      cancelStream.close();
-      cancelStream = null;
     } catch (IOException e) {
       // Safe to ignore.
       if (logger.logDebug()) {
@@ -235,6 +237,27 @@ public void abort() {
     closed = true;
   }
 
+  public void setTimeZone(TimeZone timeZone) {
+    this.timeZone = timeZone;
+  }
+
+  @Override
+  public TimeZone getTimeZone() {
+    return timeZone;
+  }
+
+  void setApplicationName(String applicationName) {
+    this.applicationName = applicationName;
+  }
+
+  @Override
+  public String getApplicationName() {
+    if (applicationName == null) {
+      return "";
+    }
+    return applicationName;
+  }
+
   /**
    * True if server uses integers for date and time fields. False if server uses double.
    */
@@ -262,6 +285,15 @@ public void abort() {
   private final String database;
   private final QueryExecutorImpl executor;
   private final Logger logger;
+  private final int cancelSignalTimeout;
 
-  private final int connectTimeout;
+  /**
+   * TimeZone of the current connection (TimeZone backend parameter)
+   */
+  private TimeZone timeZone;
+
+  /**
+   * application_name connection property
+   */
+  private String applicationName;
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v3/QueryExecutorImpl.java b/pgjdbc/src/main/java/org/postgresql/core/v3/QueryExecutorImpl.java
index d3795fdc0d..8e31196d68 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v3/QueryExecutorImpl.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v3/QueryExecutorImpl.java
@@ -24,8 +24,11 @@
 import org.postgresql.core.QueryExecutor;
 import org.postgresql.core.ResultCursor;
 import org.postgresql.core.ResultHandler;
+import org.postgresql.core.SqlCommand;
+import org.postgresql.core.SqlCommandType;
 import org.postgresql.core.Utils;
 import org.postgresql.jdbc.BatchResultHandler;
+import org.postgresql.jdbc.TimestampUtils;
 import org.postgresql.util.GT;
 import org.postgresql.util.PSQLException;
 import org.postgresql.util.PSQLState;
@@ -57,6 +60,7 @@ public QueryExecutorImpl(ProtocolConnectionImpl protoConnection, PGStream pgStre
     this.logger = logger;
 
     this.allowEncodingChanges = PGProperty.ALLOW_ENCODING_CHANGES.getBoolean(info);
+    this.allowReWriteBatchedInserts = PGProperty.REWRITE_BATCHED_INSERTS.getBoolean(info);
   }
 
   /**
@@ -83,6 +87,7 @@ private void lock(Object obtainer) throws PSQLException {
     if (lockedFor == obtainer) {
       throw new PSQLException(GT.tr("Tried to obtain lock while already holding it"),
           PSQLState.OBJECT_NOT_IN_STATE);
+
     }
     waitOnLock();
     lockedFor = obtainer;
@@ -112,6 +117,7 @@ private void waitOnLock() throws PSQLException {
       try {
         this.wait();
       } catch (InterruptedException ie) {
+        Thread.currentThread().interrupt();
         throw new PSQLException(
             GT.tr("Interrupted while waiting to obtain lock on database connection"),
             PSQLState.OBJECT_NOT_IN_STATE, ie);
@@ -131,24 +137,35 @@ boolean hasLock(Object holder) {
   // Query parsing
   //
 
-  public Query createSimpleQuery(String sql) {
-    return parseQuery(sql, false);
+  public Query createSimpleQuery(String sql, boolean autocommit) {
+    return parseQuery(sql, false, autocommit);
   }
 
-  public Query createParameterizedQuery(String sql) {
-    return parseQuery(sql, true);
+  public Query createParameterizedQuery(String sql, boolean autocommit) {
+    return parseQuery(sql, true, autocommit);
   }
 
-  private Query parseQuery(String query, boolean withParameters) {
+  private Query parseQuery(String query, boolean withParameters, boolean autocommit) {
 
     List<NativeQuery> queries = Parser.parseJdbcSql(query,
-        protoConnection.getStandardConformingStrings(), withParameters, true);
+        protoConnection.getStandardConformingStrings(), withParameters, true,
+        autocommit, allowReWriteBatchedInserts);
     if (queries.isEmpty()) {
       // Empty query
       return EMPTY_QUERY;
     }
     if (queries.size() == 1) {
-      return new SimpleQuery(queries.get(0), protoConnection);
+      NativeQuery firstQuery = queries.get(0);
+      if (allowReWriteBatchedInserts && firstQuery.getCommand().isBatchedReWriteCompatible()) {
+        int valuesBraceOpenPosition =
+            firstQuery.getCommand().getBatchRewriteValuesBraceOpenPosition();
+        int valuesBraceClosePosition =
+            firstQuery.getCommand().getBatchRewriteValuesBraceClosePosition();
+        return new BatchedQuery(firstQuery, protoConnection, valuesBraceOpenPosition,
+            valuesBraceClosePosition);
+      } else {
+        return new SimpleQuery(firstQuery, protoConnection);
+      }
     }
 
     // Multiple statements.
@@ -1513,7 +1530,10 @@ private void sendDescribeStatement(SimpleQuery query, SimpleParameterList params
     }
     pgStream.SendChar(0); // end message
 
-    pendingDescribeStatementQueue.add(new DescribeRequest(query, params, describeOnly));
+    // Note: statement name can change over time for the same query object
+    // Thus we take a snapshot of the query name
+    pendingDescribeStatementQueue.add(
+        new DescribeRequest(query, params, describeOnly, query.getStatementName()));
     pendingDescribePortalQueue.add(query);
     query.setStatementDescribed(true);
     query.setPortalDescribed(true);
@@ -1784,7 +1804,6 @@ protected void processResults(ResultHandler handler, int flags) throws IOExcepti
 
     List<byte[][]> tuples = null;
 
-    int len;
     int c;
     boolean endQuery = false;
 
@@ -1826,7 +1845,8 @@ protected void processResults(ResultHandler handler, int flags) throws IOExcepti
           SimpleQuery query = describeData.query;
           SimpleParameterList params = describeData.parameterList;
           boolean describeOnly = describeData.describeOnly;
-          String origStatementName = query.getStatementName();
+          // This might differ from query.getStatementName if the query was re-prepared
+          String origStatementName = describeData.statementName;
 
           int numParams = pgStream.ReceiveInteger2();
 
@@ -2015,7 +2035,6 @@ protected void processResults(ResultHandler handler, int flags) throws IOExcepti
 
         {
           ExecuteRequest executeData = pendingExecuteQueue.removeFirst();
-          SimpleQuery currentQuery = executeData.query;
           Portal currentPortal = executeData.portal;
           handler.handleCommandStatus("EMPTY", 0, 0);
           if (currentPortal != null) {
@@ -2069,6 +2088,13 @@ protected void processResults(ResultHandler handler, int flags) throws IOExcepti
               endQuery = true;
             }
           }
+
+          if ("TimeZone".equals(name)) {
+            protoConnection.setTimeZone(TimestampUtils.parseBackendTimeZone(value));
+          }
+          if ("application_name".equals(name)) {
+            protoConnection.setApplicationName(value);
+          }
           break;
         }
 
@@ -2243,7 +2269,7 @@ private Field[] receiveFields() throws IOException {
       int typeLength = pgStream.ReceiveInteger2();
       int typeModifier = pgStream.ReceiveInteger4();
       int formatType = pgStream.ReceiveInteger2();
-      fields[i] = new Field(columnLabel, "", /* name not yet determined */
+      fields[i] = new Field(columnLabel,
           typeOid, typeLength, typeModifier, tableOid, positionInTable);
       fields[i].setFormat(formatType);
 
@@ -2381,6 +2407,8 @@ private void receiveRFQ() throws IOException {
   private final PGStream pgStream;
   private final Logger logger;
   private final boolean allowEncodingChanges;
+  private final boolean allowReWriteBatchedInserts;
+
 
   /**
    * The estimated server response size since we last consumed the input stream from the server, in
@@ -2393,7 +2421,9 @@ private void receiveRFQ() throws IOException {
   private int estimatedReceiveBufferBytes = 0;
 
   private final SimpleQuery beginTransactionQuery =
-      new SimpleQuery(new NativeQuery("BEGIN", new int[0]), null);
+      new SimpleQuery(new NativeQuery("BEGIN", new int[0], SqlCommand.createStatementTypeInfo(
+          SqlCommandType.BLANK)), null);
 
-  private final SimpleQuery EMPTY_QUERY = new SimpleQuery(new NativeQuery("", new int[0]), null);
+  private final SimpleQuery EMPTY_QUERY = new SimpleQuery(new NativeQuery("", new int[0], SqlCommand
+      .createStatementTypeInfo(SqlCommandType.BLANK)), null);
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v3/SimpleParameterList.java b/pgjdbc/src/main/java/org/postgresql/core/v3/SimpleParameterList.java
index 6f41c9439d..a9b59912ce 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v3/SimpleParameterList.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v3/SimpleParameterList.java
@@ -81,6 +81,7 @@ private void bind(int index, Object value, int oid, byte binary) throws SQLExcep
     }
 
     paramTypes[index] = oid;
+    pos = index + 1;
   }
 
   public int getParameterCount() {
@@ -354,6 +355,7 @@ public ParameterList copy() {
     System.arraycopy(paramValues, 0, newCopy.paramValues, 0, paramValues.length);
     System.arraycopy(paramTypes, 0, newCopy.paramTypes, 0, paramTypes.length);
     System.arraycopy(flags, 0, newCopy.flags, 0, flags.length);
+    newCopy.pos = pos;
     return newCopy;
   }
 
@@ -362,12 +364,66 @@ public void clear() {
     Arrays.fill(paramTypes, 0);
     Arrays.fill(encoded, null);
     Arrays.fill(flags, (byte) 0);
+    pos = 0;
   }
 
   public SimpleParameterList[] getSubparams() {
     return null;
   }
 
+  public Object[] getValues() {
+    return paramValues;
+  }
+
+  public int[] getParamTypes() {
+    return paramTypes;
+  }
+
+  public byte[] getFlags() {
+    return flags;
+  }
+
+  public byte[][] getEncoding() {
+    return encoded;
+  }
+
+  public void appendAll(ParameterList list) throws SQLException {
+    if (list instanceof org.postgresql.core.v3.SimpleParameterList ) {
+      /* only v3.SimpleParameterList is compatible with this type
+      we need to create copies of our parameters, otherwise the values can be changed */
+      SimpleParameterList spl = (SimpleParameterList) list;
+      int inParamCount = spl.getInParameterCount();
+      if ((pos + inParamCount) > paramValues.length) {
+        throw new PSQLException(
+          GT.tr("Added parameters index out of range: {0}, number of columns: {1}.",
+            new Object[]{(pos + inParamCount), paramValues.length}),
+              PSQLState.INVALID_PARAMETER_VALUE);
+      }
+      System.arraycopy(spl.getValues(), 0, this.paramValues, pos, inParamCount);
+      System.arraycopy(spl.getParamTypes(), 0, this.paramTypes, pos, inParamCount);
+      System.arraycopy(spl.getFlags(), 0, this.flags, pos, inParamCount);
+      System.arraycopy(spl.getEncoding(), 0, this.encoded, pos, inParamCount);
+      pos += inParamCount;
+    }
+  }
+
+  @Override
+  /**
+   * Useful implementation of toString.
+   * @return String representation of the list values
+   */
+  public String toString() {
+    StringBuilder ts = new StringBuilder("<[");
+    if (paramValues.length > 0) {
+      ts.append(toString(1));
+      for (int c = 2; c <= paramValues.length; c++) {
+        ts.append(" ,").append(toString(c));
+      }
+    }
+    ts.append("]>");
+    return ts.toString();
+  }
+
   private final Object[] paramValues;
   private final int[] paramTypes;
   private final byte[] flags;
@@ -379,5 +435,7 @@ public SimpleParameterList[] getSubparams() {
    * to null".
    */
   private final static Object NULL_OBJECT = new Object();
+
+  private int pos = 0;
 }
 
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v3/SimpleQuery.java b/pgjdbc/src/main/java/org/postgresql/core/v3/SimpleQuery.java
index a67af2990c..70b9f74d46 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v3/SimpleQuery.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v3/SimpleQuery.java
@@ -26,6 +26,10 @@
  */
 class SimpleQuery implements V3Query {
 
+  SimpleQuery(SimpleQuery src) {
+    this(src.nativeQuery, src.protoConnection);
+  }
+
   SimpleQuery(NativeQuery query, ProtocolConnectionImpl protoConnection) {
     this.nativeQuery = query;
     this.protoConnection = protoConnection;
@@ -36,7 +40,7 @@ public ParameterList createParameterList() {
       return NO_PARAMETERS;
     }
 
-    return new SimpleParameterList(nativeQuery.bindPositions.length, protoConnection);
+    return new SimpleParameterList(getBindCount(), protoConnection);
   }
 
   public String toString(ParameterList parameters) {
@@ -105,6 +109,7 @@ String getNativeSql() {
   }
 
   void setStatementName(String statementName) {
+    assert statementName != null : "statement name should not be null";
     this.statementName = statementName;
     this.encodedStatementName = Utils.encodeUTF8(statementName);
   }
@@ -126,6 +131,9 @@ boolean isPreparedFor(int[] paramTypes) {
       return false; // Not prepared.
     }
 
+    assert preparedTypes == null || paramTypes.length == preparedTypes.length
+        : String.format("paramTypes:%1$d preparedTypes:%2$d", paramTypes.length,
+        paramTypes == null ? -1 : preparedTypes.length);
     // Check for compatible types.
     for (int i = 0; i < paramTypes.length; ++i) {
       if (paramTypes[i] != Oid.UNSPECIFIED && paramTypes[i] != preparedTypes[i]) {
@@ -249,6 +257,18 @@ void unprepare() {
     cachedMaxResultRowSize = null;
   }
 
+  public int getBatchSize() {
+    return 1;
+  }
+
+  NativeQuery getNativeQuery() {
+    return nativeQuery;
+  }
+
+  public final int getBindCount() {
+    return nativeQuery.bindPositions.length * getBatchSize();
+  }
+
   private final NativeQuery nativeQuery;
 
   private final ProtocolConnectionImpl protoConnection;
@@ -270,4 +290,3 @@ void unprepare() {
 
   final static SimpleParameterList NO_PARAMETERS = new SimpleParameterList(0, null);
 }
-
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v3/V3ParameterList.java b/pgjdbc/src/main/java/org/postgresql/core/v3/V3ParameterList.java
index 08d15781a6..db0a230b2c 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v3/V3ParameterList.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v3/V3ParameterList.java
@@ -43,5 +43,21 @@ interface V3ParameterList extends ParameterList {
    */
   SimpleParameterList[] getSubparams();
 
+  /**
+   * Return the parameter type information.
+   * @return an array of {@link org.postgresql.core.Oid} type information
+   */
+  int[] getParamTypes();
 
+  /**
+   * Return the flags for each parameter.
+   * @return an array of bytes used to store flags.
+   */
+  byte[] getFlags();
+
+  /**
+   * Return the encoding for each parameter.
+   * @return nested byte array of bytes with encoding information.
+   */
+  byte[][] getEncoding();
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/ds/PGPooledConnection.java b/pgjdbc/src/main/java/org/postgresql/ds/PGPooledConnection.java
index 56e22e435e..b704ab6da2 100644
--- a/pgjdbc/src/main/java/org/postgresql/ds/PGPooledConnection.java
+++ b/pgjdbc/src/main/java/org/postgresql/ds/PGPooledConnection.java
@@ -259,7 +259,7 @@ public ConnectionHandler(Connection con) {
     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
       final String methodName = method.getName();
       // From Object
-      if (method.getDeclaringClass().getName().equals("java.lang.Object")) {
+      if (method.getDeclaringClass() == Object.class) {
         if (methodName.equals("toString")) {
           return "Pooled connection wrapping physical connection " + con;
         }
@@ -387,7 +387,7 @@ public StatementHandler(ConnectionHandler con, Statement st) {
     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
       final String methodName = method.getName();
       // From Object
-      if (method.getDeclaringClass().getName().equals("java.lang.Object")) {
+      if (method.getDeclaringClass() == Object.class) {
         if (methodName.equals("toString")) {
           return "Pooled statement wrapping physical statement " + st;
         }
diff --git a/pgjdbc/src/main/java/org/postgresql/ds/PGPoolingDataSource.java b/pgjdbc/src/main/java/org/postgresql/ds/PGPoolingDataSource.java
index 2f6446a957..e375740084 100644
--- a/pgjdbc/src/main/java/org/postgresql/ds/PGPoolingDataSource.java
+++ b/pgjdbc/src/main/java/org/postgresql/ds/PGPoolingDataSource.java
@@ -331,7 +331,7 @@ public Connection getConnection() throws SQLException {
    */
   public void close() {
     synchronized (lock) {
-      while (available.size() > 0) {
+      while (!available.isEmpty()) {
         PooledConnection pci = available.pop();
         try {
           pci.close();
@@ -339,7 +339,7 @@ public void close() {
         }
       }
       available = null;
-      while (used.size() > 0) {
+      while (!used.isEmpty()) {
         PooledConnection pci = used.pop();
         pci.removeConnectionEventListener(connectionEventListener);
         try {
@@ -372,7 +372,7 @@ private Connection getPooledConnection() throws SQLException {
             PSQLState.CONNECTION_DOES_NOT_EXIST);
       }
       while (true) {
-        if (available.size() > 0) {
+        if (!available.isEmpty()) {
           pc = available.pop();
           used.push(pc);
           break;
diff --git a/pgjdbc/src/main/java/org/postgresql/ds/common/BaseDataSource.java b/pgjdbc/src/main/java/org/postgresql/ds/common/BaseDataSource.java
index 9037a25d72..7ea7985cab 100644
--- a/pgjdbc/src/main/java/org/postgresql/ds/common/BaseDataSource.java
+++ b/pgjdbc/src/main/java/org/postgresql/ds/common/BaseDataSource.java
@@ -396,6 +396,38 @@ public void setPreparedStatementCacheSizeMiB(int cacheSize) {
     PGProperty.PREPARED_STATEMENT_CACHE_SIZE_MIB.set(properties, cacheSize);
   }
 
+  /**
+   * @return database metadata cache fields size (number of fields cached per connection)
+   * @see PGProperty#DATABASE_METADATA_CACHE_FIELDS
+   */
+  public int getDatabaseMetadataCacheFields() {
+    return PGProperty.DATABASE_METADATA_CACHE_FIELDS.getIntNoCheck(properties);
+  }
+
+  /**
+   * @param cacheSize database metadata cache fields size (number of fields cached per connection)
+   * @see PGProperty#DATABASE_METADATA_CACHE_FIELDS
+   */
+  public void setDatabaseMetadataCacheFields(int cacheSize) {
+    PGProperty.DATABASE_METADATA_CACHE_FIELDS.set(properties, cacheSize);
+  }
+
+  /**
+   * @return database metadata cache fields size (number of megabytes per connection)
+   * @see PGProperty#DATABASE_METADATA_CACHE_FIELDS_MIB
+   */
+  public int getDatabaseMetadataCacheFieldsMiB() {
+    return PGProperty.DATABASE_METADATA_CACHE_FIELDS_MIB.getIntNoCheck(properties);
+  }
+
+  /**
+   * @param cacheSize database metadata cache fields size (number of megabytes per connection)
+   * @see PGProperty#DATABASE_METADATA_CACHE_FIELDS_MIB
+   */
+  public void setDatabaseMetadataCacheFieldsMiB(int cacheSize) {
+    PGProperty.DATABASE_METADATA_CACHE_FIELDS_MIB.set(properties, cacheSize);
+  }
+
   /**
    * @param fetchSize default fetch size
    * @see PGProperty#DEFAULT_ROW_FETCH_SIZE
@@ -444,6 +476,22 @@ public int getSocketTimeout() {
     return PGProperty.SOCKET_TIMEOUT.getIntNoCheck(properties);
   }
 
+  /**
+   * @param seconds timeout that is used for sending cancel command
+   * @see PGProperty#CANCEL_SIGNAL_TIMEOUT
+   */
+  public void setCancelSignalTimeout(int seconds) {
+    PGProperty.CANCEL_SIGNAL_TIMEOUT.set(properties, seconds);
+  }
+
+  /**
+   * @return timeout that is used for sending cancel command in seconds
+   * @see PGProperty#CANCEL_SIGNAL_TIMEOUT
+   */
+  public int getCancelSignalTimeout() {
+    return PGProperty.CANCEL_SIGNAL_TIMEOUT.getIntNoCheck(properties);
+  }
+
 
   /**
    * @param enabled if SSL is enabled
@@ -453,7 +501,7 @@ public void setSsl(boolean enabled) {
     if (enabled) {
       PGProperty.SSL.set(properties, true);
     } else {
-      PGProperty.SSL.set(properties, null);
+      PGProperty.SSL.set(properties, false);
     }
   }
 
@@ -462,7 +510,8 @@ public void setSsl(boolean enabled) {
    * @see PGProperty#SSL
    */
   public boolean getSsl() {
-    return PGProperty.SSL.isPresent(properties);
+    // "true" if "ssl" is set but empty
+    return PGProperty.SSL.getBoolean(properties) || "".equals(PGProperty.SSL.get(properties));
   }
 
   /**
@@ -1178,4 +1227,20 @@ public void setLoglevel(int logLevel) {
   public int getLoglevel() {
     return PGProperty.LOG_LEVEL.getIntNoCheck(properties);
   }
+
+  /**
+   * @see PGProperty#REWRITE_BATCHED_INSERTS
+   * @return boolean indicating property is enabled or not.
+   */
+  public boolean getReWriteBatchedInserts() {
+    return PGProperty.REWRITE_BATCHED_INSERTS.getBoolean(properties);
+  }
+
+  /**
+   * @see PGProperty#REWRITE_BATCHED_INSERTS
+   * @param reWrite boolean value to set the property in the properties collection
+   */
+  public void setReWriteBatchedInserts(boolean reWrite) {
+    PGProperty.REWRITE_BATCHED_INSERTS.set(properties, reWrite);
+  }
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/fastpath/Fastpath.java b/pgjdbc/src/main/java/org/postgresql/fastpath/Fastpath.java
index f7ec863ce0..e4a4da4177 100644
--- a/pgjdbc/src/main/java/org/postgresql/fastpath/Fastpath.java
+++ b/pgjdbc/src/main/java/org/postgresql/fastpath/Fastpath.java
@@ -224,7 +224,7 @@ public long getOID(String name, FastpathArg[] args) throws SQLException {
    * @throws SQLException if a database-access error occurs or no result
    */
   public byte[] getData(String name, FastpathArg[] args) throws SQLException {
-    return (byte[]) fastpath(name, args);
+    return fastpath(name, args);
   }
 
   /**
diff --git a/pgjdbc/src/main/java/org/postgresql/geometric/PGline.java b/pgjdbc/src/main/java/org/postgresql/geometric/PGline.java
index 8a4f41d974..74fabd2f40 100644
--- a/pgjdbc/src/main/java/org/postgresql/geometric/PGline.java
+++ b/pgjdbc/src/main/java/org/postgresql/geometric/PGline.java
@@ -167,4 +167,9 @@ public String getValue() {
     return "{" + a + "," + b + "," + c + "}";
   }
 
+  @Override
+  public Object clone() throws CloneNotSupportedException {
+    // squid:S2157 "Cloneables" should implement "clone
+    return super.clone();
+  }
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/geometric/PGpoint.java b/pgjdbc/src/main/java/org/postgresql/geometric/PGpoint.java
index 5d062a4a86..dfa50a8b16 100644
--- a/pgjdbc/src/main/java/org/postgresql/geometric/PGpoint.java
+++ b/pgjdbc/src/main/java/org/postgresql/geometric/PGpoint.java
@@ -187,4 +187,10 @@ public void setLocation(int x, int y) {
   public void setLocation(Point p) {
     setLocation(p.x, p.y);
   }
+
+  @Override
+  public Object clone() throws CloneNotSupportedException {
+    // squid:S2157 "Cloneables" should implement "clone
+    return super.clone();
+  }
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/gss/GssAction.java b/pgjdbc/src/main/java/org/postgresql/gss/GssAction.java
index 71d3ed6c7c..e87efc863c 100644
--- a/pgjdbc/src/main/java/org/postgresql/gss/GssAction.java
+++ b/pgjdbc/src/main/java/org/postgresql/gss/GssAction.java
@@ -21,7 +21,6 @@ class GssAction implements PrivilegedAction<Exception> {
   private final PGStream pgStream;
   private final String host;
   private final String user;
-  private final String password;
   private final String kerberosServerName;
   private final Logger logger;
   private final boolean useSpnego;
@@ -29,12 +28,11 @@ class GssAction implements PrivilegedAction<Exception> {
 
 
   public GssAction(PGStream pgStream, GSSCredential clientCredentials, String host, String user,
-      String password, String kerberosServerName, Logger logger, boolean useSpnego) {
+      String kerberosServerName, Logger logger, boolean useSpnego) {
     this.pgStream = pgStream;
     this.clientCredentials = clientCredentials;
     this.host = host;
     this.user = user;
-    this.password = password;
     this.kerberosServerName = kerberosServerName;
     this.logger = logger;
     this.useSpnego = useSpnego;
diff --git a/pgjdbc/src/main/java/org/postgresql/gss/MakeGSS.java b/pgjdbc/src/main/java/org/postgresql/gss/MakeGSS.java
index 3e151a618d..ba894e48c1 100644
--- a/pgjdbc/src/main/java/org/postgresql/gss/MakeGSS.java
+++ b/pgjdbc/src/main/java/org/postgresql/gss/MakeGSS.java
@@ -35,8 +35,6 @@ public static void authenticate(PGStream pgStream, String host, String user, Str
       logger.debug(" <=BE AuthenticationReqGSS");
     }
 
-    Exception result = null;
-
     if (jaasApplicationName == null) {
       jaasApplicationName = "pgjdbc";
     }
@@ -44,13 +42,14 @@ public static void authenticate(PGStream pgStream, String host, String user, Str
       kerberosServerName = "postgres";
     }
 
+    Exception result = null;
     try {
       boolean performAuthentication = true;
       GSSCredential gssCredential = null;
       Subject sub = Subject.getSubject(AccessController.getContext());
       if (sub != null) {
         Set<GSSCredential> gssCreds = sub.getPrivateCredentials(GSSCredential.class);
-        if (gssCreds != null && gssCreds.size() > 0) {
+        if (gssCreds != null && !gssCreds.isEmpty()) {
           gssCredential = gssCreds.iterator().next();
           performAuthentication = false;
         }
@@ -62,7 +61,7 @@ public static void authenticate(PGStream pgStream, String host, String user, Str
         sub = lc.getSubject();
       }
       PrivilegedAction<Exception> action = new GssAction(pgStream, gssCredential, host, user,
-          password, kerberosServerName, logger, useSpnego);
+          kerberosServerName, logger, useSpnego);
 
       result = Subject.doAs(sub, action);
     } catch (Exception e) {
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/AbstractBlobClob.java b/pgjdbc/src/main/java/org/postgresql/jdbc/AbstractBlobClob.java
index 8613bb7d58..c5ca2cc38a 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/AbstractBlobClob.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/AbstractBlobClob.java
@@ -21,7 +21,6 @@
 import java.sql.Blob;
 import java.sql.SQLException;
 import java.util.ArrayList;
-import java.util.Iterator;
 
 /**
  * This class holds all of the methods common to both Blobs and Clobs.
@@ -32,7 +31,6 @@ public abstract class AbstractBlobClob {
   protected BaseConnection conn;
 
   private LargeObject currentLo;
-  private long loPos;
   private boolean currentLoIsWriteable;
   private boolean support64bit;
 
@@ -51,11 +49,7 @@ public AbstractBlobClob(BaseConnection conn, long oid) throws SQLException {
     this.currentLo = null;
     this.currentLoIsWriteable = false;
 
-    if (conn.haveMinimumServerVersion(90300)) {
-      support64bit = true;
-    } else {
-      support64bit = false;
-    }
+    support64bit = conn.haveMinimumServerVersion(90300);
 
     subLOs = new ArrayList<LargeObject>();
   }
@@ -66,9 +60,7 @@ public synchronized void free() throws SQLException {
       currentLo = null;
       currentLoIsWriteable = false;
     }
-    Iterator<LargeObject> i = subLOs.iterator();
-    while (i.hasNext()) {
-      LargeObject subLO = i.next();
+    for (LargeObject subLO : subLOs) {
       subLO.close();
     }
     subLOs = null;
@@ -187,7 +179,7 @@ public LOIterator(long start) throws SQLException {
     }
 
     public boolean hasNext() throws SQLException {
-      boolean result = false;
+      boolean result;
       if (idx < numBytes) {
         result = true;
       } else {
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/BatchResultHandler.java b/pgjdbc/src/main/java/org/postgresql/jdbc/BatchResultHandler.java
index e7c1bbf6c4..b31038ab3d 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/BatchResultHandler.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/BatchResultHandler.java
@@ -5,6 +5,7 @@
 import org.postgresql.core.Query;
 import org.postgresql.core.ResultCursor;
 import org.postgresql.core.ResultHandler;
+import org.postgresql.core.v3.BatchedQuery;
 import org.postgresql.util.GT;
 import org.postgresql.util.PSQLException;
 import org.postgresql.util.PSQLState;
@@ -27,8 +28,8 @@ public class BatchResultHandler implements ResultHandler {
   private int resultIndex = 0;
 
   private final Query[] queries;
-  private final ParameterList[] parameterLists;
   private final int[] updateCounts;
+  private final ParameterList[] parameterLists;
   private final boolean expectGeneratedKeys;
   private PgResultSet generatedKeys;
   private int committedRows; // 0 means no rows committed. 1 means row 0 was committed, and so on
@@ -37,11 +38,11 @@ public class BatchResultHandler implements ResultHandler {
   private PgResultSet latestGeneratedKeysRs;
 
   BatchResultHandler(PgStatement pgStatement, Query[] queries, ParameterList[] parameterLists,
-      int[] updateCounts, boolean expectGeneratedKeys) {
+      boolean expectGeneratedKeys) {
     this.pgStatement = pgStatement;
     this.queries = queries;
     this.parameterLists = parameterLists;
-    this.updateCounts = updateCounts;
+    this.updateCounts = new int[queries.length];
     this.expectGeneratedKeys = expectGeneratedKeys;
     this.allGeneratedRows = !expectGeneratedKeys ? null : new ArrayList<List<byte[][]>>();
   }
@@ -83,7 +84,7 @@ public void handleCommandStatus(String status, int updateCount, long insertOID)
       latestGeneratedRows = null;
     }
 
-    if (resultIndex >= updateCounts.length) {
+    if (resultIndex >= queries.length) {
       handleError(new PSQLException(GT.tr("Too many update results were returned."),
           PSQLState.TOO_MANY_RESULTS));
       return;
@@ -133,7 +134,7 @@ public void handleError(SQLException newError) {
       batchException = new BatchUpdateException(
           GT.tr("Batch entry {0} {1} was aborted.  Call getNextException to see the cause.",
               new Object[]{resultIndex, queryString}),
-          newError.getSQLState(), updateCounts);
+          newError.getSQLState(), uncompressUpdateCount());
     }
 
     batchException.setNextException(newError);
@@ -149,4 +150,49 @@ public void handleCompletion() throws SQLException {
   public ResultSet getGeneratedKeys() {
     return generatedKeys;
   }
+
+  private int[] uncompressUpdateCount() {
+    if (!(queries[0] instanceof BatchedQuery)) {
+      return updateCounts;
+    }
+    int totalRows = 0;
+    boolean hasRewrites = false;
+    for (Query query : queries) {
+      int batchSize = query.getBatchSize();
+      totalRows += batchSize;
+      hasRewrites |= batchSize > 1;
+    }
+    if (!hasRewrites) {
+      return updateCounts;
+    }
+
+    /* In this situation there is a batch that has been rewritten. Substitute
+     * the running total returned by the database with a status code to
+     * indicate successful completion for each row the driver client added
+     * to the batch.
+     */
+    int[] newUpdateCounts = new int[totalRows];
+    int offset = 0;
+    for (int i = 0; i < queries.length; i++) {
+      Query query = queries[i];
+      int batchSize = query.getBatchSize();
+      int superBatchResult = updateCounts[i];
+      if (batchSize == 1) {
+        newUpdateCounts[offset++] = superBatchResult;
+        continue;
+      }
+      if (superBatchResult > 0) {
+        // If some rows inserted, we do not really know how did they spread over individual
+        // statements
+        superBatchResult = Statement.SUCCESS_NO_INFO;
+      }
+      Arrays.fill(newUpdateCounts, offset, offset + batchSize, superBatchResult);
+      offset += batchSize;
+    }
+    return newUpdateCounts;
+  }
+
+  public int[] getUpdateCount() {
+    return uncompressUpdateCount();
+  }
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/CacheMetadata.java b/pgjdbc/src/main/java/org/postgresql/jdbc/CacheMetadata.java
deleted file mode 100644
index d7bd45aa35..0000000000
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/CacheMetadata.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package org.postgresql.jdbc;
-
-import org.postgresql.core.Field;
-
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-
-public class CacheMetadata {
-  // FIXME: unsynchronized hashmap might lead to thread stuck
-  private static Map<String, List<CacheMetadataField>> _cache =
-      new HashMap<String, List<CacheMetadataField>>();
-
-  protected boolean isCached(String idFields) {
-    return _cache.containsKey(idFields);
-  }
-
-  protected void getCache(String idFields, Field[] fields) {
-    List<CacheMetadataField> liste = _cache.get(idFields);
-    if (liste != null) {
-      int no = 0;
-      for (CacheMetadataField c : liste) {
-        c.get(fields[no++]);
-      }
-    }
-  }
-
-  protected void setCache(String idFields, Field[] fields) {
-    List<CacheMetadataField> liste = new LinkedList<CacheMetadataField>();
-
-    for (Field field : fields) {
-      CacheMetadataField c = new CacheMetadataField(field);
-      liste.add(c);
-    }
-
-    _cache.put(idFields, liste);
-  }
-
-  protected String getIdFields(Field[] fields) {
-    StringBuilder sb = new StringBuilder();
-
-    for (Field field : fields) {
-      sb.append(getIdField(field)).append('/');
-    }
-
-    return sb.toString();
-  }
-
-  private String getIdField(Field f) {
-    return f.getTableOid() + "." + f.getPositionInTable();
-  }
-}
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/CacheMetadataField.java b/pgjdbc/src/main/java/org/postgresql/jdbc/CacheMetadataField.java
deleted file mode 100644
index 2acbe22992..0000000000
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/CacheMetadataField.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package org.postgresql.jdbc;
-
-import org.postgresql.core.Field;
-
-class CacheMetadataField {
-  private String colName;
-  private String tabName;
-  private String schemaName;
-  private int nullable;
-  private boolean auto;
-
-  protected CacheMetadataField(Field f) {
-    colName = f.getColumnName();
-    tabName = f.getTableName();
-    schemaName = f.getSchemaName();
-    nullable = f.getNullable();
-    auto = f.getAutoIncrement();
-  }
-
-  protected void get(Field f) {
-    f.setColumnName(colName);
-    f.setTableName(tabName);
-    f.setSchemaName(schemaName);
-    f.setNullable(nullable);
-    f.setAutoIncrement(auto);
-  }
-}
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/CachedQueryCreateAction.java b/pgjdbc/src/main/java/org/postgresql/jdbc/CachedQueryCreateAction.java
index 35511e6949..fbd36a6a33 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/CachedQueryCreateAction.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/CachedQueryCreateAction.java
@@ -46,7 +46,7 @@ public CachedQuery create(Object key) throws SQLException {
       isFunction = false;
       outParmBeforeFunc = false;
     }
-    Query query = connection.getQueryExecutor().createParameterizedQuery(parsedSql);
+    Query query = connection.getQueryExecutor().createParameterizedQuery(parsedSql, connection.getAutoCommit());
     return new CachedQuery(key, query, isFunction, outParmBeforeFunc);
   }
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/CallableBatchResultHandler.java b/pgjdbc/src/main/java/org/postgresql/jdbc/CallableBatchResultHandler.java
index f5f199c4fd..f89421688d 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/CallableBatchResultHandler.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/CallableBatchResultHandler.java
@@ -8,12 +8,11 @@
 import java.util.List;
 
 class CallableBatchResultHandler extends BatchResultHandler {
-  CallableBatchResultHandler(PgStatement statement, Query[] queries, ParameterList[] parameterLists,
-      int[] updateCounts) {
-    super(statement, queries, parameterLists, updateCounts, false);
+  CallableBatchResultHandler(PgStatement statement, Query[] queries, ParameterList[] parameterLists) {
+    super(statement, queries, parameterLists, false);
   }
 
-  public void handleResultRows(Query fromQuery, Field[] fields, List tuples, ResultCursor cursor) {
+  public void handleResultRows(Query fromQuery, Field[] fields, List<byte[][]> tuples, ResultCursor cursor) {
     /* ignore */
   }
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/EscapedFunctions.java b/pgjdbc/src/main/java/org/postgresql/jdbc/EscapedFunctions.java
index 33c077ba46..247e8ad9f7 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/EscapedFunctions.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/EscapedFunctions.java
@@ -415,7 +415,7 @@ public static String sqlucase(List<?> parsedArgs) throws SQLException {
    * @throws SQLException if something wrong happens
    */
   public static String sqlcurdate(List<?> parsedArgs) throws SQLException {
-    if (parsedArgs.size() != 0) {
+    if (!parsedArgs.isEmpty()) {
       throw new PSQLException(GT.tr("{0} function doesn''t take any argument.", "curdate"),
           PSQLState.SYNTAX_ERROR);
     }
@@ -430,7 +430,7 @@ public static String sqlcurdate(List<?> parsedArgs) throws SQLException {
    * @throws SQLException if something wrong happens
    */
   public static String sqlcurtime(List<?> parsedArgs) throws SQLException {
-    if (parsedArgs.size() != 0) {
+    if (!parsedArgs.isEmpty()) {
       throw new PSQLException(GT.tr("{0} function doesn''t take any argument.", "curtime"),
           PSQLState.SYNTAX_ERROR);
     }
@@ -695,7 +695,7 @@ public static String sqltimestampdiff(List<?> parsedArgs) throws SQLException {
     return buf.toString();
   }
 
-  private final static String constantToDatePart(String type) throws SQLException {
+  private static String constantToDatePart(String type) throws SQLException {
     if (!type.startsWith(SQL_TSI_ROOT)) {
       throw new PSQLException(GT.tr("Interval {0} not yet implemented", type),
           PSQLState.SYNTAX_ERROR);
@@ -733,7 +733,7 @@ private final static String constantToDatePart(String type) throws SQLException
    * @throws SQLException if something wrong happens
    */
   public static String sqldatabase(List<?> parsedArgs) throws SQLException {
-    if (parsedArgs.size() != 0) {
+    if (!parsedArgs.isEmpty()) {
       throw new PSQLException(GT.tr("{0} function doesn''t take any argument.", "database"),
           PSQLState.SYNTAX_ERROR);
     }
@@ -763,7 +763,7 @@ public static String sqlifnull(List<?> parsedArgs) throws SQLException {
    * @throws SQLException if something wrong happens
    */
   public static String sqluser(List<?> parsedArgs) throws SQLException {
-    if (parsedArgs.size() != 0) {
+    if (!parsedArgs.isEmpty()) {
       throw new PSQLException(GT.tr("{0} function doesn''t take any argument.", "user"),
           PSQLState.SYNTAX_ERROR);
     }
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/FieldMetadata.java b/pgjdbc/src/main/java/org/postgresql/jdbc/FieldMetadata.java
new file mode 100644
index 0000000000..21f974c2ae
--- /dev/null
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/FieldMetadata.java
@@ -0,0 +1,89 @@
+package org.postgresql.jdbc;
+
+import org.postgresql.util.CanEstimateSize;
+
+/**
+ * This is an internal class to hold field metadata info like table name, column name, etc.
+ * This class is not meant to be used outside of pgjdbc.
+ */
+public class FieldMetadata implements CanEstimateSize {
+  public static class Key {
+    final int tableOid;
+    final int positionInTable;
+
+    Key(int tableOid, int positionInTable) {
+      this.positionInTable = positionInTable;
+      this.tableOid = tableOid;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) {
+        return true;
+      }
+      if (o == null || getClass() != o.getClass()) {
+        return false;
+      }
+
+      Key key = (Key) o;
+
+      if (tableOid != key.tableOid) {
+        return false;
+      }
+      return positionInTable == key.positionInTable;
+    }
+
+    @Override
+    public int hashCode() {
+      int result = tableOid;
+      result = 31 * result + positionInTable;
+      return result;
+    }
+
+    @Override
+    public String toString() {
+      return "Key{"
+          + "tableOid=" + tableOid
+          + ", positionInTable=" + positionInTable
+          + '}';
+    }
+  }
+
+  final String columnName;
+  final String tableName;
+  final String schemaName;
+  final int nullable;
+  final boolean autoIncrement;
+
+  public FieldMetadata(String columnName) {
+    this(columnName, "", "", PgResultSetMetaData.columnNullableUnknown, false);
+  }
+
+  FieldMetadata(String columnName, String tableName, String schemaName, int nullable,
+      boolean autoIncrement) {
+    this.columnName = columnName;
+    this.tableName = tableName;
+    this.schemaName = schemaName;
+    this.nullable = nullable;
+    this.autoIncrement = autoIncrement;
+  }
+
+  public long getSize() {
+    return columnName.length() * 2
+        + tableName.length() * 2
+        + schemaName.length() * 2
+        + 4L
+        + 1L;
+  }
+
+  @Override
+  public String toString() {
+    return "FieldMetadata{"
+        + "columnName='" + columnName + '\''
+        + ", tableName='" + tableName + '\''
+        + ", schemaName='" + schemaName + '\''
+        + ", nullable=" + nullable
+        + ", autoIncrement=" + autoIncrement
+        + '}';
+  }
+}
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/PgArray.java b/pgjdbc/src/main/java/org/postgresql/jdbc/PgArray.java
index 6cc1757299..5ed6a5a0ab 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/PgArray.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/PgArray.java
@@ -171,6 +171,10 @@ public Object getArrayImpl(long index, int count, Map<String, Class<?>> map) thr
       return readBinaryArray((int) index, count);
     }
 
+    if (fieldString == null) {
+      return null;
+    }
+
     buildArrayList();
 
     if (count == 0) {
@@ -458,7 +462,7 @@ private synchronized void buildArrayList() throws SQLException {
           i++;
         } else if (!insideString && chars[i] == '{') {
           // subarray start
-          if (dims.size() == 0) {
+          if (dims.isEmpty()) {
             dims.add(arrayList);
           } else {
             PgArrayList a = new PgArrayList();
@@ -502,7 +506,7 @@ private synchronized void buildArrayList() throws SQLException {
           String b = buffer == null ? null : buffer.toString();
 
           // add element to current array
-          if (b != null && (b.length() > 0 || wasInsideString)) {
+          if (b != null && (!b.isEmpty() || wasInsideString)) {
             curArray.add(!wasInsideString && haveMinServer82 && b.equals("NULL") ? null : b);
           }
 
@@ -514,7 +518,7 @@ private synchronized void buildArrayList() throws SQLException {
             dims.remove(dims.size() - 1);
 
             // when multi-dimension
-            if (dims.size() > 0) {
+            if (!dims.isEmpty()) {
               curArray = dims.get(dims.size() - 1);
             }
 
@@ -877,11 +881,11 @@ public ResultSet getResultSetImpl(long index, int count, Map<String, Class<?>> m
 
     BaseStatement stat = (BaseStatement) connection
         .createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
-    return (ResultSet) stat.createDriverResultSet(fields, rows);
+    return stat.createDriverResultSet(fields, rows);
   }
 
   public String toString() {
-    if (fieldString == null) {
+    if (fieldString == null && fieldBytes != null) {
       try {
         Object array = readBinaryArray(1,0);
         java.sql.Array tmpArray = connection.createArrayOf(getBaseTypeName(), (Object[]) array);
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/PgCallableStatement.java b/pgjdbc/src/main/java/org/postgresql/jdbc/PgCallableStatement.java
index 72848e3f56..e35235b7c7 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/PgCallableStatement.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/PgCallableStatement.java
@@ -434,9 +434,9 @@ private void checkIndex(int parameterIndex, boolean fetchingData) throws SQLExce
   }
 
   @Override
-  protected BatchResultHandler createBatchHandler(int[] updateCounts, Query[] queries,
+  protected BatchResultHandler createBatchHandler(Query[] queries,
       ParameterList[] parameterLists) {
-    return new CallableBatchResultHandler(this, queries, parameterLists, updateCounts);
+    return new CallableBatchResultHandler(this, queries, parameterLists);
   }
 
   public java.sql.Array getArray(int i) throws SQLException {
@@ -459,7 +459,7 @@ public Clob getClob(int i) throws SQLException {
     throw Driver.notImplemented(this.getClass(), "getClob(int)");
   }
 
-  public Object getObjectImpl(int i, java.util.Map map) throws SQLException {
+  public Object getObjectImpl(int i, Map<String, Class<?>> map) throws SQLException {
     if (map == null || map.isEmpty()) {
       return getObject(i);
     }
@@ -872,7 +872,7 @@ public BigDecimal getBigDecimal(String parameterName) throws SQLException {
     throw Driver.notImplemented(this.getClass(), "getBigDecimal(String)");
   }
 
-  public Object getObjectImpl(String parameterName, java.util.Map map) throws SQLException {
+  public Object getObjectImpl(String parameterName, Map<String, Class<?>> map) throws SQLException {
     throw Driver.notImplemented(this.getClass(), "getObject(String,Map)");
   }
 
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/PgConnection.java b/pgjdbc/src/main/java/org/postgresql/jdbc/PgConnection.java
index 815f7f1598..78d37b3164 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/PgConnection.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/PgConnection.java
@@ -21,6 +21,7 @@
 import org.postgresql.core.Logger;
 import org.postgresql.core.Oid;
 import org.postgresql.core.ProtocolConnection;
+import org.postgresql.core.Provider;
 import org.postgresql.core.Query;
 import org.postgresql.core.QueryExecutor;
 import org.postgresql.core.ResultCursor;
@@ -69,6 +70,7 @@
 import java.util.Properties;
 import java.util.Set;
 import java.util.StringTokenizer;
+import java.util.TimeZone;
 import java.util.Timer;
 import java.util.TimerTask;
 import java.util.concurrent.Executor;
@@ -147,34 +149,28 @@ public class PgConnection implements BaseConnection {
   // Only instantiated if a task is actually scheduled.
   private volatile Timer cancelTimer = null;
 
-  // In general, it is not expected that connection would be used in multiple threads concurrently
-  // However, if client performs cleanup of statements via finalizers/phantomreferences, then it
-  // might
-  // result in AbstractJdbc2Statement.close to be called concurrently with active operation on
-  // connection
-  // Thus we synchronize access to avoid java.util.ConcurrentModificationException
   private final LruCache<Object, CachedQuery> statementCache;
+  private final LruCache<FieldMetadata.Key, FieldMetadata> fieldMetadataCache;
+
+  private boolean reWriteBatchedInserts = false;
 
   CachedQuery borrowQuery(String sql, boolean isCallable) throws SQLException {
     Object key = isCallable ? new CallableQueryKey(sql) : sql;
-    // Synchronized to fix #368
-    synchronized (statementCache) {
-      return statementCache.borrow(key);
-    }
+    return statementCache.borrow(key);
   }
 
   void releaseQuery(CachedQuery cachedQuery) {
-    // Synchronized to fix #368
-    synchronized (statementCache) {
-      statementCache.put(cachedQuery.key, cachedQuery);
-    }
+    statementCache.put(cachedQuery.key, cachedQuery);
   }
 
   //
   // Ctor.
   //
-  public PgConnection(HostSpec[] hostSpecs, String user, String database, Properties info,
-      String url) throws SQLException {
+  public PgConnection(HostSpec[] hostSpecs,
+                      String user,
+                      String database,
+                      Properties info,
+                      String url) throws SQLException {
     this.creatingURL = url;
 
     // Read loglevel arg and set the loglevel based on this value
@@ -318,11 +314,17 @@ public PgConnection(HostSpec[] hostSpecs, String user, String database, Properti
 
     // Initialize timestamp stuff
     timestampUtils = new TimestampUtils(haveMinimumServerVersion(ServerVersion.v7_4),
-        haveMinimumServerVersion(ServerVersion.v8_2), !protoConnection.getIntegerDateTimes());
+        haveMinimumServerVersion(ServerVersion.v8_2), !protoConnection.getIntegerDateTimes(),
+        new Provider<TimeZone>() {
+          @Override
+          public TimeZone get() {
+            return protoConnection.getTimeZone();
+          }
+        });
 
     // Initialize common queries.
-    commitQuery = getQueryExecutor().createSimpleQuery("COMMIT");
-    rollbackQuery = getQueryExecutor().createSimpleQuery("ROLLBACK");
+    commitQuery = getQueryExecutor().createSimpleQuery("COMMIT", getAutoCommit());
+    rollbackQuery = getQueryExecutor().createSimpleQuery("ROLLBACK", getAutoCommit());
 
     int unknownLength = PGProperty.UNKNOWN_LENGTH.getInt(info);
 
@@ -337,6 +339,7 @@ public PgConnection(HostSpec[] hostSpecs, String user, String database, Properti
     statementCache = new LruCache<Object, CachedQuery>(
         Math.max(0, PGProperty.PREPARED_STATEMENT_CACHE_QUERIES.getInt(info)),
         Math.max(0, PGProperty.PREPARED_STATEMENT_CACHE_SIZE_MIB.getInt(info) * 1024 * 1024),
+        false,
         new CachedQueryCreateAction(this, protoConnection.getServerVersionNum()),
         new LruCache.EvictAction<CachedQuery>() {
           @Override
@@ -363,6 +366,13 @@ public void evict(CachedQuery cachedQuery) throws SQLException {
       }
       this._clientInfo.put("ApplicationName", appName);
     }
+
+    reWriteBatchedInserts = PGProperty.REWRITE_BATCHED_INSERTS.getBoolean(info);
+
+    fieldMetadataCache = new LruCache<FieldMetadata.Key, FieldMetadata>(
+            Math.max(0, PGProperty.DATABASE_METADATA_CACHE_FIELDS.getInt(info)),
+            Math.max(0, PGProperty.DATABASE_METADATA_CACHE_FIELDS_MIB.getInt(info) * 1024 * 1024),
+        false);
   }
 
   private Set<Integer> getOidSet(String oidList) throws PSQLException {
@@ -1101,11 +1111,19 @@ public void setForceBinary(boolean newValue) {
     this.forcebinary = newValue;
   }
 
-
   public void setTypeMapImpl(Map<String, Class<?>> map) throws SQLException {
     typemap = map;
   }
 
+  @Override
+  public boolean isReWriteBatchedInsertsEnabled() {
+    return this.reWriteBatchedInserts;
+  }
+
+  public void setReWriteBatchedInserts(boolean reWrite) {
+    this.reWriteBatchedInserts = reWrite;
+  }
+
   public Logger getLogger() {
     return logger;
   }
@@ -1184,6 +1202,11 @@ public String escapeLiteral(String literal) throws SQLException {
         .toString();
   }
 
+  @Override
+  public LruCache<FieldMetadata.Key, FieldMetadata> getFieldMetadataCache() {
+    return fieldMetadataCache;
+  }
+
   private static void appendArray(StringBuilder sb, Object elements, char delim) {
     sb.append('{');
 
@@ -1362,6 +1385,10 @@ public void setClientInfo(String name, String value) throws SQLClientInfoExcepti
       if (value == null) {
         value = "";
       }
+      final String oldValue = protoConnection.getApplicationName();
+      if (value.equals(oldValue)) {
+        return;
+      }
 
       try {
         StringBuilder sql = new StringBuilder("SET application_name = '");
@@ -1412,11 +1439,13 @@ public void setClientInfo(Properties properties) throws SQLClientInfoException {
 
   public String getClientInfo(String name) throws SQLException {
     checkClosed();
+    _clientInfo.put("ApplicationName", protoConnection.getApplicationName());
     return _clientInfo.getProperty(name);
   }
 
   public Properties getClientInfo() throws SQLException {
     checkClosed();
+    _clientInfo.put("ApplicationName", protoConnection.getApplicationName());
     return _clientInfo;
   }
 
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/PgDatabaseMetaData.java b/pgjdbc/src/main/java/org/postgresql/jdbc/PgDatabaseMetaData.java
index 5c19fff6b9..26ae89944e 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/PgDatabaseMetaData.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/PgDatabaseMetaData.java
@@ -14,6 +14,7 @@
 import org.postgresql.core.Oid;
 import org.postgresql.core.ServerVersion;
 import org.postgresql.util.GT;
+import org.postgresql.util.JdbcBlackHole;
 import org.postgresql.util.PSQLException;
 import org.postgresql.util.PSQLState;
 
@@ -70,17 +71,21 @@ protected int getMaxIndexKeys() throws SQLException {
             + " t1.typelem=t2.oid AND t1.typname='oidvector'";
       }
       Statement stmt = connection.createStatement();
-      ResultSet rs = stmt.executeQuery(sql);
-      if (!rs.next()) {
-        stmt.close();
-        throw new PSQLException(
-            GT.tr(
-                "Unable to determine a value for MaxIndexKeys due to missing system catalog data."),
-            PSQLState.UNEXPECTED_ERROR);
-      }
-      INDEX_MAX_KEYS = rs.getInt(1);
-      rs.close();
-      stmt.close();
+      ResultSet rs = null;
+      try {
+        rs = stmt.executeQuery(sql);
+        if (!rs.next()) {
+          stmt.close();
+          throw new PSQLException(
+              GT.tr(
+                  "Unable to determine a value for MaxIndexKeys due to missing system catalog data."),
+              PSQLState.UNEXPECTED_ERROR);
+        }
+        INDEX_MAX_KEYS = rs.getInt(1);
+      } finally {
+        JdbcBlackHole.close(rs);
+        JdbcBlackHole.close(stmt);
+      }
     }
     return INDEX_MAX_KEYS;
   }
@@ -95,14 +100,18 @@ protected int getMaxNameLength() throws SQLException {
         sql = "SELECT typlen FROM pg_type WHERE typname='name'";
       }
       Statement stmt = connection.createStatement();
-      ResultSet rs = stmt.executeQuery(sql);
-      if (!rs.next()) {
-        throw new PSQLException(GT.tr("Unable to find name datatype in the system catalogs."),
-            PSQLState.UNEXPECTED_ERROR);
+      ResultSet rs = null;
+      try {
+        rs = stmt.executeQuery(sql);
+        if (!rs.next()) {
+          throw new PSQLException(GT.tr("Unable to find name datatype in the system catalogs."),
+              PSQLState.UNEXPECTED_ERROR);
+        }
+        NAMEDATALEN = rs.getInt("typlen");
+      } finally {
+        JdbcBlackHole.close(rs);
+        JdbcBlackHole.close(stmt);
       }
-      NAMEDATALEN = rs.getInt("typlen");
-      rs.close();
-      stmt.close();
     }
     return NAMEDATALEN - 1;
   }
@@ -976,12 +985,12 @@ protected String escapeQuotes(String s) throws SQLException {
     return sb.toString();
   }
 
-  public java.sql.ResultSet getProcedures(String catalog, String schemaPattern,
+  public ResultSet getProcedures(String catalog, String schemaPattern,
       String procedureNamePattern) throws SQLException {
     return getProcedures(getJDBCMajorVersion(), catalog, schemaPattern, procedureNamePattern);
   }
 
-  protected java.sql.ResultSet getProcedures(int jdbcVersion, String catalog, String schemaPattern,
+  protected ResultSet getProcedures(int jdbcVersion, String catalog, String schemaPattern,
       String procedureNamePattern) throws SQLException {
     String sql;
     if (connection.haveMinimumServerVersion(ServerVersion.v7_3)) {
@@ -1035,13 +1044,13 @@ protected java.sql.ResultSet getProcedures(int jdbcVersion, String catalog, Stri
     return createMetaDataStatement().executeQuery(sql);
   }
 
-  public java.sql.ResultSet getProcedureColumns(String catalog, String schemaPattern,
+  public ResultSet getProcedureColumns(String catalog, String schemaPattern,
       String procedureNamePattern, String columnNamePattern) throws SQLException {
     return getProcedureColumns(getJDBCMajorVersion(), catalog, schemaPattern, procedureNamePattern,
         columnNamePattern);
   }
 
-  protected java.sql.ResultSet getProcedureColumns(int jdbcVersion, String catalog,
+  protected ResultSet getProcedureColumns(int jdbcVersion, String catalog,
       String schemaPattern, String procedureNamePattern, String columnNamePattern)
           throws SQLException {
     int columns = 13;
@@ -1282,7 +1291,7 @@ protected java.sql.ResultSet getProcedureColumns(int jdbcVersion, String catalog
     return ((BaseStatement) createMetaDataStatement()).createDriverResultSet(f, v);
   }
 
-  public java.sql.ResultSet getTables(String catalog, String schemaPattern, String tableNamePattern,
+  public ResultSet getTables(String catalog, String schemaPattern, String tableNamePattern,
       String types[]) throws SQLException {
     String select;
     String orderby;
@@ -1494,7 +1503,7 @@ public java.sql.ResultSet getTables(String catalog, String schemaPattern, String
     ht.put("NOSCHEMAS", "c.relkind = 'm'");
   }
 
-  public java.sql.ResultSet getSchemas() throws SQLException {
+  public ResultSet getSchemas() throws SQLException {
     return getSchemas(getJDBCMajorVersion(), null, null);
   }
 
@@ -1540,7 +1549,7 @@ protected ResultSet getSchemas(int jdbcVersion, String catalog, String schemaPat
    * PostgreSQL does not support multiple catalogs from a single connection, so to reduce confusion
    * we only return the current catalog. {@inheritDoc}
    */
-  public java.sql.ResultSet getCatalogs() throws SQLException {
+  public ResultSet getCatalogs() throws SQLException {
     Field f[] = new Field[1];
     List<byte[][]> v = new ArrayList<byte[][]>();
     f[0] = new Field("TABLE_CAT", Oid.VARCHAR);
@@ -1551,7 +1560,7 @@ public java.sql.ResultSet getCatalogs() throws SQLException {
     return ((BaseStatement) createMetaDataStatement()).createDriverResultSet(f, v);
   }
 
-  public java.sql.ResultSet getTableTypes() throws SQLException {
+  public ResultSet getTableTypes() throws SQLException {
     String types[] = new String[tableTypeClauses.size()];
     Iterator<String> e = tableTypeClauses.keySet().iterator();
     int i = 0;
@@ -1572,7 +1581,7 @@ public java.sql.ResultSet getTableTypes() throws SQLException {
     return ((BaseStatement) createMetaDataStatement()).createDriverResultSet(f, v);
   }
 
-  protected java.sql.ResultSet getColumns(int jdbcVersion, String catalog, String schemaPattern,
+  protected ResultSet getColumns(int jdbcVersion, String catalog, String schemaPattern,
       String tableNamePattern, String columnNamePattern) throws SQLException {
     int numberOfFields;
     if (jdbcVersion >= 4) {
@@ -1797,13 +1806,13 @@ protected java.sql.ResultSet getColumns(int jdbcVersion, String catalog, String
     return ((BaseStatement) createMetaDataStatement()).createDriverResultSet(f, v);
   }
 
-  public java.sql.ResultSet getColumns(String catalog, String schemaPattern,
+  public ResultSet getColumns(String catalog, String schemaPattern,
       String tableNamePattern, String columnNamePattern) throws SQLException {
     return getColumns(getJDBCMajorVersion(), catalog, schemaPattern, tableNamePattern,
         columnNamePattern);
   }
 
-  public java.sql.ResultSet getColumnPrivileges(String catalog, String schema, String table,
+  public ResultSet getColumnPrivileges(String catalog, String schema, String table,
       String columnNamePattern) throws SQLException {
     Field f[] = new Field[8];
     List<byte[][]> v = new ArrayList<byte[][]>();
@@ -1920,7 +1929,7 @@ public java.sql.ResultSet getColumnPrivileges(String catalog, String schema, Str
     return ((BaseStatement) createMetaDataStatement()).createDriverResultSet(f, v);
   }
 
-  public java.sql.ResultSet getTablePrivileges(String catalog, String schemaPattern,
+  public ResultSet getTablePrivileges(String catalog, String schemaPattern,
       String tableNamePattern) throws SQLException {
     Field f[] = new Field[7];
     List<byte[][]> v = new ArrayList<byte[][]>();
@@ -2023,7 +2032,7 @@ private static void sortStringArray(String s[]) {
    */
   private static List<String> parseACLArray(String aclString) {
     List<String> acls = new ArrayList<String>();
-    if (aclString == null || aclString.length() == 0) {
+    if (aclString == null || aclString.isEmpty()) {
       return acls;
     }
     boolean inQuotes = false;
@@ -2068,7 +2077,7 @@ private static void addACLPrivileges(String acl, Map<String, Map<String, List<St
 
     String user = acl.substring(0, equalIndex);
     String grantor = null;
-    if (user.length() == 0) {
+    if (user.isEmpty()) {
       user = "PUBLIC";
     }
     String privs;
@@ -2186,7 +2195,7 @@ public Map<String, Map<String, List<String[]>>> parseACL(String aclArray, String
     return privileges;
   }
 
-  public java.sql.ResultSet getBestRowIdentifier(String catalog, String schema, String table,
+  public ResultSet getBestRowIdentifier(String catalog, String schema, String table,
       int scope, boolean nullable) throws SQLException {
     Field f[] = new Field[8];
     List<byte[][]> v = new ArrayList<byte[][]>(); // The new ResultSet tuple stuff
@@ -2272,7 +2281,7 @@ public java.sql.ResultSet getBestRowIdentifier(String catalog, String schema, St
     return ((BaseStatement) createMetaDataStatement()).createDriverResultSet(f, v);
   }
 
-  public java.sql.ResultSet getVersionColumns(String catalog, String schema, String table)
+  public ResultSet getVersionColumns(String catalog, String schema, String table)
       throws SQLException {
     Field f[] = new Field[8];
     List<byte[][]> v = new ArrayList<byte[][]>(); // The new ResultSet tuple stuff
@@ -2314,7 +2323,7 @@ public java.sql.ResultSet getVersionColumns(String catalog, String schema, Strin
     return ((BaseStatement) createMetaDataStatement()).createDriverResultSet(f, v);
   }
 
-  public java.sql.ResultSet getPrimaryKeys(String catalog, String schema, String table)
+  public ResultSet getPrimaryKeys(String catalog, String schema, String table)
       throws SQLException {
     String sql;
     if (connection.haveMinimumServerVersion(ServerVersion.v8_1)) {
@@ -2382,7 +2391,7 @@ public java.sql.ResultSet getPrimaryKeys(String catalog, String schema, String t
    * @return ResultSet
    * @throws SQLException if something wrong happens
    */
-  protected java.sql.ResultSet getImportedExportedKeys(String primaryCatalog, String primarySchema,
+  protected ResultSet getImportedExportedKeys(String primaryCatalog, String primarySchema,
       String primaryTable, String foreignCatalog, String foreignSchema, String foreignTable)
           throws SQLException {
     Field f[] = new Field[14];
@@ -2659,7 +2668,7 @@ protected java.sql.ResultSet getImportedExportedKeys(String primaryCatalog, Stri
       // we are primarily interested in the column names which are the last items in the string
 
       List<String> tokens = tokenize(targs, "\\000");
-      if (tokens.size() > 0) {
+      if (!tokens.isEmpty()) {
         fkName = tokens.get(0);
       }
 
@@ -2706,24 +2715,24 @@ protected java.sql.ResultSet getImportedExportedKeys(String primaryCatalog, Stri
     return ((BaseStatement) createMetaDataStatement()).createDriverResultSet(f, tuples);
   }
 
-  public java.sql.ResultSet getImportedKeys(String catalog, String schema, String table)
+  public ResultSet getImportedKeys(String catalog, String schema, String table)
       throws SQLException {
     return getImportedExportedKeys(null, null, null, catalog, schema, table);
   }
 
-  public java.sql.ResultSet getExportedKeys(String catalog, String schema, String table)
+  public ResultSet getExportedKeys(String catalog, String schema, String table)
       throws SQLException {
     return getImportedExportedKeys(catalog, schema, table, null, null, null);
   }
 
-  public java.sql.ResultSet getCrossReference(String primaryCatalog, String primarySchema,
+  public ResultSet getCrossReference(String primaryCatalog, String primarySchema,
       String primaryTable, String foreignCatalog, String foreignSchema, String foreignTable)
           throws SQLException {
     return getImportedExportedKeys(primaryCatalog, primarySchema, primaryTable, foreignCatalog,
         foreignSchema, foreignTable);
   }
 
-  public java.sql.ResultSet getTypeInfo() throws SQLException {
+  public ResultSet getTypeInfo() throws SQLException {
 
     Field f[] = new Field[18];
     List<byte[][]> v = new ArrayList<byte[][]>(); // The new ResultSet tuple stuff
@@ -2777,12 +2786,16 @@ public java.sql.ResultSet getTypeInfo() throws SQLException {
       int typeOid = (int) rs.getLong(2);
 
       tuple[0] = connection.encodeString(typname);
+      int sqlType = connection.getTypeInfo().getSQLType(typname);
       tuple[1] =
-          connection.encodeString(Integer.toString(connection.getTypeInfo().getSQLType(typname)));
+          connection.encodeString(Integer.toString(sqlType));
       tuple[2] = connection
           .encodeString(Integer.toString(connection.getTypeInfo().getMaximumPrecision(typeOid)));
 
-      if (connection.getTypeInfo().requiresQuoting(typeOid)) {
+      // Using requiresQuoting(oid) would might trigger select statements that might fail with NPE
+      // if oid in question is being dropped.
+      // requiresQuotingSqlType is not bulletproof, however, it solves the most visible NPE.
+      if (connection.getTypeInfo().requiresQuotingSqlType(sqlType)) {
         tuple[3] = bliteral;
         tuple[4] = bliteral;
       }
@@ -2824,7 +2837,7 @@ public java.sql.ResultSet getTypeInfo() throws SQLException {
     return ((BaseStatement) createMetaDataStatement()).createDriverResultSet(f, v);
   }
 
-  public java.sql.ResultSet getIndexInfo(String catalog, String schema, String tableName,
+  public ResultSet getIndexInfo(String catalog, String schema, String tableName,
       boolean unique, boolean approximate) throws SQLException {
     /*
      * This is a complicated function because we have three possible situations: <= 7.2 no schemas,
@@ -2849,13 +2862,22 @@ public java.sql.ResultSet getIndexInfo(String catalog, String schema, String tab
           + "  END AS TYPE, "
           + "  (i.keys).n AS ORDINAL_POSITION, "
           + "  trim(both '\"' from pg_catalog.pg_get_indexdef(ci.oid, (i.keys).n, false)) AS COLUMN_NAME, "
-          + "  CASE am.amcanorder "
-          + "    WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 "
+          // TODO: Implement ASC_OR_DESC for PostgreSQL 9.6+
+          + (connection.haveMinimumServerVersion(ServerVersion.v9_6)
+          ? "  CASE am.amname "
+          + "    WHEN 'btree' THEN CASE i.indoption[(i.keys).n - 1] & 1 "
           + "      WHEN 1 THEN 'D' "
           + "      ELSE 'A' "
           + "    END "
           + "    ELSE NULL "
           + "  END AS ASC_OR_DESC, "
+          : "  CASE am.amcanorder "
+              + "    WHEN true THEN CASE i.indoption[(i.keys).n - 1] & 1 "
+              + "      WHEN 1 THEN 'D' "
+              + "      ELSE 'A' "
+              + "    END "
+              + "    ELSE NULL "
+              + "  END AS ASC_OR_DESC, ")
           + "  ci.reltuples AS CARDINALITY, "
           + "  ci.relpages AS PAGES, "
           + "  pg_catalog.pg_get_expr(i.indpred, i.indrelid) AS FILTER_CONDITION "
@@ -2975,18 +2997,18 @@ private static List<String> tokenize(String input, String delimiter) {
 
   public boolean supportsResultSetType(int type) throws SQLException {
     // The only type we don't support
-    return type != java.sql.ResultSet.TYPE_SCROLL_SENSITIVE;
+    return type != ResultSet.TYPE_SCROLL_SENSITIVE;
   }
 
 
   public boolean supportsResultSetConcurrency(int type, int concurrency) throws SQLException {
     // These combinations are not supported!
-    if (type == java.sql.ResultSet.TYPE_SCROLL_SENSITIVE) {
+    if (type == ResultSet.TYPE_SCROLL_SENSITIVE) {
       return false;
     }
 
     // We do support Updateable ResultSets
-    if (concurrency == java.sql.ResultSet.CONCUR_UPDATABLE) {
+    if (concurrency == ResultSet.CONCUR_UPDATABLE) {
       return true;
     }
 
@@ -3037,7 +3059,7 @@ public boolean supportsBatchUpdates() throws SQLException {
     return true;
   }
 
-  public java.sql.ResultSet getUDTs(String catalog, String schemaPattern, String typeNamePattern,
+  public ResultSet getUDTs(String catalog, String schemaPattern, String typeNamePattern,
       int[] types) throws SQLException {
     String sql = "select "
         + "null as type_cat, n.nspname as type_schem, t.typname as type_name,  null as class_name, "
@@ -3122,8 +3144,8 @@ public boolean rowChangesAreVisible(int type) throws SQLException {
   }
 
   protected java.sql.Statement createMetaDataStatement() throws SQLException {
-    return connection.createStatement(java.sql.ResultSet.TYPE_SCROLL_INSENSITIVE,
-        java.sql.ResultSet.CONCUR_READ_ONLY);
+    return connection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
+        ResultSet.CONCUR_READ_ONLY);
   }
 
   public long getMaxLogicalLobSize() throws SQLException {
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/PgPreparedStatement.java b/pgjdbc/src/main/java/org/postgresql/jdbc/PgPreparedStatement.java
index 62ee9d84bf..e4e8157f17 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/PgPreparedStatement.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/PgPreparedStatement.java
@@ -16,6 +16,7 @@
 import org.postgresql.core.Query;
 import org.postgresql.core.QueryExecutor;
 import org.postgresql.core.ServerVersion;
+import org.postgresql.core.v3.BatchedQuery;
 import org.postgresql.largeobject.LargeObject;
 import org.postgresql.largeobject.LargeObjectManager;
 import org.postgresql.util.ByteConverter;
@@ -62,6 +63,7 @@
 import java.time.OffsetDateTime;
 //#endif
 import java.util.ArrayList;
+import java.util.Calendar;
 import java.util.Map;
 import java.util.TimeZone;
 import java.util.UUID;
@@ -82,6 +84,8 @@ class PgPreparedStatement extends PgStatement implements PreparedStatement {
    */
   protected boolean outParmBeforeFunc = false;
 
+  private TimeZone defaultTimeZone;
+
   PgPreparedStatement(PgConnection connection, String sql, int rsType, int rsConcurrency,
       int rsHoldability) throws SQLException {
     this(connection, sql, false, rsType, rsConcurrency, rsHoldability);
@@ -156,11 +160,15 @@ public boolean execute() throws SQLException {
   }
 
   public boolean executeWithFlags(int flags) throws SQLException {
-    checkClosed();
+    try {
+      checkClosed();
 
-    execute(preparedQuery.query, preparedParameters, flags);
+      execute(preparedQuery.query, preparedParameters, flags);
 
-    return (result != null && result.getResultSet() != null);
+      return (result != null && result.getResultSet() != null);
+    } finally {
+      defaultTimeZone = null;
+    }
   }
 
   protected boolean isOneShotQuery(Query query) {
@@ -239,6 +247,10 @@ public void setNull(int parameterIndex, int sqlType) throws SQLException {
         oid = Oid.DATE;
         break;
       case Types.TIME:
+      //#if mvn.project.property.postgresql.jdbc.spec >= "JDBC4.2"
+      case Types.TIME_WITH_TIMEZONE:
+      case Types.TIMESTAMP_WITH_TIMEZONE:
+      //#endif
       case Types.TIMESTAMP:
         oid = Oid.UNSPECIFIED;
         break;
@@ -547,7 +559,7 @@ private void setPGobject(int parameterIndex, PGobject x) throws SQLException {
     }
   }
 
-  private void setMap(int parameterIndex, Map x) throws SQLException {
+  private void setMap(int parameterIndex, Map<?, ?> x) throws SQLException {
     int oid = connection.getTypeInfo().getPGType("hstore");
     if (oid == Oid.UNSPECIFIED) {
       throw new PSQLException(GT.tr("No hstore extension installed."),
@@ -629,7 +641,7 @@ public void setObject(int parameterIndex, Object in, int targetSqlType, int scal
             break;
             //#endif
           } else {
-            tmpd = connection.getTimestampUtils().toDate(null, in.toString());
+            tmpd = connection.getTimestampUtils().toDate(getDefaultCalendar(), in.toString());
           }
           setDate(parameterIndex, tmpd);
         }
@@ -647,7 +659,7 @@ public void setObject(int parameterIndex, Object in, int targetSqlType, int scal
             break;
             //#endif
           } else {
-            tmpt = connection.getTimestampUtils().toTime(null, in.toString());
+            tmpt = connection.getTimestampUtils().toTime(getDefaultCalendar(), in.toString());
           }
           setTime(parameterIndex, tmpt);
         }
@@ -667,7 +679,7 @@ public void setObject(int parameterIndex, Object in, int targetSqlType, int scal
             break;
             //#endif
           } else {
-            tmpts = connection.getTimestampUtils().toTimestamp(null, in.toString());
+            tmpts = connection.getTimestampUtils().toTimestamp(getDefaultCalendar(), in.toString());
           }
           setTimestamp(parameterIndex, tmpts);
         }
@@ -733,6 +745,8 @@ public void setObject(int parameterIndex, Object in, int targetSqlType, int scal
       case Types.OTHER:
         if (in instanceof PGobject) {
           setPGobject(parameterIndex, (PGobject) in);
+        } else if (in instanceof Map) {
+          setMap(parameterIndex, (Map<?, ?>) in);
         } else {
           bindString(parameterIndex, in.toString(), Oid.UNSPECIFIED);
         }
@@ -1033,7 +1047,7 @@ public void setObject(int parameterIndex, Object x) throws SQLException {
       setTimestamp(parameterIndex, (OffsetDateTime) x);
       //#endif
     } else if (x instanceof Map) {
-      setMap(parameterIndex, (Map) x);
+      setMap(parameterIndex, (Map<?, ?>) x);
     } else {
       // Can't infer a type.
       throw new PSQLException(GT.tr(
@@ -1111,15 +1125,16 @@ public void addBatch(String p_sql) throws SQLException {
 
   public void addBatch() throws SQLException {
     checkClosed();
-
     if (batchStatements == null) {
       batchStatements = new ArrayList<Query>();
       batchParameters = new ArrayList<ParameterList>();
     }
-
     // we need to create copies of our parameters, otherwise the values can be changed
-    batchStatements.add(preparedQuery.query);
     batchParameters.add(preparedParameters.copy());
+    Query query = preparedQuery.query;
+    if (!(query instanceof BatchedQuery) || batchStatements.isEmpty()) {
+      batchStatements.add(query);
+    }
   }
 
   public ResultSetMetaData getMetaData() throws SQLException {
@@ -1388,6 +1403,9 @@ public void setDate(int i, java.sql.Date d, java.util.Calendar cal) throws SQLEx
     // 2005-01-01 00:00:00+03
     // (1 row)
 
+    if (cal == null) {
+      cal = getDefaultCalendar();
+    }
     bindString(i, connection.getTimestampUtils().toString(cal, d), Oid.UNSPECIFIED);
   }
 
@@ -1412,6 +1430,9 @@ public void setTime(int i, Time t, java.util.Calendar cal) throws SQLException {
       }
     }
 
+    if (cal == null) {
+      cal = getDefaultCalendar();
+    }
     bindString(i, connection.getTimestampUtils().toString(cal, t), oid);
   }
 
@@ -1465,7 +1486,9 @@ public void setTimestamp(int i, Timestamp t, java.util.Calendar cal) throws SQLE
         cal = pgTimestamp.getCalendar();
       }
     }
-
+    if (cal == null) {
+      cal = getDefaultCalendar();
+    }
     bindString(i, connection.getTimestampUtils().toString(cal, t), oid);
   }
 
@@ -1632,6 +1655,27 @@ public void setURL(int parameterIndex, java.net.URL x) throws SQLException {
     throw Driver.notImplemented(this.getClass(), "setURL(int,URL)");
   }
 
+  @Override
+  public int[] executeBatch() throws SQLException {
+    try {
+      return super.executeBatch();
+    } finally {
+      defaultTimeZone = null;
+    }
+  }
+
+  private Calendar getDefaultCalendar() {
+    TimestampUtils timestampUtils = connection.getTimestampUtils();
+    if (timestampUtils.hasFastDefaultTimeZone()) {
+      return timestampUtils.getSharedCalendar(null);
+    }
+    Calendar sharedCalendar = timestampUtils.getSharedCalendar(defaultTimeZone);
+    if (defaultTimeZone == null) {
+      defaultTimeZone = sharedCalendar.getTimeZone();
+    }
+    return sharedCalendar;
+  }
+
   public ParameterMetaData getParameterMetaData() throws SQLException {
     int flags = QueryExecutor.QUERY_ONESHOT | QueryExecutor.QUERY_DESCRIBE_ONLY
         | QueryExecutor.QUERY_SUPPRESS_BEGIN;
@@ -1647,4 +1691,50 @@ public ParameterMetaData getParameterMetaData() throws SQLException {
     return null;
 
   }
+
+  @Override
+  protected void transformQueriesAndParameters() throws SQLException {
+    if (batchParameters.size() <= 1
+        || !(preparedQuery.query instanceof BatchedQuery)) {
+      return;
+    }
+    BatchedQuery originalQuery = (BatchedQuery) preparedQuery.query;
+    // Single query cannot have more than {@link Short#MAX_VALUE} binds, thus
+    // the number of multi-values blocks should be capped.
+    // Typically, it does not make much sense to batch more than 128 rows: performance
+    // does not improve much after updating 128 statements with 1 multi-valued one, thus
+    // we cap maximum batch size and split there.
+    final int bindCount = originalQuery.getBindCount();
+    final int highestBlockCount = 128;
+    final int maxValueBlocks =
+        Integer.highestOneBit( // deriveForMultiBatch supports powers of two only
+            Math.min(Math.max(1, (Short.MAX_VALUE - 1) / bindCount), highestBlockCount));
+    int unprocessedBatchCount = batchParameters.size();
+    final int fullValueBlocksCount = unprocessedBatchCount / maxValueBlocks;
+    final int partialValueBlocksCount = Integer.bitCount(unprocessedBatchCount % maxValueBlocks);
+    final int count = fullValueBlocksCount + partialValueBlocksCount;
+    ArrayList<Query> newBatchStatements = new ArrayList<Query>(count);
+    ArrayList<ParameterList> newBatchParameters = new ArrayList<ParameterList>(count);
+    int offset = 0;
+    for (int i = 0; i < count; i++) {
+      int valueBlock;
+      if (unprocessedBatchCount >= maxValueBlocks) {
+        valueBlock = maxValueBlocks;
+      } else {
+        valueBlock = Integer.highestOneBit(unprocessedBatchCount);
+      }
+      // Find appropriate batch for block count.
+      BatchedQuery bq = originalQuery.deriveForMultiBatch(valueBlock);
+      ParameterList newPl = bq.createParameterList();
+      for (int j = 0; j < valueBlock; j++) {
+        ParameterList pl = batchParameters.get(offset++);
+        newPl.appendAll(pl);
+      }
+      newBatchStatements.add(bq);
+      newBatchParameters.add(newPl);
+      unprocessedBatchCount -= valueBlock;
+    }
+    batchStatements = newBatchStatements;
+    batchParameters = newBatchParameters;
+  }
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/PgResultSet.java b/pgjdbc/src/main/java/org/postgresql/jdbc/PgResultSet.java
index 6b9e7ec818..088f303c32 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/PgResultSet.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/PgResultSet.java
@@ -96,10 +96,9 @@ public class PgResultSet implements ResultSet, org.postgresql.PGRefCursorResultS
   private final int resultsettype;
   private final int resultsetconcurrency;
   private int fetchdirection = ResultSet.FETCH_UNKNOWN;
+  private TimeZone defaultTimeZone;
   protected final BaseConnection connection; // the connection we belong to
   protected final BaseStatement statement; // the statement we belong to
-  private Statement realStatement;
-  // the real statement we belong to (when using forced binary prepared statement test hack)
   protected final Field fields[]; // Field metadata for this resultset.
   protected final Query originalQuery; // Query we originated from
 
@@ -346,7 +345,7 @@ public void afterLast() throws SQLException {
   public void beforeFirst() throws SQLException {
     checkScrollable();
 
-    if (rows.size() > 0) {
+    if (!rows.isEmpty()) {
       current_row = -1;
     }
 
@@ -490,10 +489,13 @@ public java.sql.Date getDate(int i, java.util.Calendar cal) throws SQLException
       return null;
     }
 
+    if (cal == null) {
+      cal = getDefaultCalendar();
+    }
     if (isBinary(i)) {
       int col = i - 1;
       int oid = fields[col].getOID();
-      TimeZone tz = cal == null ? null : cal.getTimeZone();
+      TimeZone tz = cal.getTimeZone();
       if (oid == Oid.DATE) {
         return connection.getTimestampUtils().toDateBin(tz, this_row[col]);
       } else if (oid == Oid.TIMESTAMP || oid == Oid.TIMESTAMPTZ) {
@@ -520,10 +522,13 @@ public Time getTime(int i, java.util.Calendar cal) throws SQLException {
       return null;
     }
 
+    if (cal == null) {
+      cal = getDefaultCalendar();
+    }
     if (isBinary(i)) {
       int col = i - 1;
       int oid = fields[col].getOID();
-      TimeZone tz = cal == null ? null : cal.getTimeZone();
+      TimeZone tz = cal.getTimeZone();
       if (oid == Oid.TIME || oid == Oid.TIMETZ) {
         return connection.getTimestampUtils().toTimeBin(tz, this_row[col]);
       } else if (oid == Oid.TIMESTAMP || oid == Oid.TIMESTAMPTZ) {
@@ -551,12 +556,15 @@ public Timestamp getTimestamp(int i, java.util.Calendar cal) throws SQLException
       return null;
     }
 
+    if (cal == null) {
+      cal = getDefaultCalendar();
+    }
     int col = i - 1;
     int oid = fields[col].getOID();
     if (isBinary(i)) {
       if (oid == Oid.TIMESTAMPTZ || oid == Oid.TIMESTAMP) {
         boolean hasTimeZone = oid == Oid.TIMESTAMPTZ;
-        TimeZone tz = cal == null ? null : cal.getTimeZone();
+        TimeZone tz = cal.getTimeZone();
         return connection.getTimestampUtils().toTimestampBin(tz, this_row[col], hasTimeZone);
       } else {
         // JDBC spec says getTimestamp of Time and Date must be supported
@@ -602,7 +610,8 @@ private LocalDateTime getLocalDateTime(int i) throws SQLException {
               PSQLState.DATA_TYPE_MISMATCH);
     }
     if (isBinary(i)) {
-      return connection.getTimestampUtils().toLocalDateTimeBin(this_row[col]);
+      TimeZone timeZone = getDefaultCalendar().getTimeZone();
+      return connection.getTimestampUtils().toLocalDateTimeBin(timeZone, this_row[col]);
     }
 
     String string = getString(i);
@@ -712,7 +721,7 @@ public boolean isBeforeFirst() throws SQLException {
       return false;
     }
 
-    return ((row_offset + current_row) < 0 && rows.size() > 0);
+    return ((row_offset + current_row) < 0 && !rows.isEmpty());
   }
 
 
@@ -893,7 +902,7 @@ public synchronized void deleteRow() throws SQLException {
               "Currently positioned after the end of the ResultSet.  You cannot call deleteRow() here."),
           PSQLState.INVALID_CURSOR_STATE);
     }
-    if (rows.size() == 0) {
+    if (rows.isEmpty()) {
       throw new PSQLException(GT.tr("There are no rows in this ResultSet."),
           PSQLState.INVALID_CURSOR_STATE);
     }
@@ -914,7 +923,7 @@ public synchronized void deleteRow() throws SQLException {
         }
       }
 
-      deleteStatement = ((java.sql.Connection) connection).prepareStatement(deleteSQL.toString());
+      deleteStatement = connection.prepareStatement(deleteSQL.toString());
     }
     deleteStatement.clearParameters();
 
@@ -936,7 +945,7 @@ public synchronized void insertRow() throws SQLException {
 
     if (!onInsertRow) {
       throw new PSQLException(GT.tr("Not on the insert row."), PSQLState.INVALID_CURSOR_STATE);
-    } else if (updateValues.size() == 0) {
+    } else if (updateValues.isEmpty()) {
       throw new PSQLException(GT.tr("You must specify at least one column value to insert a row."),
           PSQLState.INVALID_PARAMETER_VALUE);
     } else {
@@ -965,7 +974,7 @@ public synchronized void insertRow() throws SQLException {
       }
 
       insertSQL.append(paramSQL.toString());
-      insertStatement = ((java.sql.Connection) connection).prepareStatement(insertSQL.toString());
+      insertStatement = connection.prepareStatement(insertSQL.toString());
 
       Iterator<String> keys = updateValues.keySet().iterator();
 
@@ -1239,7 +1248,7 @@ public void refreshRow() throws SQLException {
           PSQLState.INVALID_CURSOR_STATE);
     }
 
-    if (isBeforeFirst() || isAfterLast() || rows.size() == 0) {
+    if (isBeforeFirst() || isAfterLast() || rows.isEmpty()) {
       return;
     }
 
@@ -1271,7 +1280,7 @@ public void refreshRow() throws SQLException {
     }
     // because updateable result sets do not yet support binary transfers we must request refresh
     // with updateable result set to get field data in correct format
-    selectStatement = ((java.sql.Connection) connection).prepareStatement(selectSQL.toString(),
+    selectStatement = connection.prepareStatement(selectSQL.toString(),
         ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
 
 
@@ -1305,7 +1314,7 @@ public synchronized void updateRow() throws SQLException {
           PSQLState.INVALID_CURSOR_STATE);
     }
 
-    if (isBeforeFirst() || isAfterLast() || rows.size() == 0) {
+    if (isBeforeFirst() || isAfterLast() || rows.isEmpty()) {
       throw new PSQLException(
           GT.tr(
               "Cannot update the ResultSet because it is either before the start or after the end of the results."),
@@ -1348,7 +1357,7 @@ public synchronized void updateRow() throws SQLException {
     if (connection.getLogger().logDebug()) {
       connection.getLogger().debug("updating " + updateSQL.toString());
     }
-    updateStatement = ((java.sql.Connection) connection).prepareStatement(updateSQL.toString());
+    updateStatement = connection.prepareStatement(updateSQL.toString());
 
     int i = 0;
     Iterator<Object> iterator = updateValues.values().iterator();
@@ -1519,7 +1528,7 @@ boolean isUpdateable() throws SQLException {
 
     parseQuery();
 
-    if (singleTable == false) {
+    if (!singleTable) {
       connection.getLogger().debug("not a single table");
       return false;
     }
@@ -1555,7 +1564,7 @@ boolean isUpdateable() throws SQLException {
       String[] s = quotelessTableName(tableName);
       String quotelessTableName = s[0];
       String quotelessSchemaName = s[1];
-      java.sql.ResultSet rs = ((java.sql.Connection) connection).getMetaData().getPrimaryKeys("",
+      java.sql.ResultSet rs = connection.getMetaData().getPrimaryKeys("",
           quotelessSchemaName, quotelessTableName);
       while (rs.next()) {
         numPKcolumns++;
@@ -1679,10 +1688,7 @@ private void parseQuery() {
 
   private void updateRowBuffer() throws SQLException {
 
-    Iterator<String> columns = updateValues.keySet().iterator();
-
-    while (columns.hasNext()) {
-      String columnName = columns.next();
+    for (String columnName : updateValues.keySet()) {
       int columnIndex = findColumn(columnName) - 1;
 
       Object valueObject = updateValues.get(columnName);
@@ -1699,17 +1705,22 @@ private void updateRowBuffer() throws SQLException {
 
           case Types.DATE:
             rowBuffer[columnIndex] = connection
-                .encodeString(connection.getTimestampUtils().toString(null, (Date) valueObject));
+                .encodeString(
+                    connection.getTimestampUtils().toString(
+                        getDefaultCalendar(), (Date) valueObject));
             break;
 
           case Types.TIME:
             rowBuffer[columnIndex] = connection
-                .encodeString(connection.getTimestampUtils().toString(null, (Time) valueObject));
+                .encodeString(
+                    connection.getTimestampUtils().toString(
+                        getDefaultCalendar(), (Time) valueObject));
             break;
 
           case Types.TIMESTAMP:
             rowBuffer[columnIndex] = connection.encodeString(
-                connection.getTimestampUtils().toString(null, (Timestamp) valueObject));
+                connection.getTimestampUtils().toString(
+                    getDefaultCalendar(), (Timestamp) valueObject));
             break;
 
           case Types.NULL:
@@ -1847,7 +1858,7 @@ public boolean next() throws SQLException {
       current_row = 0;
 
       // Test the new rows array.
-      if (rows.size() == 0) {
+      if (rows.isEmpty()) {
         this_row = null;
         rowBuffer = null;
         return false;
@@ -1886,13 +1897,16 @@ public String getString(int columnIndex) throws SQLException {
 
     // varchar in binary is same as text, other binary fields are converted to their text format
     if (isBinary(columnIndex) && getSQLType(columnIndex) != Types.VARCHAR) {
-      Object obj = internalGetObject(columnIndex, fields[columnIndex - 1]);
+      Field field = fields[columnIndex - 1];
+      Object obj = internalGetObject(columnIndex, field);
       if (obj == null) {
         return null;
       }
       // hack to be compatible with text protocol
       if (obj instanceof java.util.Date) {
-        return connection.getTimestampUtils().timeToString((java.util.Date) obj);
+        int oid = field.getOID();
+        return connection.getTimestampUtils().timeToString((java.util.Date) obj,
+            oid == Oid.TIMESTAMPTZ || oid == Oid.TIMETZ);
       }
       if ("hstore".equals(getPGType(columnIndex))) {
         return HStoreConverter.toString((Map<?, ?>) obj);
@@ -1946,7 +1960,7 @@ public byte getByte(int columnIndex) throws SQLException {
 
     if (s != null) {
       s = s.trim();
-      if (s.length() == 0) {
+      if (s.isEmpty()) {
         return 0;
       }
       try {
@@ -3043,7 +3057,7 @@ private long readLongValue(byte[] bytes, int oid, long minVal, long maxVal, Stri
   protected void updateValue(int columnIndex, Object value) throws SQLException {
     checkUpdateable();
 
-    if (!onInsertRow && (isBeforeFirst() || isAfterLast() || rows.size() == 0)) {
+    if (!onInsertRow && (isBeforeFirst() || isAfterLast() || rows.isEmpty())) {
       throw new PSQLException(
           GT.tr(
               "Cannot update the ResultSet because it is either before the start or after the end of the results."),
@@ -3118,11 +3132,6 @@ void addRows(List<byte[][]> tuples) {
     rows.addAll(tuples);
   }
 
-
-  public void registerRealStatement(Statement realStatement) {
-    this.realStatement = realStatement;
-  }
-
   public void updateRef(int columnIndex, Ref x) throws SQLException {
     throw org.postgresql.Driver.notImplemented(this.getClass(), "updateRef(int,Ref)");
   }
@@ -3251,7 +3260,7 @@ public <T> T getObject(int columnIndex, Class<T> type) throws SQLException {
       //#endif
       ) {
         Timestamp timestampValue = getTimestamp(columnIndex);
-        Calendar calendar = Calendar.getInstance();
+        Calendar calendar = Calendar.getInstance(getDefaultCalendar().getTimeZone());
         calendar.setTimeInMillis(timestampValue.getTime());
         return type.cast(calendar);
       } else {
@@ -3619,4 +3628,16 @@ public <T> T unwrap(Class<T> iface) throws SQLException {
     }
     throw new SQLException("Cannot unwrap to " + iface.getName());
   }
+
+  private Calendar getDefaultCalendar() {
+    TimestampUtils timestampUtils = connection.getTimestampUtils();
+    if (timestampUtils.hasFastDefaultTimeZone()) {
+      return timestampUtils.getSharedCalendar(null);
+    }
+    Calendar sharedCalendar = timestampUtils.getSharedCalendar(defaultTimeZone);
+    if (defaultTimeZone == null) {
+      defaultTimeZone = sharedCalendar.getTimeZone();
+    }
+    return sharedCalendar;
+  }
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/PgResultSetMetaData.java b/pgjdbc/src/main/java/org/postgresql/jdbc/PgResultSetMetaData.java
index e01df52ef8..75c1d66641 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/PgResultSetMetaData.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/PgResultSetMetaData.java
@@ -12,6 +12,8 @@
 import org.postgresql.core.BaseConnection;
 import org.postgresql.core.Field;
 import org.postgresql.util.GT;
+import org.postgresql.util.JdbcBlackHole;
+import org.postgresql.util.LruCache;
 import org.postgresql.util.PSQLException;
 import org.postgresql.util.PSQLState;
 
@@ -26,7 +28,6 @@ public class PgResultSetMetaData implements ResultSetMetaData, PGResultSetMetaDa
   protected final Field[] fields;
 
   private boolean fieldInfoFetched;
-  private CacheMetadata _cache;
 
   /*
    * Initialise for a result with a tuple set and a field descriptor set
@@ -37,7 +38,6 @@ public PgResultSetMetaData(BaseConnection connection, Field[] fields) {
     this.connection = connection;
     this.fields = fields;
     fieldInfoFetched = false;
-    _cache = new CacheMetadata();
   }
 
   /*
@@ -64,7 +64,7 @@ public int getColumnCount() throws SQLException {
   public boolean isAutoIncrement(int column) throws SQLException {
     fetchFieldMetaData();
     Field field = getField(column);
-    return field.getAutoIncrement();
+    return field.getMetadata().autoIncrement;
   }
 
   /*
@@ -126,7 +126,7 @@ public boolean isCurrency(int column) throws SQLException {
   public int isNullable(int column) throws SQLException {
     fetchFieldMetaData();
     Field field = getField(column);
-    return field.getNullable();
+    return field.getMetadata().nullable;
   }
 
   /*
@@ -184,9 +184,12 @@ public String getColumnName(int column) throws SQLException {
   }
 
   public String getBaseColumnName(int column) throws SQLException {
-    fetchFieldMetaData();
     Field field = getField(column);
-    return field.getColumnName();
+    if (field.getTableOid() == 0) {
+      return "";
+    }
+    fetchFieldMetaData();
+    return field.getMetadata().columnName;
   }
 
   /*
@@ -200,40 +203,53 @@ public String getSchemaName(int column) throws SQLException {
     return "";
   }
 
+  private boolean populateFieldsWithCachedMetadata() {
+    boolean allOk = true;
+    LruCache<FieldMetadata.Key, FieldMetadata> metadata = connection.getFieldMetadataCache();
+    for (Field field : fields) {
+      if (field.getMetadata() != null) {
+        // No need to update metadata
+        continue;
+      }
+
+      final FieldMetadata fieldMetadata =
+          metadata.get(new FieldMetadata.Key(field.getTableOid(), field.getPositionInTable()));
+      if (fieldMetadata == null) {
+        allOk = false;
+      } else {
+        field.setMetadata(fieldMetadata);
+      }
+    }
+    return allOk;
+  }
+
   private void fetchFieldMetaData() throws SQLException {
     if (fieldInfoFetched) {
       return;
     }
 
-    // see if cached
-    String idFields = _cache.getIdFields(fields);
-    if (_cache.isCached(idFields)) {
-      // get metadata from cache
-      _cache.getCache(idFields, fields);
+    if (populateFieldsWithCachedMetadata()) {
       fieldInfoFetched = true;
       return;
     }
 
-    fieldInfoFetched = true;
-
-    StringBuilder sql = new StringBuilder();
-    sql.append("SELECT c.oid, a.attnum, a.attname, c.relname, n.nspname, ");
-    sql.append("a.attnotnull OR (t.typtype = 'd' AND t.typnotnull), ");
-    sql.append("pg_catalog.pg_get_expr(d.adbin, d.adrelid) LIKE '%nextval(%' ");
-    sql.append("FROM pg_catalog.pg_class c ");
-    sql.append("JOIN pg_catalog.pg_namespace n ON (c.relnamespace = n.oid) ");
-    sql.append("JOIN pg_catalog.pg_attribute a ON (c.oid = a.attrelid) ");
-    sql.append("JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid) ");
-    sql.append(
-        "LEFT JOIN pg_catalog.pg_attrdef d ON (d.adrelid = a.attrelid AND d.adnum = a.attnum) ");
-    sql.append("JOIN (");
+    StringBuilder sql = new StringBuilder(
+        "SELECT c.oid, a.attnum, a.attname, c.relname, n.nspname, "
+            + "a.attnotnull OR (t.typtype = 'd' AND t.typnotnull), "
+            + "pg_catalog.pg_get_expr(d.adbin, d.adrelid) LIKE '%nextval(%' "
+            + "FROM pg_catalog.pg_class c "
+            + "JOIN pg_catalog.pg_namespace n ON (c.relnamespace = n.oid) "
+            + "JOIN pg_catalog.pg_attribute a ON (c.oid = a.attrelid) "
+            + "JOIN pg_catalog.pg_type t ON (a.atttypid = t.oid) "
+            + "LEFT JOIN pg_catalog.pg_attrdef d ON (d.adrelid = a.attrelid AND d.adnum = a.attnum) "
+            + "JOIN (");
 
     // 7.4 servers don't support row IN operations (a,b) IN ((c,d),(e,f))
     // so we've got to fake that with a JOIN here.
     //
     boolean hasSourceInfo = false;
     for (Field field : fields) {
-      if (field.getTableOid() == 0) {
+      if (field.getMetadata() != null) {
         continue;
       }
 
@@ -259,39 +275,40 @@ private void fetchFieldMetaData() throws SQLException {
     sql.append(") vals ON (c.oid = vals.oid AND a.attnum = vals.attnum) ");
 
     if (!hasSourceInfo) {
+      fieldInfoFetched = true;
       return;
     }
 
     Statement stmt = connection.createStatement();
-    ResultSet rs = stmt.executeQuery(sql.toString());
-    while (rs.next()) {
-      int table = (int) rs.getLong(1);
-      int column = (int) rs.getLong(2);
-      String columnName = rs.getString(3);
-      String tableName = rs.getString(4);
-      String schemaName = rs.getString(5);
-      int nullable =
-          rs.getBoolean(6) ? ResultSetMetaData.columnNoNulls : ResultSetMetaData.columnNullable;
-      boolean autoIncrement = rs.getBoolean(7);
-      for (Field field : fields) {
-        if (field.getTableOid() == table && field.getPositionInTable() == column) {
-          field.setColumnName(columnName);
-          field.setTableName(tableName);
-          field.setSchemaName(schemaName);
-          field.setNullable(nullable);
-          field.setAutoIncrement(autoIncrement);
-        }
+    ResultSet rs = null;
+    try {
+      LruCache<FieldMetadata.Key, FieldMetadata> metadataCache = connection.getFieldMetadataCache();
+      rs = stmt.executeQuery(sql.toString());
+      while (rs.next()) {
+        int table = (int) rs.getLong(1);
+        int column = (int) rs.getLong(2);
+        String columnName = rs.getString(3);
+        String tableName = rs.getString(4);
+        String schemaName = rs.getString(5);
+        int nullable =
+            rs.getBoolean(6) ? ResultSetMetaData.columnNoNulls : ResultSetMetaData.columnNullable;
+        boolean autoIncrement = rs.getBoolean(7);
+        FieldMetadata fieldMetadata =
+            new FieldMetadata(columnName, tableName, schemaName, nullable, autoIncrement);
+        FieldMetadata.Key key = new FieldMetadata.Key(table, column);
+        metadataCache.put(key, fieldMetadata);
       }
+    } finally {
+      JdbcBlackHole.close(rs);
+      JdbcBlackHole.close(stmt);
     }
-    stmt.close();
-    // put in cache
-    _cache.setCache(idFields, fields);
+    populateFieldsWithCachedMetadata();
   }
 
   public String getBaseSchemaName(int column) throws SQLException {
     fetchFieldMetaData();
     Field field = getField(column);
-    return field.getSchemaName();
+    return field.getMetadata().schemaName;
   }
 
   /*
@@ -338,7 +355,7 @@ public String getTableName(int column) throws SQLException {
   public String getBaseTableName(int column) throws SQLException {
     fetchFieldMetaData();
     Field field = getField(column);
-    return field.getTableName();
+    return field.getMetadata().tableName;
   }
 
   /*
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/PgStatement.java b/pgjdbc/src/main/java/org/postgresql/jdbc/PgStatement.java
index 11948e1127..5f907d5a68 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/PgStatement.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/PgStatement.java
@@ -74,20 +74,18 @@ public class PgStatement implements Statement, BaseStatement {
    * Protects statement from out-of-order cancels. It protects from both
    * {@link #setQueryTimeout(int)} and {@link #cancel()} induced ones.
    *
-   * .execute() and friends change statementState to STATE_IN_QUERY during execute. .cancel()
-   * ignores cancel request if state is IDLE. In case .execute() observes non-IN_QUERY state as it
-   * completes the query, it waits till STATE_CANCELLED. Note: the field must be
+   * {@link #execute(String)} and friends change the field to
+   * {@link StatementCancelState#IN_QUERY} during execute. {@link #cancel()}
+   * ignores cancel request if state is {@link StatementCancelState#IDLE}.
+   * In case {@link #execute(String)} observes non-{@link StatementCancelState#IDLE} state as it
+   * completes the query, it waits till {@link StatementCancelState#CANCELLED}. Note: the field must be
    * set/get/compareAndSet via {@link #STATE_UPDATER} as per {@link AtomicIntegerFieldUpdater}
    * javadoc.
    */
-  private volatile int statementState = STATE_IDLE;
-  private final static int STATE_IDLE = 0;
-  private final static int STATE_IN_QUERY = 1;
-  private final static int STATE_CANCELLING = 2;
-  private final static int STATE_CANCELLED = 3;
+  private volatile StatementCancelState statementState = StatementCancelState.IDLE;
 
-  private static final AtomicIntegerFieldUpdater<PgStatement> STATE_UPDATER =
-      AtomicIntegerFieldUpdater.newUpdater(PgStatement.class, "statementState");
+  private static final AtomicReferenceFieldUpdater<PgStatement, StatementCancelState> STATE_UPDATER =
+      AtomicReferenceFieldUpdater.newUpdater(PgStatement.class, StatementCancelState.class, "statementState");
 
   /**
    * Does the caller of execute/executeUpdate want generated keys for this execution? This is set by
@@ -275,7 +273,6 @@ public java.sql.ResultSet executeQuery(String p_sql) throws SQLException {
       ps.setFetchSize(getFetchSize());
       ps.setFetchDirection(getFetchDirection());
       PgResultSet rs = (PgResultSet) ps.executeQuery();
-      rs.registerRealStatement(this);
 
       result = firstUnclosedResult = new ResultWrapper(rs);
       return rs;
@@ -317,7 +314,7 @@ public boolean executeWithFlags(String p_sql, int flags) throws SQLException {
     checkClosed();
     p_sql = replaceProcessing(p_sql, replaceProcessingEnabled,
         connection.getStandardConformingStrings());
-    Query simpleQuery = connection.getQueryExecutor().createSimpleQuery(p_sql);
+    Query simpleQuery = connection.getQueryExecutor().createSimpleQuery(p_sql, connection.getAutoCommit());
     execute(simpleQuery, null, QueryExecutor.QUERY_ONESHOT | flags);
     this.lastSimpleQuery = simpleQuery;
     return (result != null && result.getResultSet() != null);
@@ -908,7 +905,7 @@ public void addBatch(String p_sql) throws SQLException {
     p_sql = replaceProcessing(p_sql, replaceProcessingEnabled,
         connection.getStandardConformingStrings());
 
-    batchStatements.add(connection.getQueryExecutor().createSimpleQuery(p_sql));
+    batchStatements.add(connection.getQueryExecutor().createSimpleQuery(p_sql, connection.getAutoCommit()));
     batchParameters.add(null);
   }
 
@@ -919,9 +916,9 @@ public void clearBatch() throws SQLException {
     }
   }
 
-  protected BatchResultHandler createBatchHandler(int[] updateCounts, Query[] queries,
+  protected BatchResultHandler createBatchHandler(Query[] queries,
       ParameterList[] parameterLists) {
-    return new BatchResultHandler(this, queries, parameterLists, updateCounts,
+    return new BatchResultHandler(this, queries, parameterLists,
         wantsGeneratedKeysAlways);
   }
 
@@ -934,13 +931,13 @@ public int[] executeBatch() throws SQLException {
       return new int[0];
     }
 
-    int size = batchStatements.size();
-    int[] updateCounts = new int[size];
-
     // Construct query/parameter arrays.
-    Query[] queries = batchStatements.toArray(new Query[batchStatements.size()]);
+    transformQueriesAndParameters();
+    // Empty arrays should be passed to toArray
+    // see http://shipilev.net/blog/2016/arrays-wisdom-ancients/
+    Query[] queries = batchStatements.toArray(new Query[0]);
     ParameterList[] parameterLists =
-        batchParameters.toArray(new ParameterList[batchParameters.size()]);
+        batchParameters.toArray(new ParameterList[0]);
     batchStatements.clear();
     batchParameters.clear();
 
@@ -967,8 +964,13 @@ public int[] executeBatch() throws SQLException {
       flags = QueryExecutor.QUERY_NO_RESULTS;
     }
 
-    // Only use named statements after we hit the threshold
-    if (isOneShotQuery(null)) {
+    boolean sameQueryAhead = queries.length > 1 && queries[0] == queries[1];
+
+    if (isOneShotQuery(null)
+        // If executing the same query twice in a batch, make sure the statement
+        // is server-prepared. In other words, "oneshot" only if the query is one in the batch
+        // or the queries are different
+        && !sameQueryAhead) {
       flags |= QueryExecutor.QUERY_ONESHOT;
     } else {
       // If a batch requests generated keys and isn't already described,
@@ -977,7 +979,12 @@ public int[] executeBatch() throws SQLException {
       // maximum data returned. Without that, we don't know how many queries
       // we'll be able to queue up before we risk a deadlock.
       // (see v3.QueryExecutorImpl's MAX_BUFFERED_RECV_BYTES)
-      preDescribe = wantsGeneratedKeysAlways && !queries[0].isStatementDescribed();
+
+      // SameQueryAhead is just a quick way to issue pre-describe for batch execution
+      // TODO: It should be reworked into "pre-describe if query has unknown parameter
+      // types and same query is ahead".
+      preDescribe = (wantsGeneratedKeysAlways || sameQueryAhead)
+          && !queries[0].isStatementDescribed();
       /*
        * It's also necessary to force a Describe on the first execution of the new statement, even
        * though we already described it, to work around bug #267.
@@ -990,7 +997,7 @@ public int[] executeBatch() throws SQLException {
     }
 
     BatchResultHandler handler;
-    handler = createBatchHandler(updateCounts, queries, parameterLists);
+    handler = createBatchHandler(queries, parameterLists);
 
     if (preDescribe || forceBinaryTransfers) {
       // Do a client-server round trip, parsing and describing the query so we
@@ -1026,11 +1033,11 @@ public int[] executeBatch() throws SQLException {
       }
     }
 
-    return updateCounts;
+    return handler.getUpdateCount();
   }
 
   public void cancel() throws SQLException {
-    if (!STATE_UPDATER.compareAndSet(this, STATE_IN_QUERY, STATE_CANCELLING)) {
+    if (!STATE_UPDATER.compareAndSet(this, StatementCancelState.IN_QUERY, StatementCancelState.CANCELING)) {
       // Not in query, there's nothing to cancel
       return;
     }
@@ -1040,7 +1047,7 @@ public void cancel() throws SQLException {
         connection.cancelQuery();
       }
     } finally {
-      STATE_UPDATER.set(this, STATE_CANCELLED);
+      STATE_UPDATER.set(this, StatementCancelState.CANCELLED);
       synchronized (connection) {
         connection.notifyAll(); // wake-up killTimerTask
       }
@@ -1091,7 +1098,7 @@ private void startTimer() {
      */
     cleanupTimer();
 
-    STATE_UPDATER.set(this, STATE_IN_QUERY);
+    STATE_UPDATER.set(this, StatementCancelState.IN_QUERY);
 
     if (timeout == 0) {
       return;
@@ -1139,10 +1146,10 @@ private boolean cleanupTimer() {
   private void killTimerTask() {
     boolean timerTaskIsClear = cleanupTimer();
     // The order is important here: in case we need to wait for the cancel task, the state must be
-    // kept STATE_IN_QUERY, so cancelTask would be able to cancel the query.
+    // kept StatementCancelState.IN_QUERY, so cancelTask would be able to cancel the query.
     // It is believed that this case is very rare, so "additional cancel and wait below" would not
     // harm it.
-    if (timerTaskIsClear && STATE_UPDATER.compareAndSet(this, STATE_IN_QUERY, STATE_IDLE)) {
+    if (timerTaskIsClear && STATE_UPDATER.compareAndSet(this, StatementCancelState.IN_QUERY, StatementCancelState.IDLE)) {
       return;
     }
 
@@ -1150,13 +1157,14 @@ private void killTimerTask() {
     // "timeout error"
     // We wait till state becomes "cancelled"
     boolean interrupted = false;
-    while (!STATE_UPDATER.compareAndSet(this, STATE_CANCELLED, STATE_IDLE)) {
+    while (!STATE_UPDATER.compareAndSet(this, StatementCancelState.CANCELLED, StatementCancelState.IDLE)) {
       synchronized (connection) {
         try {
           // Note: wait timeout here is irrelevant since synchronized(connection) would block until
           // .cancel finishes
           connection.wait(10);
-        } catch (InterruptedException e) {
+        } catch (InterruptedException e) { // NOSONAR
+          // Either re-interrupt this method or rethrow the "InterruptedException"
           interrupted = true;
         }
       }
@@ -1406,4 +1414,8 @@ public ResultSet createDriverResultSet(Field[] fields, List<byte[][]> tuples)
       throws SQLException {
     return createResultSet(null, fields, tuples, null);
   }
+
+  protected void transformQueriesAndParameters() throws SQLException {
+  }
+
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/StatementCancelState.java b/pgjdbc/src/main/java/org/postgresql/jdbc/StatementCancelState.java
new file mode 100644
index 0000000000..2f979da829
--- /dev/null
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/StatementCancelState.java
@@ -0,0 +1,19 @@
+/*-------------------------------------------------------------------------
+*
+* Copyright (c) 2004-2015, PostgreSQL Global Development Group
+*
+*
+*-------------------------------------------------------------------------
+*/
+
+package org.postgresql.jdbc;
+
+/**
+ * Represents {@link PgStatement#cancel()} state.
+ */
+enum StatementCancelState {
+    IDLE,
+    IN_QUERY,
+    CANCELING,
+    CANCELLED
+}
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/TimestampUtils.java b/pgjdbc/src/main/java/org/postgresql/jdbc/TimestampUtils.java
index 95d8e367fa..7a13c09245 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/TimestampUtils.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/TimestampUtils.java
@@ -10,11 +10,13 @@
 
 import org.postgresql.PGStatement;
 import org.postgresql.core.Oid;
+import org.postgresql.core.Provider;
 import org.postgresql.util.ByteConverter;
 import org.postgresql.util.GT;
 import org.postgresql.util.PSQLException;
 import org.postgresql.util.PSQLState;
 
+import java.lang.reflect.Field;
 import java.sql.Date;
 import java.sql.SQLException;
 import java.sql.Time;
@@ -30,6 +32,7 @@
 //#endif
 import java.util.Calendar;
 import java.util.GregorianCalendar;
+import java.util.HashMap;
 import java.util.SimpleTimeZone;
 import java.util.TimeZone;
 
@@ -44,13 +47,57 @@ public class TimestampUtils {
   private static final int ONEDAY = 24 * 3600 * 1000;
   private static final char[] ZEROS = {'0', '0', '0', '0', '0', '0', '0', '0', '0'};
   private static final char[][] NUMBERS;
+  private static final HashMap<String, TimeZone> GMT_ZONES = new HashMap<String, TimeZone>();
+
+  private static final Field DEFAULT_TIME_ZONE_FIELD;
+
+  private TimeZone prevDefaultZoneFieldValue;
+  private TimeZone defaultTimeZoneCache;
 
   static {
     // The expected maximum value is 60 (seconds), so 64 is used "just in case"
     NUMBERS = new char[64][];
     for (int i = 0; i < NUMBERS.length; i++) {
-      NUMBERS[i] = Integer.toString(i).toCharArray();
+      NUMBERS[i] = ((i < 10 ? "0" : "") + Integer.toString(i)).toCharArray();
     }
+
+    // Backend's gmt-3 means GMT+03 in Java. Here a map is created so gmt-3 can be converted to
+    // java TimeZone
+    for (int i = -12; i <= 14; i++) {
+      TimeZone timeZone;
+      String pgZoneName;
+      if (i == 0) {
+        timeZone = TimeZone.getTimeZone("GMT");
+        pgZoneName = "GMT";
+      } else {
+        timeZone = TimeZone.getTimeZone("GMT" + (i <= 0 ? "+" : "-") + Math.abs(i));
+        pgZoneName = "GMT" + (i >= 0 ? "+" : "-");
+      }
+
+      if (i == 0) {
+        GMT_ZONES.put(pgZoneName, timeZone);
+        continue;
+      }
+      GMT_ZONES.put(pgZoneName + Math.abs(i), timeZone);
+      GMT_ZONES.put(pgZoneName + NUMBERS[Math.abs(i)], timeZone);
+    }
+    // Fast path to getting the default timezone.
+    // Accessing the default timezone over and over creates a clone with regular API.
+    // Because we don't mutate that object in our use of it, we can access the field directly.
+    // This saves the creation of a clone everytime, and the memory associated to all these clones.
+    Field tzField;
+    try {
+      tzField = TimeZone.class.getDeclaredField("defaultTimeZone");
+      tzField.setAccessible(true);
+      TimeZone defaultTz = TimeZone.getDefault();
+      Object tzFromField = tzField.get(null);
+      if (defaultTz == null || !defaultTz.equals(tzFromField)) {
+        tzField = null;
+      }
+    } catch (Exception e) {
+      tzField = null;
+    }
+    DEFAULT_TIME_ZONE_FIELD = tzField;
   }
 
   private final StringBuilder sbuf = new StringBuilder();
@@ -70,11 +117,14 @@ public class TimestampUtils {
    * True if the backend uses doubles for time values. False if long is used.
    */
   private final boolean usesDouble;
+  private final Provider<TimeZone> timeZoneProvider;
 
-  TimestampUtils(boolean min74, boolean min82, boolean usesDouble) {
+  TimestampUtils(boolean min74, boolean min82, boolean usesDouble,
+      Provider<TimeZone> timeZoneProvider) {
     this.min74 = min74;
     this.min82 = min82;
     this.usesDouble = usesDouble;
+    this.timeZoneProvider = timeZoneProvider;
   }
 
   private Calendar getCalendar(int sign, int hr, int min, int sec) {
@@ -427,12 +477,30 @@ public synchronized Date toDate(Calendar cal, String s) throws SQLException {
   }
 
   private Calendar setupCalendar(Calendar cal) {
+    TimeZone timeZone = cal == null ? null : cal.getTimeZone();
+    return getSharedCalendar(timeZone);
+  }
+
+  /**
+   * Get a shared calendar, applying the supplied time zone or the default time zone if null.
+   *
+   * @return The shared calendar.
+   */
+  public Calendar getSharedCalendar(TimeZone timeZone) {
+    if (timeZone == null) {
+      timeZone = getDefaultTz();
+    }
     Calendar tmp = calendarWithUserTz;
-    tmp.setTimeZone(cal == null ? getDefaultTz() : cal.getTimeZone());
+    tmp.setTimeZone(timeZone);
     return tmp;
   }
 
   public synchronized String toString(Calendar cal, Timestamp x) {
+    return toString(cal, x, true);
+  }
+
+  public synchronized String toString(Calendar cal, Timestamp x,
+      boolean withTimeZone) {
     if (x.getTime() == PGStatement.DATE_POSITIVE_INFINITY) {
       return "infinity";
     } else if (x.getTime() == PGStatement.DATE_NEGATIVE_INFINITY) {
@@ -447,13 +515,20 @@ public synchronized String toString(Calendar cal, Timestamp x) {
     appendDate(sbuf, cal);
     sbuf.append(' ');
     appendTime(sbuf, cal, x.getNanos());
-    appendTimeZone(sbuf, cal);
+    if (withTimeZone) {
+      appendTimeZone(sbuf, cal);
+    }
     appendEra(sbuf, cal);
 
     return sbuf.toString();
   }
 
   public synchronized String toString(Calendar cal, Date x) {
+    return toString(cal, x, true);
+  }
+
+  public synchronized String toString(Calendar cal, Date x,
+      boolean withTimeZone) {
     if (x.getTime() == PGStatement.DATE_POSITIVE_INFINITY) {
       return "infinity";
     } else if (x.getTime() == PGStatement.DATE_NEGATIVE_INFINITY) {
@@ -467,12 +542,20 @@ public synchronized String toString(Calendar cal, Date x) {
 
     appendDate(sbuf, cal);
     appendEra(sbuf, cal);
-    appendTimeZone(sbuf, cal);
+    if (withTimeZone) {
+      sbuf.append(' ');
+      appendTimeZone(sbuf, cal);
+    }
 
     return sbuf.toString();
   }
 
   public synchronized String toString(Calendar cal, Time x) {
+    return toString(cal, x, true);
+  }
+
+  public synchronized String toString(Calendar cal, Time x,
+      boolean withTimeZone) {
     cal = setupCalendar(cal);
     cal.setTime(x);
 
@@ -481,7 +564,7 @@ public synchronized String toString(Calendar cal, Time x) {
     appendTime(sbuf, cal, cal.get(Calendar.MILLISECOND) * 1000000);
 
     // The 'time' parser for <= 7.3 doesn't like timezones.
-    if (min74) {
+    if (min74 && withTimeZone) {
       appendTimeZone(sbuf, cal);
     }
 
@@ -533,6 +616,9 @@ private static void appendTime(StringBuilder sb, int hours, int minutes, int sec
     // a two digit fractional second, but we don't need to support 7.1
     // anymore and getting the version number here is difficult.
     //
+    if (nanos == 0) {
+      return;
+    }
     sb.append('.');
     int len = sb.length();
     sb.append(nanos / 1000); // append microseconds
@@ -554,15 +640,18 @@ private void appendTimeZone(StringBuilder sb, int offset) {
     int mins = (absoff - hours * 60 * 60) / 60;
     int secs = absoff - hours * 60 * 60 - mins * 60;
 
-    sb.append((offset >= 0) ? " +" : " -");
+    sb.append((offset >= 0) ? "+" : "-");
 
     sb.append(NUMBERS[hours]);
 
+    if (mins == 0 && secs == 0) {
+      return;
+    }
     sb.append(':');
 
     sb.append(NUMBERS[mins]);
 
-    if (min82) {
+    if (min82 && secs != 0) {
       sb.append(':');
       sb.append(NUMBERS[secs]);
     }
@@ -741,8 +830,26 @@ public Date toDateBin(TimeZone tz, byte[] bytes) throws PSQLException {
     return new Date(millis);
   }
 
-  private static TimeZone getDefaultTz() {
-    return TimeZone.getDefault();
+  private TimeZone getDefaultTz() {
+    // Fast path to getting the default timezone.
+    if (DEFAULT_TIME_ZONE_FIELD != null) {
+      try {
+        TimeZone defaultTimeZone = (TimeZone) DEFAULT_TIME_ZONE_FIELD.get(null);
+        if (defaultTimeZone == prevDefaultZoneFieldValue) {
+          return defaultTimeZoneCache;
+        }
+        prevDefaultZoneFieldValue = defaultTimeZone;
+      } catch (Exception e) {
+        // If this were to fail, fallback on slow method.
+      }
+    }
+    TimeZone tz = TimeZone.getDefault();
+    defaultTimeZoneCache = tz;
+    return tz;
+  }
+
+  public boolean hasFastDefaultTimeZone() {
+    return DEFAULT_TIME_ZONE_FIELD != null;
   }
 
   /**
@@ -890,9 +997,9 @@ private ParsedBinaryTimestamp toParsedTimestampBin(TimeZone tz, byte[] bytes, bo
    * @return The parsed local date time object.
    * @throws PSQLException If binary format could not be parsed.
    */
-  public LocalDateTime toLocalDateTimeBin(byte[] bytes)  throws PSQLException {
+  public LocalDateTime toLocalDateTimeBin(TimeZone tz, byte[] bytes) throws PSQLException {
 
-    ParsedBinaryTimestamp parsedTimestamp = this.toParsedTimestampBin(null, bytes, true);
+    ParsedBinaryTimestamp parsedTimestamp = this.toParsedTimestampBin(tz, bytes, true);
     if (parsedTimestamp.infinity == Infinity.POSITIVE) {
       return LocalDateTime.MAX;
     } else if (parsedTimestamp.infinity == Infinity.NEGATIVE) {
@@ -1061,17 +1168,22 @@ public Time convertToTime(long millis, TimeZone tz) {
    * in text mode.
    *
    * @param time time value
+   * @param withTimeZone whether timezone should be added
    * @return given time value as String
    */
-  public String timeToString(java.util.Date time) {
-    long millis = time.getTime();
-    if (millis <= PGStatement.DATE_NEGATIVE_INFINITY) {
-      return "-infinity";
+  public String timeToString(java.util.Date time, boolean withTimeZone) {
+    Calendar cal = null;
+    if (withTimeZone) {
+      cal = calendarWithUserTz;
+      cal.setTimeZone(timeZoneProvider.get());
     }
-    if (millis >= PGStatement.DATE_POSITIVE_INFINITY) {
-      return "infinity";
+    if (time instanceof Timestamp) {
+      return toString(cal, (Timestamp) time, withTimeZone);
+    }
+    if (time instanceof Time) {
+      return toString(cal, (Time) time, withTimeZone);
     }
-    return time.toString();
+    return toString(cal, (Date) time, withTimeZone);
   }
 
   /**
@@ -1150,4 +1262,18 @@ public void toBinDate(TimeZone tz, byte[] bytes, Date value) throws PSQLExceptio
     ByteConverter.int4(bytes, 0, (int) (secs / 86400));
   }
 
+  /**
+   * Converts backend's TimeZone parameter to java format.
+   * Notable difference: backend's gmt-3 is GMT+03 in Java.
+   * @return java TimeZone
+   */
+  public static TimeZone parseBackendTimeZone(String timeZone) {
+    if (timeZone.startsWith("GMT")) {
+      TimeZone tz = GMT_ZONES.get(timeZone);
+      if (tz != null) {
+        return tz;
+      }
+    }
+    return TimeZone.getTimeZone(timeZone);
+  }
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/TypeInfoCache.java b/pgjdbc/src/main/java/org/postgresql/jdbc/TypeInfoCache.java
index fdb27f6360..d80a58cf34 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/TypeInfoCache.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/TypeInfoCache.java
@@ -156,10 +156,13 @@ public synchronized void addCoreType(String pgTypeName, Integer oid, Integer sql
     String pgArrayTypeName = pgTypeName + "[]";
     _pgNameToJavaClass.put(pgArrayTypeName, "java.sql.Array");
     _pgNameToSQLType.put(pgArrayTypeName, Types.ARRAY);
+    _pgNameToOid.put(pgArrayTypeName, arrayOid);
     pgArrayTypeName = "_" + pgTypeName;
     if (!_pgNameToJavaClass.containsKey(pgArrayTypeName)) {
       _pgNameToJavaClass.put(pgArrayTypeName, "java.sql.Array");
       _pgNameToSQLType.put(pgArrayTypeName, Types.ARRAY);
+      _pgNameToOid.put(pgArrayTypeName, arrayOid);
+      _oidToPgName.put(arrayOid, pgArrayTypeName);
     }
   }
 
@@ -252,9 +255,7 @@ public synchronized int getSQLType(String pgTypeName) throws SQLException {
     }
     rs.close();
 
-    if (pgTypeName != null) {
-      _pgNameToSQLType.put(pgTypeName, type);
-    }
+    _pgNameToSQLType.put(pgTypeName, type);
     return type;
   }
 
@@ -263,13 +264,13 @@ private PreparedStatement getOidStatement(String pgTypeName) throws SQLException
     boolean hasQuote = pgTypeName.contains("\"");
     int dotIndex = pgTypeName.indexOf('.');
 
-    if (dotIndex == -1 && !hasQuote) {
+    if (dotIndex == -1 && !hasQuote && !isArray) {
       if (_getOidStatementSimple == null) {
         String sql;
         if (_conn.haveMinimumServerVersion(ServerVersion.v8_0)) {
           // see comments in @getSQLType()
           // -- go with older way of unnesting array to be compatible with 8.0
-          sql = "SELECT pg_type.oid "
+          sql = "SELECT pg_type.oid, typname "
               + "  FROM pg_catalog.pg_type "
               + "  LEFT "
               + "  JOIN (select ns.oid as nspoid, ns.nspname, r.r "
@@ -282,9 +283,9 @@ private PreparedStatement getOidStatement(String pgTypeName) throws SQLException
               + " WHERE typname = ? "
               + " ORDER BY sp.r, pg_type.oid DESC LIMIT 1;";
         } else if (_conn.haveMinimumServerVersion(ServerVersion.v7_3)) {
-          sql = "SELECT oid FROM pg_catalog.pg_type WHERE typname = ? ORDER BY oid DESC LIMIT 1";
+          sql = "SELECT oid, typname FROM pg_catalog.pg_type WHERE typname = ? ORDER BY oid DESC LIMIT 1";
         } else {
-          sql = "SELECT oid FROM pg_type WHERE typname = ? ORDER BY oid DESC LIMIT 1";
+          sql = "SELECT oid, typname FROM pg_type WHERE typname = ? ORDER BY oid DESC LIMIT 1";
         }
         _getOidStatementSimple = _conn.prepareStatement(sql);
       }
@@ -292,28 +293,28 @@ private PreparedStatement getOidStatement(String pgTypeName) throws SQLException
       String lcName = pgTypeName.toLowerCase();
       // default arrays are represented with _ as prefix ... this dont even work for public schema
       // fully
-      _getOidStatementSimple.setString(1,
-          isArray ? "_" + lcName.substring(0, lcName.length() - 2) : lcName);
+      _getOidStatementSimple.setString(1, lcName);
       return _getOidStatementSimple;
     }
     PreparedStatement oidStatementComplex;
     if (isArray) {
       if (_getOidStatementComplexArray == null) {
-        String sql = "SELECT t.typarray "
+        String sql = "SELECT t.typarray, arr.typname "
             + "  FROM pg_catalog.pg_type t"
             + "  JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid"
-            + " WHERE t.typname = ? AND (n.nspname = ? OR ? IS NULL AND n.nspname = ANY (current_schemas(false)))"
-            + " ORDER BY t.oid DESC LIMIT 1;";
+            + "  JOIN pg_catalog.pg_type arr ON arr.oid = t.typarray"
+            + " WHERE t.typname = ? AND (n.nspname = ? OR ? IS NULL AND n.nspname = ANY (current_schemas(true)))"
+            + " ORDER BY t.oid DESC LIMIT 1";
         _getOidStatementComplexArray = _conn.prepareStatement(sql);
       }
       oidStatementComplex = _getOidStatementComplexArray;
     } else {
       if (_getOidStatementComplexNonArray == null) {
-        String sql = "SELECT t.oid "
+        String sql = "SELECT t.oid, t.typname "
             + "  FROM pg_catalog.pg_type t"
             + "  JOIN pg_catalog.pg_namespace n ON t.typnamespace = n.oid"
-            + " WHERE t.typname = ? AND (n.nspname = ? OR ? IS NULL AND n.nspname = ANY (current_schemas(false)))"
-            + " ORDER BY t.oid DESC LIMIT 1;";
+            + " WHERE t.typname = ? AND (n.nspname = ? OR ? IS NULL AND n.nspname = ANY (current_schemas(true)))"
+            + " ORDER BY t.oid DESC LIMIT 1";
         _getOidStatementComplexNonArray = _conn.prepareStatement(sql);
       }
       oidStatementComplex = _getOidStatementComplexNonArray;
@@ -374,7 +375,9 @@ public synchronized int getPGType(String pgTypeName) throws SQLException {
     ResultSet rs = oidStatement.getResultSet();
     if (rs.next()) {
       oid = (int) rs.getLong(1);
-      _oidToPgName.put(oid, pgTypeName);
+      String internalName = rs.getString(2);
+      _oidToPgName.put(oid, internalName);
+      _pgNameToOid.put(internalName, oid);
     }
     _pgNameToOid.put(pgTypeName, oid);
     rs.close();
@@ -849,6 +852,18 @@ public int getMaximumPrecision(int oid) {
 
   public boolean requiresQuoting(int oid) throws SQLException {
     int sqlType = getSQLType(oid);
+    return requiresQuotingSqlType(sqlType);
+  }
+
+  /**
+   * Returns true if particular sqlType requires quoting.
+   * This method is used internally by the driver, so it might disappear without notice.
+   *
+   * @param sqlType sql type as in java.sql.Types
+   * @return true if the type requires quoting
+   * @throws SQLException if something goes wrong
+   */
+  public boolean requiresQuotingSqlType(int sqlType) throws SQLException {
     switch (sqlType) {
       case Types.BIGINT:
       case Types.DOUBLE:
diff --git a/pgjdbc/src/main/java/org/postgresql/largeobject/LargeObject.java b/pgjdbc/src/main/java/org/postgresql/largeobject/LargeObject.java
index 35163208b1..d9ad7c18fb 100644
--- a/pgjdbc/src/main/java/org/postgresql/largeobject/LargeObject.java
+++ b/pgjdbc/src/main/java/org/postgresql/largeobject/LargeObject.java
@@ -92,7 +92,7 @@ protected LargeObject(Fastpath fp, long oid, int mode, BaseConnection conn, bool
     this.fp = fp;
     this.oid = oid;
     this.mode = mode;
-    if (commitOnClose == true) {
+    if (commitOnClose) {
       this.commitOnClose = true;
       this.conn = conn;
     } else {
@@ -175,7 +175,7 @@ public void close() throws SQLException {
       args[0] = new FastpathArg(fd);
       fp.fastpath("lo_close", args); // true here as we dont care!!
       closed = true;
-      if (this.commitOnClose == true) {
+      if (this.commitOnClose) {
         this.conn.commit();
       }
     }
diff --git a/pgjdbc/src/main/java/org/postgresql/largeobject/LargeObjectManager.java b/pgjdbc/src/main/java/org/postgresql/largeobject/LargeObjectManager.java
index c4d61454e9..62691411ba 100644
--- a/pgjdbc/src/main/java/org/postgresql/largeobject/LargeObjectManager.java
+++ b/pgjdbc/src/main/java/org/postgresql/largeobject/LargeObjectManager.java
@@ -143,7 +143,7 @@ public LargeObjectManager(BaseConnection conn) throws SQLException {
     Statement stmt = conn.createStatement();
     ResultSet res = stmt.executeQuery(sql);
 
-    if (res == null) {
+    if (res == null) { // NOSONAR
       throw new PSQLException(GT.tr("Failed to initialize LargeObject API"),
           PSQLState.SYSTEM_ERROR);
     }
diff --git a/pgjdbc/src/main/java/org/postgresql/ssl/jdbc4/LazyKeyManager.java b/pgjdbc/src/main/java/org/postgresql/ssl/jdbc4/LazyKeyManager.java
index e2367df7ef..c3611a2760 100644
--- a/pgjdbc/src/main/java/org/postgresql/ssl/jdbc4/LazyKeyManager.java
+++ b/pgjdbc/src/main/java/org/postgresql/ssl/jdbc4/LazyKeyManager.java
@@ -164,7 +164,7 @@ public PrivateKey getPrivateKey(String alias) {
         }
 
         try {
-          raf = new RandomAccessFile(new File(keyfile), "r");
+          raf = new RandomAccessFile(new File(keyfile), "r"); // NOSONAR
         } catch (FileNotFoundException ex) {
           if (!defaultfile) {
             // It is not an error if there is no file at the default location
diff --git a/pgjdbc/src/main/java/org/postgresql/ssl/jdbc4/LibPQFactory.java b/pgjdbc/src/main/java/org/postgresql/ssl/jdbc4/LibPQFactory.java
index 308bba181a..018c5ab284 100644
--- a/pgjdbc/src/main/java/org/postgresql/ssl/jdbc4/LibPQFactory.java
+++ b/pgjdbc/src/main/java/org/postgresql/ssl/jdbc4/LibPQFactory.java
@@ -20,7 +20,6 @@
 import java.security.cert.Certificate;
 import java.security.cert.CertificateFactory;
 import java.security.cert.X509Certificate;
-import java.util.Iterator;
 import java.util.Properties;
 
 import javax.naming.InvalidNameException;
@@ -117,7 +116,7 @@ public LibPQFactory(Properties info) throws PSQLException {
         }
         FileInputStream fis;
         try {
-          fis = new FileInputStream(sslrootcertfile);
+          fis = new FileInputStream(sslrootcertfile); // NOSONAR
         } catch (FileNotFoundException ex) {
           throw new PSQLException(
               GT.tr("Could not open SSL root certificate file {0}.", new Object[]{sslrootcertfile}),
@@ -128,7 +127,6 @@ public LibPQFactory(Properties info) throws PSQLException {
           // Certificate[] certs = cf.generateCertificates(fis).toArray(new Certificate[]{}); //Does
           // not work in java 1.4
           Object[] certs = cf.generateCertificates(fis).toArray(new Certificate[]{});
-          fis.close();
           ks.load(null, null);
           for (int i = 0; i < certs.length; i++) {
             ks.setCertificateEntry("cert" + i, (Certificate) certs[i]);
@@ -143,6 +141,12 @@ public LibPQFactory(Properties info) throws PSQLException {
               GT.tr("Loading the SSL root certificate {0} into a TrustManager failed.",
                   new Object[]{sslrootcertfile}),
               PSQLState.CONNECTION_FAILURE, gsex);
+        } finally {
+          try {
+            fis.close();
+          } catch (IOException e) {
+            /* ignore */
+          }
         }
         tm = tmf.getTrustManagers();
       } else { // server validation is not required
@@ -207,7 +211,7 @@ public void handle(Callback[] callbacks) throws IOException, UnsupportedCallback
             // It is used instead of cons.readPassword(prompt), because the prompt may contain '%'
             // characters
             ((PasswordCallback) callback).setPassword(
-                cons.readPassword("%s", new Object[]{((PasswordCallback) callback).getPrompt()}));
+                cons.readPassword("%s", ((PasswordCallback) callback).getPrompt()));
           } else {
             ((PasswordCallback) callback).setPassword(password);
           }
@@ -249,10 +253,7 @@ public boolean verify(String hostname, SSLSession session) {
       return false;
     }
     String CN = null;
-    Iterator<Rdn> it = DN.getRdns().iterator();
-    // for(Rdn rdn : DN.getRdns())
-    while (it.hasNext()) {
-      Rdn rdn = it.next();
+    for (Rdn rdn : DN.getRdns()) {
       if ("CN".equals(rdn.getType())) {
         // Multiple AVAs are not treated
         CN = (String) rdn.getValue();
diff --git a/pgjdbc/src/main/java/org/postgresql/sspi/ISSPIClient.java b/pgjdbc/src/main/java/org/postgresql/sspi/ISSPIClient.java
new file mode 100644
index 0000000000..608320b921
--- /dev/null
+++ b/pgjdbc/src/main/java/org/postgresql/sspi/ISSPIClient.java
@@ -0,0 +1,29 @@
+/*-------------------------------------------------------------------------
+*
+* Copyright (c) 2003-2016, PostgreSQL Global Development Group
+* Copyright (c) 2004, Open Cloud Limited.
+*
+*
+*-------------------------------------------------------------------------
+*/
+
+package org.postgresql.sspi;
+
+import java.io.IOException;
+import java.sql.SQLException;
+
+/**
+ * Use Waffle-JNI to support SSPI authentication when PgJDBC is running on a Windows
+ * client and talking to a Windows server.
+ *
+ * SSPI is not supported on a non-Windows client.
+ */
+public interface ISSPIClient {
+  boolean isSSPISupported();
+
+  void startSSPI() throws SQLException, IOException;
+
+  void continueSSPI(int msgLength) throws SQLException, IOException;
+
+  void dispose();
+}
diff --git a/pgjdbc/src/main/java/org/postgresql/sspi/SSPIClient.java b/pgjdbc/src/main/java/org/postgresql/sspi/SSPIClient.java
index a2b32d0514..b4999acb2d 100644
--- a/pgjdbc/src/main/java/org/postgresql/sspi/SSPIClient.java
+++ b/pgjdbc/src/main/java/org/postgresql/sspi/SSPIClient.java
@@ -1,3 +1,12 @@
+/*-------------------------------------------------------------------------
+*
+* Copyright (c) 2003-2016, PostgreSQL Global Development Group
+* Copyright (c) 2004, Open Cloud Limited.
+*
+*
+*-------------------------------------------------------------------------
+*/
+
 package org.postgresql.sspi;
 
 import org.postgresql.core.Logger;
@@ -26,7 +35,7 @@
  *
  * @author craig
  */
-public class SSPIClient {
+public class SSPIClient implements ISSPIClient {
 
   public static String SSPI_DEFAULT_SPN_SERVICE_CLASS = "POSTGRES";
 
@@ -59,7 +68,6 @@ public SSPIClient(PGStream pgStream, String spnServiceClass, boolean enableNegot
     this.pgStream = pgStream;
 
     /* If blank or unspecified, SPN service class should be POSTGRES */
-    String realServiceClass = spnServiceClass;
     if (spnServiceClass != null && spnServiceClass.isEmpty()) {
       spnServiceClass = null;
     }
@@ -161,7 +169,7 @@ public void startSSPI() throws SQLException, IOException {
 
         sspiContext = new WindowsSecurityContextImpl();
         sspiContext.setPrincipalName(targetName);
-        sspiContext.setCredentialsHandle(clientCredentials.getHandle());
+        sspiContext.setCredentialsHandle(clientCredentials);
         sspiContext.setSecurityPackage(securityPackage);
         sspiContext.initialize(null, null, targetName);
       } catch (Win32Exception ex) {
diff --git a/pgjdbc/src/main/java/org/postgresql/util/JdbcBlackHole.java b/pgjdbc/src/main/java/org/postgresql/util/JdbcBlackHole.java
new file mode 100644
index 0000000000..a9d9646229
--- /dev/null
+++ b/pgjdbc/src/main/java/org/postgresql/util/JdbcBlackHole.java
@@ -0,0 +1,38 @@
+package org.postgresql.util;
+
+import java.sql.Connection;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Statement;
+
+public class JdbcBlackHole {
+  public static void close(Connection con) {
+    try {
+      if (con != null) {
+        con.close();
+      }
+    } catch (SQLException e) {
+      /* ignore for now */
+    }
+  }
+
+  public static void close(Statement s) {
+    try {
+      if (s != null) {
+        s.close();
+      }
+    } catch (SQLException e) {
+      /* ignore for now */
+    }
+  }
+
+  public static void close(ResultSet rs) {
+    try {
+      if (rs != null) {
+        rs.close();
+      }
+    } catch (SQLException e) {
+      /* ignore for now */
+    }
+  }
+}
diff --git a/pgjdbc/src/main/java/org/postgresql/util/LruCache.java b/pgjdbc/src/main/java/org/postgresql/util/LruCache.java
index a6959e4fb7..603be5bf7f 100644
--- a/pgjdbc/src/main/java/org/postgresql/util/LruCache.java
+++ b/pgjdbc/src/main/java/org/postgresql/util/LruCache.java
@@ -40,8 +40,13 @@ public interface CreateAction<Key, Value> {
   private final int maxSizeEntries;
   private final long maxSizeBytes;
   private long currentSize;
+  private final Map<Key, Value> cache;
+
+  private class LimitedMap extends LinkedHashMap<Key, Value> {
+    LimitedMap(int initialCapacity, float loadFactor, boolean accessOrder) {
+      super(initialCapacity, loadFactor, accessOrder);
+    }
 
-  private final Map<Key, Value> cache = new LinkedHashMap<Key, Value>() {
     @Override
     protected boolean removeEldestEntry(Map.Entry<Key, Value> eldest) {
       // Avoid creating iterators if size constraints not violated
@@ -66,7 +71,7 @@ protected boolean removeEldestEntry(Map.Entry<Key, Value> eldest) {
       }
       return false;
     }
-  };
+  }
 
   private void evictValue(Value value) {
     try {
@@ -76,12 +81,28 @@ private void evictValue(Value value) {
     }
   }
 
-  public LruCache(int maxSizeEntries, long maxSizeBytes, CreateAction<Key, Value> createAction,
+  public LruCache(int maxSizeEntries, long maxSizeBytes, boolean accessOrder) {
+    this(maxSizeEntries, maxSizeBytes, accessOrder, NOOP_CREATE_ACTION, NOOP_EVICT_ACTION);
+  }
+
+  public LruCache(int maxSizeEntries, long maxSizeBytes, boolean accessOrder,
+      CreateAction<Key, Value> createAction,
       EvictAction<Value> onEvict) {
     this.maxSizeEntries = maxSizeEntries;
     this.maxSizeBytes = maxSizeBytes;
     this.createAction = createAction;
     this.onEvict = onEvict;
+    this.cache = new LimitedMap(16, 0.75f, accessOrder);
+  }
+
+  /**
+   * Returns an entry from the cache.
+   *
+   * @param key cache key
+   * @return entry from cache or null if cache does not contain given key.
+   */
+  public synchronized Value get(Key key) {
+    return cache.get(key);
   }
 
   /**
@@ -91,7 +112,7 @@ public LruCache(int maxSizeEntries, long maxSizeBytes, CreateAction<Key, Value>
    * @return entry from cache or newly created entry if cache does not contain given key.
    * @throws SQLException if entry creation fails
    */
-  public Value borrow(Key key) throws SQLException {
+  public synchronized Value borrow(Key key) throws SQLException {
     Value value = cache.remove(key);
     if (value == null) {
       return createAction.create(key);
@@ -106,7 +127,7 @@ public Value borrow(Key key) throws SQLException {
    * @param key key
    * @param value value
    */
-  public void put(Key key, Value value) {
+  public synchronized void put(Key key, Value value) {
     long valueSize = value.getSize();
     if (maxSizeBytes == 0 || maxSizeEntries == 0 || valueSize * 2 > maxSizeBytes) {
       // Just destroy the value if cache is disabled or if entry would consume more than a half of
@@ -117,4 +138,18 @@ public void put(Key key, Value value) {
     currentSize += valueSize;
     cache.put(key, value);
   }
+
+  public final static CreateAction NOOP_CREATE_ACTION = new CreateAction() {
+    @Override
+    public Object create(Object o) throws SQLException {
+      return null;
+    }
+  };
+
+  public final static EvictAction NOOP_EVICT_ACTION = new EvictAction() {
+    @Override
+    public void evict(Object o) throws SQLException {
+      return;
+    }
+  };
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/util/ObjectFactory.java b/pgjdbc/src/main/java/org/postgresql/util/ObjectFactory.java
index fff258f7d6..03e750d386 100644
--- a/pgjdbc/src/main/java/org/postgresql/util/ObjectFactory.java
+++ b/pgjdbc/src/main/java/org/postgresql/util/ObjectFactory.java
@@ -34,15 +34,14 @@ public static Object instantiate(String classname, Properties info, boolean tryS
           IllegalArgumentException, InstantiationException, IllegalAccessException,
           InvocationTargetException {
     Object[] args = {info};
-    Constructor ctor = null;
-    Class cls;
-    cls = Class.forName(classname);
+    Constructor<?> ctor = null;
+    Class<?> cls = Class.forName(classname);
     try {
-      ctor = cls.getConstructor(new Class[]{Properties.class});
+      ctor = cls.getConstructor(Properties.class);
     } catch (NoSuchMethodException nsme) {
       if (tryString) {
         try {
-          ctor = cls.getConstructor(new Class[]{String.class});
+          ctor = cls.getConstructor(String.class);
           args = new String[]{stringarg};
         } catch (NoSuchMethodException nsme2) {
           tryString = false;
diff --git a/pgjdbc/src/main/java/org/postgresql/util/PGBinaryObject.java b/pgjdbc/src/main/java/org/postgresql/util/PGBinaryObject.java
index 10a0ff13e2..7070f643d5 100644
--- a/pgjdbc/src/main/java/org/postgresql/util/PGBinaryObject.java
+++ b/pgjdbc/src/main/java/org/postgresql/util/PGBinaryObject.java
@@ -22,7 +22,7 @@ public interface PGBinaryObject {
    * @param offset the offset in the byte array where object data starts
    * @throws SQLException thrown if value is invalid for this type
    */
-  public void setByteValue(byte[] value, int offset) throws SQLException;
+  void setByteValue(byte[] value, int offset) throws SQLException;
 
   /**
    * This method is called to return the number of bytes needed to store this object in the binary
@@ -30,7 +30,7 @@ public interface PGBinaryObject {
    *
    * @return the number of bytes needed to store this object
    */
-  public int lengthInBytes();
+  int lengthInBytes();
 
   /**
    * This method is called the to store the value of the object, in the binary form required by
@@ -40,5 +40,5 @@ public interface PGBinaryObject {
    *        {@link #lengthInBytes} in size.
    * @param offset the offset in the byte array where object must be stored
    */
-  public void toBytes(byte[] bytes, int offset);
+  void toBytes(byte[] bytes, int offset);
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/util/PGInterval.java b/pgjdbc/src/main/java/org/postgresql/util/PGInterval.java
index 85a47908b6..9f21969e9d 100644
--- a/pgjdbc/src/main/java/org/postgresql/util/PGInterval.java
+++ b/pgjdbc/src/main/java/org/postgresql/util/PGInterval.java
@@ -428,4 +428,10 @@ public int hashCode() {
     return ((((((7 * 31 + (int) Double.doubleToLongBits(seconds)) * 31 + minutes) * 31 + hours) * 31
         + days) * 31 + months) * 31 + years) * 31;
   }
+
+  @Override
+  public Object clone() throws CloneNotSupportedException {
+    // squid:S2157 "Cloneables" should implement "clone
+    return super.clone();
+  }
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/util/PGbytea.java b/pgjdbc/src/main/java/org/postgresql/util/PGbytea.java
index 1412104f27..02ae1c64be 100644
--- a/pgjdbc/src/main/java/org/postgresql/util/PGbytea.java
+++ b/pgjdbc/src/main/java/org/postgresql/util/PGbytea.java
@@ -40,7 +40,9 @@ private static byte[] toBytesHexEscaped(byte[] s) {
     for (int i = 0; i < output.length; i++) {
       byte b1 = gethex(s[2 + i * 2]);
       byte b2 = gethex(s[2 + i * 2 + 1]);
-      output[i] = (byte) ((b1 << 4) | b2);
+      // squid:S3034
+      // Raw byte values should not be used in bitwise operations in combination with shifts
+      output[i] = (byte) ((b1 << 4) | (b2 & 0xff));
     }
     return output;
   }
diff --git a/pgjdbc/src/main/java/org/postgresql/util/PGmoney.java b/pgjdbc/src/main/java/org/postgresql/util/PGmoney.java
index f41bd854ec..4d199e01ab 100644
--- a/pgjdbc/src/main/java/org/postgresql/util/PGmoney.java
+++ b/pgjdbc/src/main/java/org/postgresql/util/PGmoney.java
@@ -92,4 +92,10 @@ public String getValue() {
       return "$" + val;
     }
   }
+
+  @Override
+  public Object clone() throws CloneNotSupportedException {
+    // squid:S2157 "Cloneables" should implement "clone
+    return super.clone();
+  }
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/util/PGtokenizer.java b/pgjdbc/src/main/java/org/postgresql/util/PGtokenizer.java
index 27ef42df56..326f3a61d6 100644
--- a/pgjdbc/src/main/java/org/postgresql/util/PGtokenizer.java
+++ b/pgjdbc/src/main/java/org/postgresql/util/PGtokenizer.java
@@ -84,11 +84,7 @@ public int tokenize(String string, char delim) {
         }
       }
 
-      if (c == '\\') {
-        skipChar = true;
-      } else {
-        skipChar = false;
-      }
+      skipChar = c == '\\';
 
       if (nest == 0 && c == delim) {
         tokens.add(string.substring(s, p));
diff --git a/pgjdbc/src/main/java/org/postgresql/util/PSQLState.java b/pgjdbc/src/main/java/org/postgresql/util/PSQLState.java
index 21bfc823af..3b40229255 100644
--- a/pgjdbc/src/main/java/org/postgresql/util/PSQLState.java
+++ b/pgjdbc/src/main/java/org/postgresql/util/PSQLState.java
@@ -91,6 +91,7 @@ public int hashCode() {
   public final static PSQLState TRANSACTION_STATE_INVALID = new PSQLState("25000");
   public final static PSQLState ACTIVE_SQL_TRANSACTION = new PSQLState("25001");
   public final static PSQLState NO_ACTIVE_SQL_TRANSACTION = new PSQLState("25P01");
+  public final static PSQLState INVALID_AUTHORIZATION_SPECIFICATION = new PSQLState("28000");
 
   public final static PSQLState STATEMENT_NOT_ALLOWED_IN_FUNCTION_CALL = new PSQLState("2F003");
 
diff --git a/pgjdbc/src/main/java/org/postgresql/util/UnixCrypt.java b/pgjdbc/src/main/java/org/postgresql/util/UnixCrypt.java
index 5d2d7b0f94..74874c66cb 100644
--- a/pgjdbc/src/main/java/org/postgresql/util/UnixCrypt.java
+++ b/pgjdbc/src/main/java/org/postgresql/util/UnixCrypt.java
@@ -23,9 +23,6 @@ public class UnixCrypt extends Object {
   private UnixCrypt() {
   }
 
-  private static final char[] saltChars =
-      ("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./".toCharArray());
-
   private static final int ITERATIONS = 16;
 
   private static final int con_salt[] = {
diff --git a/pgjdbc/src/test/java/org/postgresql/core/v2/V2ParameterListTests.java b/pgjdbc/src/test/java/org/postgresql/core/v2/V2ParameterListTests.java
new file mode 100644
index 0000000000..aab2c9c7a4
--- /dev/null
+++ b/pgjdbc/src/test/java/org/postgresql/core/v2/V2ParameterListTests.java
@@ -0,0 +1,51 @@
+/*-------------------------------------------------------------------------
+ *
+ * Copyright (c) 2003-2016, PostgreSQL Global Development Group
+ *
+ *
+ *-------------------------------------------------------------------------
+ */
+
+package org.postgresql.core.v2;
+
+import org.postgresql.test.jdbc2.BaseTest;
+
+import java.sql.SQLException;
+
+/**
+ * Test cases to make sure the parameterlist implementation works as expected.
+ *
+ * @author Jeremy Whiting jwhiting@redhat.com
+ *
+ */
+public class V2ParameterListTests extends BaseTest {
+
+  /**
+   * Test to check the merging of two parameter lists.
+   *
+   * @throws SQLException fault raised when setting parameter
+   */
+  public void testMergeOfParameterLists() throws SQLException {
+    SimpleParameterList o1SPL = new SimpleParameterList(8, Boolean.TRUE);
+    o1SPL.setIntParameter(1, 1);
+    o1SPL.setIntParameter(2, 2);
+    o1SPL.setIntParameter(3, 3);
+    o1SPL.setIntParameter(4, 4);
+
+    SimpleParameterList s2SPL = new SimpleParameterList(4, Boolean.TRUE);
+    s2SPL.setIntParameter(1, 5);
+    s2SPL.setIntParameter(2, 6);
+    s2SPL.setIntParameter(3, 7);
+    s2SPL.setIntParameter(4, 8);
+
+    o1SPL.appendAll(s2SPL);
+
+    assertEquals(
+        "Expected string representation of parameter list does not match product.",
+        "<[1 ,2 ,3 ,4 ,5 ,6 ,7 ,8]>", o1SPL.toString());
+  }
+
+  public V2ParameterListTests(String test) {
+    super(test);
+  }
+}
diff --git a/pgjdbc/src/test/java/org/postgresql/core/v3/V3ParameterListTests.java b/pgjdbc/src/test/java/org/postgresql/core/v3/V3ParameterListTests.java
new file mode 100644
index 0000000000..056f88b702
--- /dev/null
+++ b/pgjdbc/src/test/java/org/postgresql/core/v3/V3ParameterListTests.java
@@ -0,0 +1,73 @@
+/*-------------------------------------------------------------------------
+ *
+ * Copyright (c) 2003-2016, PostgreSQL Global Development Group
+ *
+ *
+ *-------------------------------------------------------------------------
+ */
+
+package org.postgresql.core.v3;
+
+import org.postgresql.core.Logger;
+import org.postgresql.core.PGStream;
+import org.postgresql.core.v2.SocketFactoryFactory;
+import org.postgresql.test.TestUtil;
+import org.postgresql.test.jdbc2.BaseTest;
+import org.postgresql.util.HostSpec;
+
+import org.junit.Before;
+
+import java.sql.SQLException;
+import java.util.Properties;
+
+import javax.net.SocketFactory;
+
+/**
+ * Test cases to make sure the parameterlist implementation works as expected.
+ *
+ * @author Jeremy Whiting jwhiting@redhat.com
+ *
+ */
+public class V3ParameterListTests extends BaseTest {
+
+  /**
+   * Test to check the merging of two collections of parameters. All elements
+   * are kept.
+   *
+   * @throws SQLException
+   *           raised exception if setting parameter fails.
+   */
+  public void testMergeOfParameterLists() throws SQLException {
+    SimpleParameterList s1SPL = new SimpleParameterList(8, pci);
+    s1SPL.setIntParameter(1, 1);
+    s1SPL.setIntParameter(2, 2);
+    s1SPL.setIntParameter(3, 3);
+    s1SPL.setIntParameter(4, 4);
+
+    SimpleParameterList s2SPL = new SimpleParameterList(4, pci);
+    s2SPL.setIntParameter(1, 5);
+    s2SPL.setIntParameter(2, 6);
+    s2SPL.setIntParameter(3, 7);
+    s2SPL.setIntParameter(4, 8);
+
+    s1SPL.appendAll(s2SPL);
+    assertEquals(
+        "Expected string representation of values does not match outcome.",
+        "<[1 ,2 ,3 ,4 ,5 ,6 ,7 ,8]>", s1SPL.toString());
+  }
+
+  public V3ParameterListTests(String test) {
+    super(test);
+  }
+
+  private ProtocolConnectionImpl pci;
+
+  @Override
+  @Before
+  protected void setUp() throws Exception {
+    SocketFactory socketFactory = SocketFactoryFactory.getSocketFactory(System.getProperties());
+    HostSpec hostSpec = new HostSpec(TestUtil.getServer(), TestUtil.getPort());
+    pci = new ProtocolConnectionImpl(new PGStream(socketFactory, hostSpec), "",
+        "", new Properties(), new Logger(), 5000);
+  }
+}
diff --git a/pgjdbc/src/test/java/org/postgresql/jdbc/DeepBatchedInsertStatementTest.java b/pgjdbc/src/test/java/org/postgresql/jdbc/DeepBatchedInsertStatementTest.java
new file mode 100644
index 0000000000..07db991ab0
--- /dev/null
+++ b/pgjdbc/src/test/java/org/postgresql/jdbc/DeepBatchedInsertStatementTest.java
@@ -0,0 +1,319 @@
+/*-------------------------------------------------------------------------
+ *
+ * Copyright (c) 2003-2016, PostgreSQL Global Development Group
+ *
+ *
+ *-------------------------------------------------------------------------
+ */
+
+package org.postgresql.jdbc;
+
+import org.postgresql.PGProperty;
+import org.postgresql.core.ParameterList;
+import org.postgresql.core.Query;
+import org.postgresql.core.v3.BatchedQuery;
+import org.postgresql.test.TestUtil;
+import org.postgresql.test.jdbc2.BaseTest;
+import org.postgresql.test.jdbc2.BatchExecuteTest;
+
+import java.lang.reflect.Method;
+import java.sql.Date;
+import java.sql.SQLException;
+import java.sql.Statement;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Properties;
+
+/**
+ * This object tests the internals of the BatchedStatementDecorator during
+ * execution. Rather than rely on testing at the jdbc api layer.
+ * on.
+ */
+public class DeepBatchedInsertStatementTest extends BaseTest {
+  public DeepBatchedInsertStatementTest(String name) {
+    super(name);
+  }
+
+  /*
+   * Set up the fixture for this testcase: a connection to a database with a
+   * table for this test.
+   */
+  protected void setUp() throws Exception {
+    super.setUp();
+    Statement stmt = con.createStatement();
+
+    /*
+     * Drop the test table if it already exists for some reason. It is not an
+     * error if it doesn't exist.
+     */
+    TestUtil.createTable(con, "testbatch", "pk INTEGER, col1 INTEGER");
+    TestUtil.createTable(con, "testunspecified", "pk INTEGER, bday TIMESTAMP");
+
+    stmt.executeUpdate("INSERT INTO testbatch VALUES (1, 0)");
+    stmt.close();
+
+    /*
+     * Generally recommended with batch updates. By default we run all tests in
+     * this test case with autoCommit disabled.
+     */
+    con.setAutoCommit(false);
+  }
+
+  // Tear down the fixture for this test case.
+  protected void tearDown() throws SQLException {
+    TestUtil.dropTable(con, "testbatch");
+    TestUtil.dropTable(con, "testunspecified");
+    super.tearDown();
+  }
+
+  @Override
+  protected void updateProperties(Properties props) {
+    PGProperty.REWRITE_BATCHED_INSERTS.set(props, true);
+    forceBinary(props);
+  }
+
+  public void testDeepInternalsBatchedQueryDecorator() throws Exception {
+    PgPreparedStatement pstmt = null;
+    try {
+      pstmt = (PgPreparedStatement) con.prepareStatement("INSERT INTO testbatch VALUES (?,?)");
+
+      pstmt.setInt(1, 1);
+      pstmt.setInt(2, 2);
+      pstmt.addBatch(); // initial pass
+      pstmt.setInt(1, 3);
+      pstmt.setInt(2, 4);
+      pstmt.addBatch();// preparedQuery should be wrapped
+
+      BatchedQuery[] bqds;
+      bqds = transformBQD(pstmt);
+      assertEquals(2, getBatchSize(bqds));
+
+      pstmt.setInt(1, 5);
+      pstmt.setInt(2, 6);
+      pstmt.addBatch();
+
+      bqds = transformBQD(pstmt);
+      assertEquals(3, getBatchSize(bqds));
+
+      BatchExecuteTest.assertSimpleInsertBatch(3, pstmt.executeBatch());
+      bqds = transformBQD(pstmt);
+
+      assertEquals(0, getBatchSize(bqds));
+
+      pstmt.setInt(1, 1);
+      pstmt.setInt(2, 2);
+      pstmt.addBatch();
+
+      bqds = transformBQD(pstmt);
+      assertEquals(1, getBatchSize(bqds));
+
+      pstmt.setInt(1, 3);
+      pstmt.setInt(2, 4);
+      pstmt.addBatch();
+      bqds = transformBQD(pstmt);
+      assertEquals(2, getBatchSize(bqds));
+
+      pstmt.setInt(1, 5);
+      pstmt.setInt(2, 6);
+      pstmt.addBatch();
+      bqds = transformBQD(pstmt);
+      assertEquals(3, getBatchSize(bqds));
+
+      BatchExecuteTest.assertSimpleInsertBatch(3, pstmt.executeBatch());
+      assertTrue("Expected encoded name is not matched.", Arrays.equals( "S_2".getBytes(),
+          getEncodedStatementName(bqds[0])));
+
+      pstmt.setInt(1, 1);
+      pstmt.setInt(2, 2);
+      pstmt.addBatch();
+      bqds = transformBQD(pstmt);
+      assertEquals(1, getBatchSize(bqds));
+      pstmt.setInt(1, 3);
+      pstmt.setInt(2, 4);
+      pstmt.addBatch();
+      bqds = transformBQD(pstmt);
+      assertEquals(2, getBatchSize(bqds));
+
+      pstmt.setInt(1, 5);
+      pstmt.setInt(2, 6);
+      pstmt.addBatch();
+      bqds = transformBQD(pstmt);
+      assertEquals(3, getBatchSize(bqds));
+
+      pstmt.setInt(1, 7);
+      pstmt.setInt(2, 8);
+      pstmt.addBatch();
+      bqds = transformBQD(pstmt);
+      assertEquals(4, getBatchSize(bqds));
+
+      BatchExecuteTest.assertSimpleInsertBatch(4, pstmt.executeBatch());
+
+      pstmt.setInt(1, 1);
+      pstmt.setInt(2, 2);
+      pstmt.addBatch();
+      bqds = transformBQD(pstmt);
+      assertEquals(1, getBatchSize(bqds));
+      pstmt.setInt(1, 3);
+      pstmt.setInt(2, 4);
+      pstmt.addBatch();
+      bqds = transformBQD(pstmt);
+      assertEquals(2, getBatchSize(bqds));
+
+      pstmt.setInt(1, 5);
+      pstmt.setInt(2, 6);
+      pstmt.addBatch();
+      bqds = transformBQD(pstmt);
+      assertEquals(3, getBatchSize(bqds));
+
+      BatchExecuteTest.assertSimpleInsertBatch(3, pstmt.executeBatch());
+
+      pstmt.setInt(1, 1);
+      pstmt.setInt(2, 2);
+      pstmt.addBatch();
+      bqds = transformBQD(pstmt);
+      assertEquals(1, getBatchSize(bqds));
+      pstmt.setInt(1, 3);
+      pstmt.setInt(2, 4);
+      pstmt.addBatch();
+      bqds = transformBQD(pstmt);
+      assertEquals(2, getBatchSize(bqds));
+
+      pstmt.setInt(1, 5);
+      pstmt.setInt(2, 6);
+      pstmt.addBatch();
+      bqds = transformBQD(pstmt);
+      assertEquals(3, getBatchSize(bqds));
+
+      BatchExecuteTest.assertSimpleInsertBatch(3, pstmt.executeBatch());
+
+      pstmt.setInt(1, 1);
+      pstmt.setInt(2, 2);
+      pstmt.addBatch();
+      bqds = transformBQD(pstmt);
+      assertEquals(1, getBatchSize(bqds));
+      pstmt.setInt(1, 3);
+      pstmt.setInt(2, 4);
+      pstmt.addBatch();
+      bqds = transformBQD(pstmt);
+      assertEquals(2, getBatchSize(bqds));
+
+      BatchExecuteTest.assertSimpleInsertBatch(2, pstmt.executeBatch());
+    } finally {
+      TestUtil.closeQuietly(pstmt);
+    }
+  }
+
+  /**
+   *
+   */
+  public void testUnspecifiedParameterType() throws Exception {
+    PgPreparedStatement pstmt = null;
+    try {
+      pstmt = (PgPreparedStatement) con
+          .prepareStatement("INSERT INTO testunspecified VALUES (?,?)");
+
+      pstmt.setInt(1, 1);
+      pstmt.setDate(2, new Date(1));
+      pstmt.addBatch();
+
+      pstmt.setInt(1, 2);
+      pstmt.setDate(2, new Date(2));
+      pstmt.addBatch();
+
+      BatchExecuteTest.assertSimpleInsertBatch(2, pstmt.executeBatch());
+
+      pstmt.setInt(1, 1);
+      pstmt.setDate(2, new Date(3));
+      pstmt.addBatch();
+      pstmt.setInt(1, 2);
+      pstmt.setDate(2, new Date(4));
+      pstmt.addBatch();
+
+      BatchExecuteTest.assertSimpleInsertBatch(2, pstmt.executeBatch());
+    } finally {
+      TestUtil.closeQuietly(pstmt);
+    }
+  }
+
+  /**
+   * Test to check the statement can provide the necessary number of prepared
+   * type fields. This is after running with a batch size of 1.
+   */
+  public void testVaryingTypeCounts() throws SQLException {
+    PgPreparedStatement pstmt = null;
+    try {
+      pstmt = (PgPreparedStatement)con.prepareStatement("INSERT INTO testunspecified VALUES (?,?)");
+      pstmt.setInt(1, 1);
+      pstmt.setDate(2, new Date(1));
+      pstmt.addBatch();
+
+      BatchExecuteTest.assertSimpleInsertBatch(1, pstmt.executeBatch());
+      pstmt.setInt(1, 1);
+      pstmt.setDate(2, new Date(2));
+      pstmt.addBatch();
+      pstmt.setInt(1, 2);
+      pstmt.setDate(2, new Date(3));
+      pstmt.addBatch();
+
+      pstmt.setInt(1, 3);
+      pstmt.setDate(2, new Date(4));
+      pstmt.addBatch();
+      pstmt.setInt(1, 4);
+      pstmt.setDate(2, new Date(5));
+      pstmt.addBatch();
+
+      BatchExecuteTest.assertSimpleInsertBatch(4, pstmt.executeBatch());
+    } finally {
+      TestUtil.closeQuietly(pstmt);
+    }
+  }
+
+  /**
+   * This method triggers the transformation of single batches to multi batches.
+   *
+   * @param ps PgPreparedStatement statement that will contain the field
+   * @return BatchedQueryDecorator[] queries after conversion
+   * @throws Exception fault raised when the field cannot be accessed
+   */
+  private BatchedQuery[] transformBQD(PgPreparedStatement ps) throws Exception {
+    // We store collections that get replace on the statement
+    ArrayList<Query> batchStatements = ps.batchStatements;
+    ArrayList<ParameterList> batchParameters = ps.batchParameters;
+    ps.transformQueriesAndParameters();
+    BatchedQuery[] bqds = ps.batchStatements.toArray(new BatchedQuery[0]);
+    // Restore collections on the statement.
+    ps.batchStatements = batchStatements;
+    ps.batchParameters = batchParameters;
+    return bqds;
+  }
+
+  /**
+   * Get the total batch size of multi batches.
+   *
+   * @param bqds the converted queries
+   * @return the total batch size
+   */
+  private int getBatchSize(BatchedQuery[] bqds) {
+    int total = 0;
+    for (BatchedQuery bqd : bqds) {
+      total += bqd.getBatchSize();
+    }
+    return total;
+  }
+
+  /**
+   * Access the encoded statement name field.
+   * Again using reflection to gain access to a private field member
+   * @param bqd BatchedQueryDecorator object on which field is present
+   * @return byte[] array of bytes that represent the statement name
+   * when encoded
+   * @throws Exception fault raised if access to field not possible
+   */
+  private byte[] getEncodedStatementName(BatchedQuery bqd)
+      throws Exception {
+    Class<?> clazz = Class.forName("org.postgresql.core.v3.SimpleQuery");
+    Method mESN = clazz.getDeclaredMethod("getEncodedStatementName");
+    mESN.setAccessible(true);
+    return (byte[]) mESN.invoke(bqd);
+  }
+}
diff --git a/pgjdbc/src/test/java/org/postgresql/jdbc/InsertRewriteWithAlternatingTypesIssue584.java b/pgjdbc/src/test/java/org/postgresql/jdbc/InsertRewriteWithAlternatingTypesIssue584.java
new file mode 100644
index 0000000000..3d66efeca8
--- /dev/null
+++ b/pgjdbc/src/test/java/org/postgresql/jdbc/InsertRewriteWithAlternatingTypesIssue584.java
@@ -0,0 +1,368 @@
+package org.postgresql.jdbc;
+
+import org.postgresql.PGProperty;
+import org.postgresql.core.CachedQuery;
+import org.postgresql.core.ParameterList;
+import org.postgresql.core.Query;
+import org.postgresql.core.v3.BatchedQuery;
+import org.postgresql.test.TestUtil;
+import org.postgresql.test.jdbc2.BaseTest4;
+
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.lang.reflect.Field;
+import java.sql.Connection;
+import java.sql.SQLException;
+import java.sql.Timestamp;
+import java.sql.Types;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Properties;
+
+/**
+ * Prepared statements are, by nature, prepared. This test makes sure that new preparation sequences
+ * are not incorrectly triggered.
+ *
+ * @author Christopher Deckers (chrriis@gmail.com)
+ *
+ */
+@RunWith(Parameterized.class)
+public class InsertRewriteWithAlternatingTypesIssue584 extends BaseTest4 {
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    TestUtil.createTable(con, "BugFreezeTable",
+        "Col1      INTEGER             NOT NULL,"
+            + "Col2      DATE                NOT NULL,"
+            + "Col3      DOUBLE PRECISION        NULL,"
+            + "Col4      SMALLINT            NOT NULL,"
+            + "Col5      NUMERIC (10)            NULL,"
+            + "Col6      DATE                    NULL,"
+            + "Col7      NUMERIC (10)        NOT NULL,"
+            + "Col8      NUMERIC (10)            NULL");
+  }
+
+  @Override
+  public void tearDown() throws SQLException {
+    TestUtil.dropTable(con, "BugFreezeTable");
+    super.tearDown();
+  }
+
+  @Override
+  protected void updateProperties(Properties props) {
+    super.updateProperties(props);
+    PGProperty.REWRITE_BATCHED_INSERTS.set(props, insertRewrite);
+  }
+
+  private boolean insertRewrite;
+
+  public InsertRewriteWithAlternatingTypesIssue584(boolean insertRewrite) {
+    this.insertRewrite = insertRewrite;
+  }
+
+  @Parameterized.Parameters(name = "insertRewrite = {0}")
+  public static Iterable<Object[]> data() {
+    Collection<Object[]> ids = new ArrayList<Object[]>();
+    for (boolean insertRewrite : new boolean[]{false, true}) {
+      ids.add(new Object[]{insertRewrite});
+    }
+    return ids;
+  }
+
+  @Test
+  public void testPreparedStatementPreparation() throws Throwable {
+    Connection conn = con;
+    conn.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);
+    try {
+      Timestamp ts = new Timestamp(2016 - 1900, 0, 31, 0, 0, 0, 0);
+      int[] types = new int[]{
+          Types.NUMERIC,
+          Types.DATE,
+          Types.DOUBLE,
+          Types.SMALLINT,
+          Types.NUMERIC,
+          Types.DATE,
+          Types.NUMERIC,
+          Types.NUMERIC,
+      };
+      Object[] row0 = new Object[]{1, ts, 0.0, true, 0.0, null, 0.0, null};
+      Object[] row1 = new Object[]{1, ts, 0.0, true, null, ts, 0.0, null};
+      Object[] row2 = new Object[]{1, ts, 0.0, true, 0.0, ts, 0.0, 0.0};
+      Object[] row3 = new Object[]{1, ts, 0.0, true, null, ts, 0.0, 0.0};
+      Object[][] tRows = new Object[][]{row0, row1, row2, row3};
+      List<Object[]> rowList = new ArrayList<Object[]>();
+      for (int ROW_INDEX : ROW_INDEXES) {
+        rowList.add(tRows[ROW_INDEX]);
+      }
+
+      StringBuilder sb = new StringBuilder();
+      sb.append(
+          "INSERT INTO BugFreezeTable (Col1,Col2,Col3,Col4,Col5,Col6,Col7,Col8) VALUES (?,?,?,?,?,?,?,?)");
+      String insert = sb.toString();
+      PgPreparedStatement pst = (PgPreparedStatement) conn.prepareStatement(insert);
+      String statementName;
+      int count = 0;
+      do {
+        Object[][] rows = rowList.toArray(new Object[0][]);
+        for (Object[] row : rows) {
+          for (int k = 0; k < row.length; k++) {
+            Object o = row[k];
+            int paramIndex = k + 1;
+            int sqlType = types[k];
+            if (o == null) {
+              pst.setNull(paramIndex, sqlType);
+            } else {
+              pst.setObject(paramIndex, o, sqlType);
+            }
+          }
+          pst.addBatch();
+        }
+        statementName = getStatementName(pst);
+        pst.executeBatch();
+      } while (statementName == null && ++count < 10);
+      Assert.assertEquals("S_1", statementName);
+    } catch (SQLException e) {
+      e.printStackTrace();
+      SQLException nextException = e.getNextException();
+      if (nextException != null) {
+        System.err.println("Next Exception:");
+        nextException.printStackTrace();
+      }
+      throw e;
+    }
+  }
+
+  private String getStatementName(PgPreparedStatement pst) throws Exception {
+    Query query;
+    BatchedQuery[] bqds = transformBQD(pst);
+    if (bqds == null) {
+      Field preparedQueryField = Class.forName("org.postgresql.jdbc.PgPreparedStatement")
+          .getDeclaredField("preparedQuery");
+      preparedQueryField.setAccessible(true);
+      CachedQuery preparedQuery = (CachedQuery) preparedQueryField.get(pst);
+      query = preparedQuery.query;
+    } else {
+      query = bqds[0];
+    }
+    Field statementNameField =
+        Class.forName("org.postgresql.core.v3.SimpleQuery").getDeclaredField("statementName");
+    statementNameField.setAccessible(true);
+    return (String) statementNameField.get(query);
+  }
+
+  /**
+   * This method triggers the transformation of single batches to multi batches.
+   *
+   * @param ps PgPreparedStatement statement that will contain the field
+   * @return BatchedQueryDecorator[] queries after conversion
+   * @throws Exception fault raised when the field cannot be accessed
+   */
+  private BatchedQuery[] transformBQD(PgPreparedStatement ps) throws Exception {
+    // We store collections that get replace on the statement
+    ArrayList<Query> batchStatements = ps.batchStatements;
+    if (!(ps.batchStatements.get(0) instanceof BatchedQuery)) {
+      // Not in rewrite mode.
+      return null;
+    }
+    ArrayList<ParameterList> batchParameters = ps.batchParameters;
+    ps.transformQueriesAndParameters();
+    BatchedQuery[] bqds = ps.batchStatements.toArray(new BatchedQuery[0]);
+    // Restore collections on the statement.
+    ps.batchStatements = batchStatements;
+    ps.batchParameters = batchParameters;
+    return bqds;
+  }
+
+  private static final int[] ROW_INDEXES = new int[]{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
+      3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,
+      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 2, 2, 2, 2, 2, 2,
+      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+      2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2,
+      2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 0, 2, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 3, 3, 3, 1, 1, 1, 1, 1, 3, 1, 3, 3, 3, 3, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2,
+      2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2,
+      2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 2,
+      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2,
+      2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2,
+      2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+      3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+      2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+      2, 2, 2, 2, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+      3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+      3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+      3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+      3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,
+      3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+      3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2,
+      2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 3, 2,
+      2, 3, 1, 0, 3, 2, 2, 3, 0, 1, 3, 2, 2, 2, 3, 3, 3, 0, 1, 2, 2, 3, 3, 2, 2, 2, 2, 2, 2, 2, 3,
+      3, 3, 3, 3, 3, 3, 2, 3, 3, 2, 2, 2, 3, 3, 0, 3, 3, 1, 2, 1, 2, 1, 1, 2, 1, 0, 3, 2, 0, 1, 1,
+      2, 1, 2, 0, 3, 0, 1, 1, 0, 1, 0, 1, 0, 1, 3, 1, 2, 1, 2, 1, 2, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0,
+      0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 2, 1, 2, 3, 2, 0, 3, 1, 0, 3, 2, 0, 1, 1, 0, 1, 0, 0,
+      0, 0, 0, 0, 1, 0, 0, 0, 2, 2, 0, 1, 0, 1, 0, 1, 1, 2, 3, 2, 1, 2, 1, 2, 0, 3, 0, 3, 0, 3, 0,
+      3, 1, 2, 0, 1, 1, 0, 1, 2, 1, 2, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1,
+      0, 1, 1, 2, 1, 0, 1, 3, 2, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 0, 2, 2, 3, 3, 2, 2,
+      3, 3, 2, 2, 3, 3, 2, 3, 2, 2, 2, 2, 3, 3, 3, 3, 2, 2, 2, 3, 3, 3, 3, 0, 3, 2, 2, 3, 3, 0, 1,
+      2, 2, 3, 3, 0, 1, 2, 3, 1, 2, 2, 1, 2, 1, 2, 1, 2, 0, 3, 1, 0, 3, 2, 2, 2, 2, 3, 3, 0, 1, 0,
+      1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 2, 1, 0, 3, 2, 0, 1, 3, 2, 1, 0,
+      3, 2, 3, 2, 3, 2, 3, 3, 2, 2, 1, 0, 1, 0, 1, 0, 3, 2, 0, 1, 3, 2, 2, 3, 0, 0, 1, 1, 0, 1, 1,
+      2, 1, 0, 3, 2, 2, 3, 0, 1, 1, 0, 1, 0, 0, 2, 1, 3, 1, 0, 0, 1, 1, 0, 1, 0, 2, 3, 1, 1, 1, 3,
+      0, 0, 0, 0, 2, 1, 0, 0, 1, 1, 0, 2, 3, 0, 1, 2, 3, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+      2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3,
+      3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2, 2, 2,
+      2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2, 2, 2, 2, 2,
+      2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 0, 0,
+      0, 0, 0, 2, 1, 1, 1, 1, 1, 3, 0, 0, 1, 1, 0, 2, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 3, 3, 0, 2, 1, 3, 2, 0, 3, 3,
+      0, 0, 1, 1, 0, 0, 2, 1, 1, 3, 2, 2, 1, 1, 2, 2, 3, 3, 0, 0, 1, 1, 0, 0, 1, 1, 2, 2, 3, 3, 0,
+      0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 2, 1, 1, 3, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1,
+      1, 1, 1, 1, 2, 2, 3, 3, 0, 0, 0, 2, 1, 1, 1, 3, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0,
+      1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 2, 1, 1, 1, 3, 0, 0, 0, 0, 0, 2, 1, 1, 1, 1, 1, 3,
+      0, 0, 2, 1, 1, 3, 2, 2, 2, 3, 3, 3, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 2,
+      1, 1, 3, 2, 2, 2, 3, 3, 3, 2, 2, 2, 3, 3, 3, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 2, 1, 1, 3,
+      0, 0, 2, 1, 1, 3, 2, 2, 3, 1, 0, 0, 1, 1, 2, 3, 2, 2, 3, 3, 2, 2, 3, 3, 2, 3, 0, 1, 0, 0, 1,
+      1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1,
+      1, 2, 2, 3, 3, 0, 0, 1, 1, 0, 0, 2, 1, 1, 3, 0, 0, 2, 1, 1, 3, 0, 0, 1, 1, 0, 1, 0, 0, 2, 1,
+      1, 3, 0, 0, 0, 1, 2, 1, 1, 1, 3, 2, 2, 1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 2, 2, 3, 3, 2, 2, 3, 3,
+      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 3, 3, 1, 1, 1, 1, 3, 3, 3, 3, 1, 1, 0, 0, 0, 0, 0,
+      0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 1,
+      1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+      3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2,
+      2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 2, 2, 2, 2, 2, 2, 2,
+      3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      1, 1, 1, 1, 1, 1, 1, 1, 1};
+}
diff --git a/pgjdbc/src/test/java/org/postgresql/test/README b/pgjdbc/src/test/java/org/postgresql/test/README.md
similarity index 99%
rename from pgjdbc/src/test/java/org/postgresql/test/README
rename to pgjdbc/src/test/java/org/postgresql/test/README.md
index 1acac61b7f..8d86dec285 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/README
+++ b/pgjdbc/src/test/java/org/postgresql/test/README.md
@@ -58,7 +58,7 @@ loss of data. We recommend you assign the following names:
 
   database: test
   username: test
-  password: password
+  password: test
 
 These names correspond with the default names set for the test suite
 in $JDBC_SRC/build.xml. If you have chosen other names you need to
diff --git a/pgjdbc/src/test/java/org/postgresql/test/TestUtil.java b/pgjdbc/src/test/java/org/postgresql/test/TestUtil.java
index 2e12cc80c4..1a8f881dc4 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/TestUtil.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/TestUtil.java
@@ -120,6 +120,13 @@ public static String getPassword() {
     return System.getProperty("password");
   }
 
+  /*
+   * Returns the user for SSPI authentication tests
+   */
+  public static String getSSPIUser() {
+    return System.getProperty("sspiusername");
+  }
+
   /*
    * postgres like user
    */
@@ -266,7 +273,11 @@ public static java.sql.Connection openDB() throws Exception {
   public static java.sql.Connection openDB(Properties props) throws Exception {
     initDriver();
 
-    String user = getUser();
+    // Allow properties to override the user name.
+    String user = props.getProperty("username");
+    if (user == null) {
+      user = getUser();
+    }
     if (user == null) {
       throw new IllegalArgumentException(
           "user name is not specified. Please specify 'username' property via -D or build.properties");
@@ -307,7 +318,7 @@ public static void createSchema(Connection con, String schema) throws SQLExcepti
 
       st.executeUpdate(sql);
     } finally {
-      st.close();
+      closeQuietly(st);
     }
   }
 
@@ -361,7 +372,7 @@ public static void createTable(Connection con, String table, String columns, boo
       }
       st.executeUpdate(sql);
     } finally {
-      st.close();
+      closeQuietly(st);
     }
   }
 
@@ -383,7 +394,7 @@ public static void createTempTable(Connection con, String table, String columns)
       // Now create the table
       st.executeUpdate("create temp table " + table + " (" + columns + ")");
     } finally {
-      st.close();
+      closeQuietly(st);
     }
   }
 
@@ -405,7 +416,7 @@ public static void createEnumType(Connection con, String name, String values)
       // Now create the table
       st.executeUpdate("create type " + name + " as enum (" + values + ")");
     } finally {
-      st.close();
+      closeQuietly(st);
     }
   }
 
@@ -427,7 +438,46 @@ public static void createCompositeType(Connection con, String name, String value
       // Now create the table
       st.executeUpdate("create type " + name + " as (" + values + ")");
     } finally {
-      st.close();
+      closeQuietly(st);
+    }
+  }
+
+  /**
+   * Drops a domain
+   *
+   * @param con Connection
+   * @param name String
+   */
+  public static void dropDomain(Connection con, String name)
+      throws SQLException {
+    Statement st = con.createStatement();
+    try {
+      st.executeUpdate("drop domain " + name + " cascade");
+    } catch (SQLException ex) {
+      if (!con.getAutoCommit()) {
+        throw ex;
+      }
+    } finally {
+      closeQuietly(st);
+    }
+  }
+
+  /**
+   * Helper creates a domain
+   *
+   * @param con Connection
+   * @param name String
+   * @param values String
+   */
+  public static void createDomain(Connection con, String name, String values)
+      throws SQLException {
+    Statement st = con.createStatement();
+    try {
+      dropDomain(con, name);
+      // Now create the table
+      st.executeUpdate("create domain " + name + " as " + values);
+    } finally {
+      closeQuietly(st);
     }
   }
 
@@ -474,7 +524,7 @@ public static void dropTable(Connection con, String table) throws SQLException {
   public static void dropType(Connection con, String type) throws SQLException {
     Statement stmt = con.createStatement();
     try {
-      String sql = "DROP TYPE " + type;
+      String sql = "DROP TYPE " + type + " CASCADE";
       stmt.executeUpdate(sql);
     } catch (SQLException ex) {
       if (!con.getAutoCommit()) {
diff --git a/pgjdbc/src/test/java/org/postgresql/test/core/NativeQueryBindLengthTest.java b/pgjdbc/src/test/java/org/postgresql/test/core/NativeQueryBindLengthTest.java
new file mode 100644
index 0000000000..a12af0c2c2
--- /dev/null
+++ b/pgjdbc/src/test/java/org/postgresql/test/core/NativeQueryBindLengthTest.java
@@ -0,0 +1,45 @@
+package org.postgresql.test.core;
+
+import org.postgresql.core.NativeQuery;
+import org.postgresql.test.jdbc2.BaseTest4;
+
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.ArrayList;
+import java.util.List;
+
+@RunWith(Parameterized.class)
+public class NativeQueryBindLengthTest extends BaseTest4 {
+  private final int expected;
+  private final int bindCount;
+
+  public NativeQueryBindLengthTest(String name, int expected, int bindCount) {
+    this.expected = expected;
+    this.bindCount = bindCount;
+  }
+
+  @Test
+  public void testBindLengthCalculation() {
+    Assert.assertEquals(expected, NativeQuery.calculateBindLength(bindCount));
+  }
+
+  @Parameterized.Parameters(name = "{0} == {1}")
+  public static Iterable<Object[]> data() {
+    List<Object[]> res = new ArrayList<Object[]>();
+    res.add(new Object[]{"'$1'.length = 2", 2, 1});
+    res.add(new Object[]{"'$1$2...$9'.length = 2*9", 18, 9});
+    res.add(new Object[]{"'$1$2...$9$10'.length = 2*9+3", 21, 10});
+    res.add(new Object[]{"'$1$2...$9$10..$99'.length = 2*9+3*90", 288, 99});
+    res.add(new Object[]{"'$1$2...$9$10..$99$100'.length = 2*9+3*90+4", 292, 100});
+    res.add(new Object[]{"'$1$2...$9$10..$99$100$101'.length = 2*9+3*90+4+4", 296, 101});
+    res.add(new Object[]{"'$1...$999'.length", 3888, 999});
+    res.add(new Object[]{"'$1...$1000'.length", 3893, 1000});
+    res.add(new Object[]{"'$1...$9999'.length", 48888, 9999});
+    res.add(new Object[]{"'$1...$10000'.length", 48894, 10000});
+    res.add(new Object[]{"'$1...$32767'.length", 185496, Short.MAX_VALUE});
+    return res;
+  }
+}
diff --git a/pgjdbc/src/test/java/org/postgresql/test/extensions/HStoreTest.java b/pgjdbc/src/test/java/org/postgresql/test/extensions/HStoreTest.java
index 14623076d6..e9d82fdbe1 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/extensions/HStoreTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/extensions/HStoreTest.java
@@ -16,6 +16,7 @@
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
+import java.sql.Types;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
@@ -65,7 +66,7 @@ public void testHStoreSelectNullValue() throws SQLException {
   }
 
   public void testHStoreSend() throws SQLException {
-    Map<String, Integer> correct = Collections.singletonMap("a", new Integer(1));
+    Map<String, Integer> correct = Collections.singletonMap("a", 1);
     PreparedStatement pstmt = _conn.prepareStatement("SELECT ?::text");
     pstmt.setObject(1, correct);
     ResultSet rs = pstmt.executeQuery();
@@ -74,6 +75,16 @@ public void testHStoreSend() throws SQLException {
     assertEquals("\"a\"=>\"1\"", rs.getString(1));
   }
 
+  public void testHStoreUsingPSSetObject4() throws SQLException {
+    Map<String, Integer> correct = Collections.singletonMap("a", 1);
+    PreparedStatement pstmt = _conn.prepareStatement("SELECT ?::text");
+    pstmt.setObject(1, correct, Types.OTHER, -1);
+    ResultSet rs = pstmt.executeQuery();
+    assertEquals(String.class.getName(), rs.getMetaData().getColumnClassName(1));
+    assertTrue(rs.next());
+    assertEquals("\"a\"=>\"1\"", rs.getString(1));
+  }
+
   public void testHStoreSendEscaped() throws SQLException {
     Map<String, String> correct = Collections.singletonMap("a", "t'e\ns\"t");
     PreparedStatement pstmt = _conn.prepareStatement("SELECT ?");
diff --git a/pgjdbc/src/test/java/org/postgresql/test/hostchooser/MultiHostsConnectionTest.java b/pgjdbc/src/test/java/org/postgresql/test/hostchooser/MultiHostsConnectionTest.java
index bdc750b532..bd12af1f6d 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/hostchooser/MultiHostsConnectionTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/hostchooser/MultiHostsConnectionTest.java
@@ -45,9 +45,8 @@ public class MultiHostsConnectionTest extends TestCase {
   private static Map<HostSpec, Object> hostStatusMap;
 
   static {
-    Field field;
     try {
-      field = GlobalHostStatusTracker.class.getDeclaredField("hostStatusMap");
+      Field field = GlobalHostStatusTracker.class.getDeclaredField("hostStatusMap");
       field.setAccessible(true);
       hostStatusMap = (Map<HostSpec, Object>) field.get(null);
 
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ArrayTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ArrayTest.java
index 9c540e32de..82cc44b675 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ArrayTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ArrayTest.java
@@ -8,8 +8,10 @@
 
 package org.postgresql.test.jdbc2;
 
+import org.postgresql.core.BaseConnection;
 import org.postgresql.geometric.PGbox;
 import org.postgresql.geometric.PGpoint;
+import org.postgresql.jdbc.PgArray;
 import org.postgresql.test.TestUtil;
 
 import org.junit.Assert;
@@ -267,6 +269,12 @@ public void testNullValues() throws SQLException {
     Assert.assertEquals(3, i[2].intValue());
   }
 
+  @Test
+  public void testNullFieldString() throws SQLException {
+    Array arr = new PgArray((BaseConnection) conn, 1, (String) null);
+    Assert.assertNull(arr.toString());
+  }
+
   @Test
   public void testUnknownArrayType() throws SQLException {
     Statement stmt = conn.createStatement();
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BaseTest4.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BaseTest4.java
index 2327522277..f1e8fc3bee 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BaseTest4.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BaseTest4.java
@@ -13,11 +13,11 @@
 public class BaseTest4 {
 
   public enum BinaryMode {
-    REGULAR, FORCE;
+    REGULAR, FORCE
   }
 
   public enum AutoCommit {
-    YES, NO;
+    YES, NO
   }
 
   protected Connection con;
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchExecuteBinaryTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchExecuteBinaryTest.java
deleted file mode 100644
index ca49fc4baa..0000000000
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchExecuteBinaryTest.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package org.postgresql.test.jdbc2;
-
-import java.util.Properties;
-
-public class BatchExecuteBinaryTest extends BatchExecuteTest {
-  public BatchExecuteBinaryTest(String name) {
-    super(name);
-  }
-
-  @Override
-  protected void updateProperties(Properties props) {
-    forceBinary(props);
-  }
-}
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchExecuteTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchExecuteTest.java
index d308b97f14..7d70d96928 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchExecuteTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchExecuteTest.java
@@ -8,15 +8,26 @@
 
 package org.postgresql.test.jdbc2;
 
+import org.postgresql.PGProperty;
 import org.postgresql.test.TestUtil;
 
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
 import java.sql.BatchUpdateException;
 import java.sql.DatabaseMetaData;
+import java.sql.Date;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Statement;
+import java.sql.Types;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collection;
+import java.util.Properties;
 
 /*
  * TODO tests that can be added to this test case - SQLExceptions chained to a BatchUpdateException
@@ -26,16 +37,37 @@
 /*
  * Test case for Statement.batchExecute()
  */
-public class BatchExecuteTest extends BaseTest {
+@RunWith(Parameterized.class)
+public class BatchExecuteTest extends BaseTest4 {
+
+  private boolean insertRewrite;
+
+  public BatchExecuteTest(BinaryMode binaryMode, boolean insertRewrite) {
+    this.insertRewrite = insertRewrite;
+    setBinaryMode(binaryMode);
+  }
 
-  public BatchExecuteTest(String name) {
-    super(name);
+  @Parameterized.Parameters(name = "binary = {0}, insertRewrite = {1}")
+  public static Iterable<Object[]> data() {
+    Collection<Object[]> ids = new ArrayList<Object[]>();
+    for (BinaryMode binaryMode : BinaryMode.values()) {
+      for (boolean insertRewrite : new boolean[]{false, true}) {
+        ids.add(new Object[]{binaryMode, insertRewrite});
+      }
+    }
+    return ids;
+  }
+
+  @Override
+  protected void updateProperties(Properties props) {
+    super.updateProperties(props);
+    PGProperty.REWRITE_BATCHED_INSERTS.set(props, insertRewrite);
   }
 
   // Set up the fixture for this testcase: a connection to a database with
   // a table for this test.
   @Override
-  protected void setUp() throws Exception {
+  public void setUp() throws Exception {
     super.setUp();
     Statement stmt = con.createStatement();
 
@@ -45,7 +77,7 @@ protected void setUp() throws Exception {
 
     stmt.executeUpdate("INSERT INTO testbatch VALUES (1, 0)");
 
-    TestUtil.createTable(con, "prep", "a integer, b integer");
+    TestUtil.createTable(con, "prep", "a integer, b integer, d date");
 
     TestUtil.createTable(con, "batchUpdCnt", "id varchar(512) primary key, data varchar(512)");
     stmt.executeUpdate("INSERT INTO batchUpdCnt(id) VALUES ('key-2')");
@@ -59,18 +91,20 @@ protected void setUp() throws Exception {
 
   // Tear down the fixture for this test case.
   @Override
-  protected void tearDown() throws SQLException {
+  public void tearDown() throws SQLException {
     con.setAutoCommit(true);
 
     TestUtil.dropTable(con, "testbatch");
     super.tearDown();
   }
 
+  @Test
   public void testSupportsBatchUpdates() throws Exception {
     DatabaseMetaData dbmd = con.getMetaData();
-    assertTrue(dbmd.supportsBatchUpdates());
+    Assert.assertTrue(dbmd.supportsBatchUpdates());
   }
 
+  @Test
   public void testEmptyClearBatch() throws Exception {
     Statement stmt = con.createStatement();
     stmt.clearBatch(); // No-op.
@@ -83,30 +117,32 @@ private void assertCol1HasValue(int expected) throws Exception {
     Statement getCol1 = con.createStatement();
 
     ResultSet rs = getCol1.executeQuery("SELECT col1 FROM testbatch WHERE pk = 1");
-    assertTrue(rs.next());
+    Assert.assertTrue(rs.next());
 
     int actual = rs.getInt("col1");
 
-    assertEquals(expected, actual);
+    Assert.assertEquals(expected, actual);
 
-    assertEquals(false, rs.next());
+    Assert.assertEquals(false, rs.next());
 
     rs.close();
     getCol1.close();
   }
 
+  @Test
   public void testExecuteEmptyBatch() throws Exception {
     Statement stmt = con.createStatement();
     int[] updateCount = stmt.executeBatch();
-    assertEquals(0, updateCount.length);
+    Assert.assertEquals(0, updateCount.length);
 
     stmt.addBatch("UPDATE testbatch SET col1 = col1 + 1 WHERE pk = 1");
     stmt.clearBatch();
     updateCount = stmt.executeBatch();
-    assertEquals(0, updateCount.length);
+    Assert.assertEquals(0, updateCount.length);
     stmt.close();
   }
 
+  @Test
   public void testClearBatch() throws Exception {
     Statement stmt = con.createStatement();
 
@@ -126,6 +162,7 @@ public void testClearBatch() throws Exception {
     stmt.close();
   }
 
+  @Test
   public void testSelectInBatch() throws Exception {
     Statement stmt = con.createStatement();
 
@@ -133,27 +170,29 @@ public void testSelectInBatch() throws Exception {
     stmt.addBatch("SELECT col1 FROM testbatch WHERE pk = 1");
     stmt.addBatch("UPDATE testbatch SET col1 = col1 + 2 WHERE pk = 1");
 
-    // There's no reason to fail
+    // There's no reason to Assert.fail
     int[] updateCounts = stmt.executeBatch();
 
-    assertTrue("First update should succeed, thus updateCount should be 1 or SUCCESS_NO_INFO"
+    Assert.assertTrue("First update should succeed, thus updateCount should be 1 or SUCCESS_NO_INFO"
             + ", actual value: " + updateCounts[0],
         updateCounts[0] == 1 || updateCounts[0] == Statement.SUCCESS_NO_INFO);
-    assertTrue("For SELECT, number of modified rows should be either 0 or SUCCESS_NO_INFO"
+    Assert.assertTrue("For SELECT, number of modified rows should be either 0 or SUCCESS_NO_INFO"
             + ", actual value: " + updateCounts[1],
         updateCounts[1] == 0 || updateCounts[1] == Statement.SUCCESS_NO_INFO);
-    assertTrue("Second update should succeed, thus updateCount should be 1 or SUCCESS_NO_INFO"
+    Assert.assertTrue("Second update should succeed, thus updateCount should be 1 or SUCCESS_NO_INFO"
             + ", actual value: " + updateCounts[2],
         updateCounts[2] == 1 || updateCounts[2] == Statement.SUCCESS_NO_INFO);
 
     stmt.close();
   }
 
+  @Test
   public void testSelectInBatchThrowsAutoCommit() throws Exception {
     con.setAutoCommit(true);
     testSelectInBatchThrows();
   }
 
+  @Test
   public void testSelectInBatchThrows() throws Exception {
     Statement stmt = con.createStatement();
 
@@ -165,7 +204,7 @@ public void testSelectInBatchThrows() throws Exception {
     int[] updateCounts;
     try {
       updateCounts = stmt.executeBatch();
-      fail("0/0 should throw BatchUpdateException");
+      Assert.fail("0/0 should throw BatchUpdateException");
     } catch (BatchUpdateException be) {
       updateCounts = be.getUpdateCounts();
     }
@@ -175,10 +214,10 @@ public void testSelectInBatchThrows() throws Exception {
     }
 
     int newValue = getCol1Value();
-    assertEquals("testbatch.col1 should not be updated since error happened in batch",
+    Assert.assertEquals("testbatch.col1 should not be updated since error happened in batch",
         oldValue, newValue);
 
-    assertEquals("All rows should be marked as EXECUTE_FAILED",
+    Assert.assertEquals("All rows should be marked as EXECUTE_FAILED",
         Arrays.toString(new int[]{Statement.EXECUTE_FAILED, Statement.EXECUTE_FAILED,
             Statement.EXECUTE_FAILED}),
         Arrays.toString(updateCounts));
@@ -197,6 +236,7 @@ private int getCol1Value() throws SQLException {
     }
   }
 
+  @Test
   public void testStringAddBatchOnPreparedStatement() throws Exception {
     PreparedStatement pstmt =
         con.prepareStatement("UPDATE testbatch SET col1 = col1 + ? WHERE PK = ?");
@@ -206,7 +246,7 @@ public void testStringAddBatchOnPreparedStatement() throws Exception {
 
     try {
       pstmt.addBatch("UPDATE testbatch SET col1 = 3");
-      fail(
+      Assert.fail(
           "Should have thrown an exception about using the string addBatch method on a prepared statement.");
     } catch (SQLException sqle) {
     }
@@ -214,6 +254,7 @@ public void testStringAddBatchOnPreparedStatement() throws Exception {
     pstmt.close();
   }
 
+  @Test
   public void testPreparedStatement() throws Exception {
     PreparedStatement pstmt =
         con.prepareStatement("UPDATE testbatch SET col1 = col1 + ? WHERE PK = ?");
@@ -253,6 +294,7 @@ public void testPreparedStatement() throws Exception {
     pstmt.close();
   }
 
+  @Test
   public void testTransactionalBehaviour() throws Exception {
     Statement stmt = con.createStatement();
 
@@ -270,9 +312,9 @@ public void testTransactionalBehaviour() throws Exception {
     assertCol1HasValue(0);
 
     int[] updateCounts = stmt.executeBatch();
-    assertEquals(2, updateCounts.length);
-    assertEquals(1, updateCounts[0]);
-    assertEquals(1, updateCounts[1]);
+    Assert.assertEquals(2, updateCounts.length);
+    Assert.assertEquals(1, updateCounts[0]);
+    Assert.assertEquals(1, updateCounts[1]);
 
     assertCol1HasValue(12);
     con.commit();
@@ -280,19 +322,21 @@ public void testTransactionalBehaviour() throws Exception {
     con.rollback();
     assertCol1HasValue(12);
 
-    stmt.close();
+    TestUtil.closeQuietly(stmt);
   }
 
+  @Test
   public void testWarningsAreCleared() throws SQLException {
     Statement stmt = con.createStatement();
     stmt.addBatch("CREATE TEMP TABLE unused (a int primary key)");
     stmt.executeBatch();
     // Execute an empty batch to clear warnings.
     stmt.executeBatch();
-    assertNull(stmt.getWarnings());
-    stmt.close();
+    Assert.assertNull(stmt.getWarnings());
+    TestUtil.closeQuietly(stmt);
   }
 
+  @Test
   public void testBatchEscapeProcessing() throws SQLException {
     Statement stmt = con.createStatement();
     stmt.execute("CREATE TEMP TABLE batchescape (d date)");
@@ -307,15 +351,15 @@ public void testBatchEscapeProcessing() throws SQLException {
     pstmt.close();
 
     ResultSet rs = stmt.executeQuery("SELECT d FROM batchescape");
-    assertTrue(rs.next());
-    assertEquals("2007-11-20", rs.getString(1));
-    assertTrue(rs.next());
-    assertEquals("2007-11-20", rs.getString(1));
-    assertTrue(!rs.next());
-    rs.close();
-    stmt.close();
+    Assert.assertTrue(rs.next());
+    Assert.assertEquals("2007-11-20", rs.getString(1));
+    Assert.assertTrue(rs.next());
+    Assert.assertEquals("2007-11-20", rs.getString(1));
+    Assert.assertTrue(!rs.next());
+    TestUtil.closeQuietly(stmt);
   }
 
+  @Test
   public void testBatchWithEmbeddedNulls() throws SQLException {
     Statement stmt = con.createStatement();
     stmt.execute("CREATE TEMP TABLE batchstring (a text)");
@@ -332,19 +376,19 @@ public void testBatchWithEmbeddedNulls() throws SQLException {
       pstmt.setString(1, "b");
       pstmt.addBatch();
       pstmt.executeBatch();
-      fail("Should have thrown an exception.");
+      Assert.fail("Should have thrown an exception.");
     } catch (SQLException sqle) {
       con.rollback();
     }
     pstmt.close();
 
     ResultSet rs = stmt.executeQuery("SELECT COUNT(*) FROM batchstring");
-    assertTrue(rs.next());
-    assertEquals(0, rs.getInt(1));
-    rs.close();
-    stmt.close();
+    Assert.assertTrue(rs.next());
+    Assert.assertEquals(0, rs.getInt(1));
+    TestUtil.closeQuietly(stmt);
   }
 
+  @Test
   public void testMixedBatch() throws SQLException {
     try {
       Statement st = con.createStatement();
@@ -358,11 +402,11 @@ public void testMixedBatch() throws SQLException {
       st.addBatch("CREATE TEMPORARY TABLE waffles(sauce text)");
       st.addBatch("INSERT INTO waffles(sauce) VALUES ('cream'), ('strawberry jam')");
       int[] batchResult = st.executeBatch();
-      assertEquals(1, batchResult[0]);
-      assertEquals(1, batchResult[1]);
-      assertEquals(1, batchResult[2]);
-      assertEquals(0, batchResult[3]);
-      assertEquals(2, batchResult[4]);
+      Assert.assertEquals(1, batchResult[0]);
+      Assert.assertEquals(1, batchResult[1]);
+      Assert.assertEquals(1, batchResult[2]);
+      Assert.assertEquals(0, batchResult[3]);
+      Assert.assertEquals(2, batchResult[4]);
     } catch (SQLException ex) {
       ex.getNextException().printStackTrace();
       throw ex;
@@ -373,16 +417,16 @@ public void testMixedBatch() throws SQLException {
    * A user reported that a query that uses RETURNING (via getGeneratedKeys) in a batch, and a
    * 'text' field value in a table is assigned NULL in the first execution of the batch then
    * non-NULL afterwards using PreparedStatement.setObject(int, Object) (i.e. no Types param or
-   * setString call) the batch may fail with:
+   * setString call) the batch may Assert.fail with:
    *
    * "Received resultset tuples, but no field structure for them"
    *
    * at org.postgresql.core.v3.QueryExecutorImpl.processResults
    *
-   * Prior to 245b388 it would instead fail with a NullPointerException in
+   * Prior to 245b388 it would instead Assert.fail with a NullPointerException in
    * AbstractJdbc2ResultSet.checkColumnIndex
    *
-   * The cause is complicated. The failure arises because the query gets re-planned mid-batch. This
+   * The cause is complicated. The Assert.failure arises because the query gets re-planned mid-batch. This
    * re-planning clears the cached information about field types. The field type information for
    * parameters gets re-acquired later but the information for *returned* values does not.
    *
@@ -412,6 +456,7 @@ public void testMixedBatch() throws SQLException {
    * This issue can be reproduced with any pair of implicitly or assignment castable types; for
    * example, using Integer in JDBC and bigint in the Pg table will do it.
    */
+  @Test
   public void testBatchReturningMixedNulls() throws SQLException {
     String[] testData = new String[]{null, "test", null, null, null};
 
@@ -445,20 +490,198 @@ public void testBatchReturningMixedNulls() throws SQLException {
       ResultSet rs = st.getGeneratedKeys();
       for (int i = 1; i <= testData.length; i++) {
         rs.next();
-        assertEquals(i, rs.getInt(1));
+        Assert.assertEquals(i, rs.getInt(1));
       }
-      assertTrue(!rs.next());
+      Assert.assertTrue(!rs.next());
     } catch (SQLException ex) {
       ex.getNextException().printStackTrace();
       throw ex;
     }
   }
 
+  @Test
+  public void testBatchWithAlternatingAndUnknownTypes0() throws SQLException {
+    testBatchWithAlternatingAndUnknownTypesN(0);
+  }
+
+  @Test
+  public void testBatchWithAlternatingAndUnknownTypes1() throws SQLException {
+    testBatchWithAlternatingAndUnknownTypesN(1);
+  }
+
+  @Test
+  public void testBatchWithAlternatingAndUnknownTypes2() throws SQLException {
+    testBatchWithAlternatingAndUnknownTypesN(2);
+  }
+
+  @Test
+  public void testBatchWithAlternatingAndUnknownTypes3() throws SQLException {
+    testBatchWithAlternatingAndUnknownTypesN(3);
+  }
+
+  @Test
+  public void testBatchWithAlternatingAndUnknownTypes4() throws SQLException {
+    testBatchWithAlternatingAndUnknownTypesN(4);
+  }
+
+  @Test
+  public void testBatchWithAlternatingAndUnknownTypes5() throws SQLException {
+    testBatchWithAlternatingAndUnknownTypesN(5);
+  }
+
+  @Test
+  public void testBatchWithAlternatingAndUnknownTypes6() throws SQLException {
+    testBatchWithAlternatingAndUnknownTypesN(6);
+  }
+
+  /**
+   * This one is reproduced in regular (non-force binary) mode
+   * As of 9.4.1208 the following tests fail:
+   * BatchExecuteTest.testBatchWithAlternatingAndUnknownTypes3
+   * BatchExecuteTest.testBatchWithAlternatingAndUnknownTypes4
+   * BatchExecuteTest.testBatchWithAlternatingAndUnknownTypes5
+   * BatchExecuteTest.testBatchWithAlternatingAndUnknownTypes6
+   * @throws SQLException in case of failure
+   * @param numPreliminaryInserts number of preliminary inserts to make so the statement gets
+   *                              prepared
+   */
+  public void testBatchWithAlternatingAndUnknownTypesN(int numPreliminaryInserts)
+      throws SQLException {
+    PreparedStatement ps = null;
+    try {
+      con.setAutoCommit(true);
+      // This test requires autoCommit false to reproduce
+      ps = con.prepareStatement("insert into prep(a, d) values(?, ?)");
+      for (int i = 0; i < numPreliminaryInserts; i++) {
+        ps.setNull(1, Types.SMALLINT);
+        ps.setObject(2, new Date(42));
+        ps.addBatch();
+        ps.executeBatch();
+      }
+
+      ps.setObject(1, new Double(43));
+      ps.setObject(2, new Date(43));
+      ps.addBatch();
+      ps.setNull(1, Types.SMALLINT);
+      ps.setObject(2, new Date(44));
+      ps.addBatch();
+      ps.executeBatch();
+
+      ps.setObject(1, new Double(45));
+      ps.setObject(2, new Date(45)); // <-- this causes "oid of bind unknown, send Describe"
+      ps.addBatch();
+      ps.setNull(1, Types.SMALLINT);
+      ps.setNull(2, Types.DATE);     // <-- this uses Oid.DATE, thus no describe message
+      // As the same query object was reused the describe from Date(45) overwrites
+      // parameter types, thus Double(45)'s type (double) comes instead of SMALLINT.
+      // Thus pgjdbc thinks the prepared statement is prepared for (double, date) types
+      // however in reality the statement is prepared for (smallint, date) types.
+
+      ps.addBatch();
+      ps.executeBatch();
+
+      // This execution with (double, unknown) passes isPreparedForTypes check, and causes
+      // the failure
+      ps.setObject(1, new Double(47));
+      ps.setObject(2, new Date(47));
+      ps.addBatch();
+      ps.executeBatch();
+    } catch (BatchUpdateException e) {
+      throw e.getNextException();
+    } finally {
+      TestUtil.closeQuietly(ps);
+    }
+    /*
+Here's the log
+11:33:10.708 (1)  FE=> Parse(stmt=null,query="CREATE TABLE prep (a integer, b integer, d date) ",oids={})
+11:33:10.708 (1)  FE=> Bind(stmt=null,portal=null)
+11:33:10.708 (1)  FE=> Describe(portal=null)
+11:33:10.708 (1)  FE=> Execute(portal=null,limit=1)
+11:33:10.708 (1)  FE=> Sync
+11:33:10.710 (1)  <=BE ParseComplete [null]
+11:33:10.711 (1)  <=BE BindComplete [unnamed]
+11:33:10.711 (1)  <=BE NoData
+11:33:10.711 (1)  <=BE CommandStatus(CREATE TABLE)
+11:33:10.711 (1)  <=BE ReadyForQuery(I)
+11:33:10.716 (1) batch execute 1 queries, handler=org.postgresql.jdbc.PgStatement$BatchResultHandler@4629104a, maxRows=0, fetchSize=0, flags=5
+11:33:10.716 (1)  FE=> Parse(stmt=null,query="BEGIN",oids={})
+11:33:10.717 (1)  FE=> Bind(stmt=null,portal=null)
+11:33:10.717 (1)  FE=> Execute(portal=null,limit=0)
+11:33:10.718 (1)  FE=> Parse(stmt=null,query="insert into prep(a, d) values($1, $2)",oids={21,0})
+11:33:10.718 (1)  FE=> Bind(stmt=null,portal=null,$1=<NULL>:B:21,$2=<'1970-1-1 +3:0:0'>:T:0)
+11:33:10.719 (1)  FE=> Describe(portal=null)
+11:33:10.719 (1)  FE=> Execute(portal=null,limit=1)
+11:33:10.719 (1)  FE=> Sync
+11:33:10.720 (1)  <=BE ParseComplete [null]
+11:33:10.720 (1)  <=BE BindComplete [unnamed]
+11:33:10.720 (1)  <=BE CommandStatus(BEGIN)
+11:33:10.720 (1)  <=BE ParseComplete [null]
+11:33:10.720 (1)  <=BE BindComplete [unnamed]
+11:33:10.720 (1)  <=BE NoData
+11:33:10.720 (1)  <=BE CommandStatus(INSERT 0 1)
+11:33:10.720 (1)  <=BE ReadyForQuery(T)
+11:33:10.721 (1) batch execute 2 queries, handler=org.postgresql.jdbc.PgStatement$BatchResultHandler@27f8302d, maxRows=0, fetchSize=0, flags=5
+11:33:10.721 (1)  FE=> Parse(stmt=null,query="insert into prep(a, d) values($1, $2)",oids={701,0})
+11:33:10.723 (1)  FE=> Bind(stmt=null,portal=null,$1=<43.0>:B:701,$2=<'1970-1-1 +3:0:0'>:T:0)
+11:33:10.723 (1)  FE=> Describe(portal=null)
+11:33:10.723 (1)  FE=> Execute(portal=null,limit=1)
+11:33:10.723 (1)  FE=> Parse(stmt=null,query="insert into prep(a, d) values($1, $2)",oids={21,0})
+11:33:10.723 (1)  FE=> Bind(stmt=null,portal=null,$1=<NULL>:B:21,$2=<'1970-1-1 +3:0:0'>:T:0)
+11:33:10.723 (1)  FE=> Describe(portal=null)
+11:33:10.723 (1)  FE=> Execute(portal=null,limit=1)
+11:33:10.723 (1)  FE=> Sync
+11:33:10.723 (1)  <=BE ParseComplete [null]
+11:33:10.723 (1)  <=BE BindComplete [unnamed]
+11:33:10.725 (1)  <=BE NoData
+11:33:10.726 (1)  <=BE CommandStatus(INSERT 0 1)
+11:33:10.726 (1)  <=BE ParseComplete [null]
+11:33:10.726 (1)  <=BE BindComplete [unnamed]
+11:33:10.726 (1)  <=BE NoData
+11:33:10.726 (1)  <=BE CommandStatus(INSERT 0 1)
+11:33:10.726 (1)  <=BE ReadyForQuery(T)
+11:33:10.726 (1) batch execute 2 queries, handler=org.postgresql.jdbc.PgStatement$BatchResultHandler@4d76f3f8, maxRows=0, fetchSize=0, flags=516
+11:33:10.726 (1)  FE=> Parse(stmt=S_1,query="insert into prep(a, d) values($1, $2)",oids={701,0})
+11:33:10.727 (1)  FE=> Describe(statement=S_1)
+11:33:10.728 (1)  FE=> Bind(stmt=S_1,portal=null,$1=<45.0>:B:701,$2=<'1970-1-1 +3:0:0'>:T:0)
+11:33:10.728 (1)  FE=> Execute(portal=null,limit=1)
+11:33:10.729 (1)  FE=> CloseStatement(S_1)
+11:33:10.729 (1)  FE=> Parse(stmt=S_2,query="insert into prep(a, d) values($1, $2)",oids={21,1082})
+11:33:10.729 (1)  FE=> Bind(stmt=S_2,portal=null,$1=<NULL>:B:21,$2=<NULL>:B:1082)
+11:33:10.729 (1)  FE=> Describe(portal=null)
+11:33:10.729 (1)  FE=> Execute(portal=null,limit=1)
+11:33:10.729 (1)  FE=> Sync
+11:33:10.730 (1)  <=BE ParseComplete [S_2]
+11:33:10.730 (1)  <=BE ParameterDescription
+11:33:10.730 (1)  <=BE NoData
+11:33:10.730 (1)  <=BE BindComplete [unnamed]
+11:33:10.730 (1)  <=BE CommandStatus(INSERT 0 1)
+11:33:10.730 (1)  <=BE CloseComplete
+11:33:10.730 (1)  <=BE ParseComplete [S_2]
+11:33:10.730 (1)  <=BE BindComplete [unnamed]
+11:33:10.730 (1)  <=BE NoData
+11:33:10.731 (1)  <=BE CommandStatus(INSERT 0 1)
+11:33:10.731 (1)  <=BE ReadyForQuery(T)
+11:33:10.731 (1) batch execute 1 queries, handler=org.postgresql.jdbc.PgStatement$BatchResultHandler@4534b60d, maxRows=0, fetchSize=0, flags=516
+11:33:10.731 (1)  FE=> Bind(stmt=S_2,portal=null,$1=<47.0>:B:701,$2=<'1970-1-1 +3:0:0'>:T:1082)
+11:33:10.731 (1)  FE=> Describe(portal=null)
+11:33:10.731 (1)  FE=> Execute(portal=null,limit=1)
+11:33:10.731 (1)  FE=> Sync
+11:33:10.732 (1)  <=BE ErrorMessage(ERROR: incorrect binary data format in bind parameter 1)
+org.postgresql.util.PSQLException: ERROR: incorrect binary data format in bind parameter 1
+  at org.postgresql.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:2185)
+  at org.postgresql.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:1914)
+  at org.postgresql.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:338)
+  at org.postgresql.jdbc.PgStatement.executeBatch(PgStatement.java:2534)
+  at org.postgresql.test.jdbc2.BatchExecuteTest.testBatchWithAlternatingTypes2(BatchExecuteTest.java:460)
+    */
+  }
+
   /**
    * Tests {@link PreparedStatement#addBatch} in case types of parameters change from one batch to
    * another. Change of the datatypes causes re-prepare server-side statement, thus exactly the same
    * query object might have different statement names.
    */
+  @Test
   public void testBatchWithAlternatingTypes() throws SQLException {
     try {
       Statement s = con.createStatement();
@@ -886,9 +1109,11 @@ Key part is (see "before the fix"):
 23:15:33.934 (1)  <=BE CommandStatus(DROP TABLE)
 23:15:33.934 (1)  <=BE ReadyForQuery(I)
 23:15:33.934 (1)  FE=> Terminate
+<<<<<<< HEAD
      */
   }
 
+  @Test
   public void testSmallBatchUpdateFailureSimple() throws SQLException {
     con.setAutoCommit(true);
 
@@ -903,34 +1128,153 @@ public void testSmallBatchUpdateFailureSimple() throws SQLException {
     int[] batchResult;
     try {
       batchResult = batchSt.executeBatch();
-      fail("Expecting BatchUpdateException as key-2 is duplicated in batchUpdCnt.id. "
+      Assert.fail("Expecting BatchUpdateException as key-2 is duplicated in batchUpdCnt.id. "
           + " executeBatch returned " + Arrays.toString(batchResult));
     } catch (BatchUpdateException ex) {
       batchResult = ex.getUpdateCounts();
     } finally {
-      batchSt.close();
+      TestUtil.closeQuietly(batchSt);
     }
 
     int newCount = getBatchUpdCount();
     if (newCount == 2) {
       // key-1 did succeed
-      assertTrue("batchResult[0] should be 1 or SUCCESS_NO_INFO since 'key-1' was inserted,"
+      Assert.assertTrue("batchResult[0] should be 1 or SUCCESS_NO_INFO since 'key-1' was inserted,"
           + " actual result is " + Arrays.toString(batchResult),
           batchResult[0] == 1 || batchResult[0] == Statement.SUCCESS_NO_INFO);
     } else {
-      assertTrue("batchResult[0] should be 0 or EXECUTE_FAILED since 'key-1' was NOT inserted,"
+      Assert.assertTrue("batchResult[0] should be 0 or EXECUTE_FAILED since 'key-1' was NOT inserted,"
               + " actual result is " + Arrays.toString(batchResult),
           batchResult[0] == 0 || batchResult[0] == Statement.EXECUTE_FAILED);
     }
 
-    assertEquals("'key-2' insertion should have failed",
-        batchResult[1], Statement.EXECUTE_FAILED);
+    Assert.assertEquals("'key-2' insertion should have Assert.failed",
+        Statement.EXECUTE_FAILED, batchResult[1]);
   }
 
   private int getBatchUpdCount() throws SQLException {
     PreparedStatement ps = con.prepareStatement("select count(*) from batchUpdCnt");
     ResultSet rs = ps.executeQuery();
-    assertTrue("count(*) must return 1 row", rs.next());
+    Assert.assertTrue("count(*) must return 1 row", rs.next());
     return rs.getInt(1);
   }
+
+  /**
+   * Check batching using two individual statements that are both the same type.
+   * Test coverage to check default behaviour is not broken.
+   * @throws SQLException for issues during test
+   */
+  @Test
+  public void testBatchWithRepeatedInsertStatement() throws SQLException {
+    PreparedStatement pstmt = null;
+    /* Optimization to re-write insert statements is disabled by default.
+     * Do nothing here.
+     */
+    try {
+      pstmt = con.prepareStatement("INSERT INTO testbatch VALUES (?,?)");
+      pstmt.setInt(1, 1);
+      pstmt.setInt(2, 1);
+      pstmt.addBatch(); //statement one
+      pstmt.setInt(1, 2);
+      pstmt.setInt(2, 2);
+      pstmt.addBatch();//statement two
+      int[] outcome = pstmt.executeBatch();
+
+      Assert.assertNotNull(outcome);
+      Assert.assertEquals(2, outcome.length);
+      int rowsInserted = insertRewrite ? Statement.SUCCESS_NO_INFO : 1;
+      Assert.assertEquals(rowsInserted, outcome[0]);
+      Assert.assertEquals(rowsInserted, outcome[1]);
+    } catch (SQLException sqle) {
+      Assert.fail("Failed to execute two statements added to a batch. Reason:" + sqle.getMessage());
+    } finally {
+      TestUtil.closeQuietly(pstmt);
+    }
+  }
+
+  /**
+  * Test case to make sure the update counter is correct for the
+  * one statement executed. Test coverage to check default behaviour is
+  * not broken.
+  * @throws SQLException for issues during test
+  */
+  @Test
+  public void testBatchWithMultiInsert() throws SQLException {
+    PreparedStatement pstmt = null;
+    try {
+      pstmt = con.prepareStatement("INSERT INTO testbatch VALUES (?,?),(?,?)");
+      pstmt.setInt(1, 1);
+      pstmt.setInt(2, 1);
+      pstmt.setInt(3, 2);
+      pstmt.setInt(4, 2);
+      pstmt.addBatch();//statement one
+      int[] outcome = pstmt.executeBatch();
+      Assert.assertNotNull(outcome);
+      Assert.assertEquals(1, outcome.length);
+      Assert.assertEquals(2, outcome[0]);
+    } catch (SQLException sqle) {
+      Assert.fail("Failed to execute two statements added to a batch. Reason:" + sqle.getMessage());
+    } finally {
+      TestUtil.closeQuietly(pstmt);
+    }
+  }
+
+  /**
+  * Test case to make sure the update counter is correct for the
+  * two double-row statements executed. Test coverage to check default behaviour is
+  * not broken.
+  * @throws SQLException for issues during test
+  */
+  @Test
+  public void testBatchWithTwoMultiInsertStatements() throws SQLException {
+    PreparedStatement pstmt = null;
+    try {
+      pstmt = con.prepareStatement("INSERT INTO testbatch VALUES (?,?),(?,?)");
+      pstmt.setInt(1, 1);
+      pstmt.setInt(2, 1);
+      pstmt.setInt(3, 2);
+      pstmt.setInt(4, 2);
+      pstmt.addBatch(); //statement one
+      pstmt.setInt(1, 3);
+      pstmt.setInt(2, 3);
+      pstmt.setInt(3, 4);
+      pstmt.setInt(4, 4);
+      pstmt.addBatch(); //statement two
+      int[] outcome = pstmt.executeBatch();
+      int rowsInserted = insertRewrite ? Statement.SUCCESS_NO_INFO : 2;
+      Assert.assertEquals(
+          "Inserting two multi-valued statements with two rows each. Expecting {2, 2} rows inserted (or SUCCESS_NO_INFO)",
+          Arrays.toString(new int[] { rowsInserted, rowsInserted }),
+          Arrays.toString(outcome));
+    } catch (SQLException sqle) {
+      Assert.fail("Failed to execute two statements added to a batch. Reason:" + sqle.getMessage());
+    } finally {
+      TestUtil.closeQuietly(pstmt);
+    }
+  }
+
+  public static void assertSimpleInsertBatch(int n, int[] actual) {
+    int[] expected = new int[n];
+    Arrays.fill(expected, 1);
+    assertBatchResult(n + " addBatch, 1 row each", expected, actual);
+  }
+
+  public static void assertBatchResult(String message, int[] expected, int[] actual) {
+    int[] clone = expected.clone();
+    boolean hasChanges = false;
+    for (int i = 0; i < actual.length; i++) {
+      int a = actual[i];
+      if (a == Statement.SUCCESS_NO_INFO && expected[i] >= 0) {
+        clone[i] = a;
+        hasChanges = true;
+      }
+    }
+    if (hasChanges) {
+      message += ", original expectation: " + Arrays.toString(expected);
+    }
+    Assert.assertEquals(
+        message,
+        Arrays.toString(clone),
+        Arrays.toString(actual));
+  }
 }
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchFailureTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchFailureTest.java
index ebfeb6724b..6e4fd5b899 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchFailureTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchFailureTest.java
@@ -1,5 +1,6 @@
 package org.postgresql.test.jdbc2;
 
+import org.postgresql.PGProperty;
 import org.postgresql.test.TestUtil;
 
 import org.junit.Assert;
@@ -28,6 +29,7 @@ public class BatchFailureTest extends BaseTest4 {
   private final FailMode failMode;
   private final FailPosition failPosition;
   private final BinaryMode binaryMode;
+  private final boolean insertRewrite;
 
   enum BatchType {
     SIMPLE {
@@ -66,7 +68,7 @@ public void addRow(Statement statement, String value) throws SQLException {
     }
   }
 
-  enum FailMode {
+  private enum FailMode {
     NO_FAIL_JUST_INSERTS, NO_FAIL_SELECT,
     FAIL_VIA_SELECT_PARSE, FAIL_VIA_SELECT_RUNTIME,
     FAIL_VIA_DUP_KEY;
@@ -97,7 +99,7 @@ public void injectFailure(Statement statement, BatchType batchType) throws SQLEx
     }
   }
 
-  enum FailPosition {
+  private enum FailPosition {
     NONE, FIRST_ROW, SECOND_ROW, MIDDLE, ALMOST_LAST_ROW, LAST_ROW;
 
     public boolean supports(FailMode mode) {
@@ -106,17 +108,20 @@ public boolean supports(FailMode mode) {
   }
 
   public BatchFailureTest(BatchType batchType, AutoCommit autoCommit,
-      FailMode failMode, FailPosition failPosition, BinaryMode binaryMode) {
+      FailMode failMode, FailPosition failPosition, BinaryMode binaryMode,
+      boolean insertRewrite) {
     this.batchType = batchType;
     this.autoCommit = autoCommit;
     this.failMode = failMode;
     this.failPosition = failPosition;
     this.binaryMode = binaryMode;
+    this.insertRewrite = insertRewrite;
   }
 
-  @Parameterized.Parameters(name = "{index}: batchTest(mode={2}, position={3}, autoCommit={1}, batchType={0}, generateKeys={1}, binary={4})")
+  @Parameterized.Parameters(name = "{index}: batchTest(mode={2}, position={3}, autoCommit={1}, batchType={0}, generateKeys={1}, binary={4}, insertRewrite={5})")
   public static Iterable<Object[]> data() {
     Collection<Object[]> ids = new ArrayList<Object[]>();
+    boolean[] booleans = new boolean[] {true, false};
     for (BatchType batchType : BatchType.values()) {
       for (FailMode failMode : FailMode.values()) {
         if (!failMode.supports(batchType)) {
@@ -128,7 +133,9 @@ public static Iterable<Object[]> data() {
           }
           for (AutoCommit autoCommit : AutoCommit.values()) {
             for (BinaryMode binaryMode : BinaryMode.values()) {
-              ids.add(new Object[]{batchType, autoCommit, failMode, failPosition, binaryMode});
+              for (boolean insertRewrite : booleans) {
+                ids.add(new Object[]{batchType, autoCommit, failMode, failPosition, binaryMode, insertRewrite});
+              }
             }
           }
         }
@@ -142,6 +149,7 @@ protected void updateProperties(Properties props) {
     if (binaryMode == BinaryMode.FORCE) {
       forceBinary(props);
     }
+    PGProperty.REWRITE_BATCHED_INSERTS.set(props, insertRewrite);
   }
 
   @Override
@@ -234,7 +242,7 @@ public void run() throws SQLException {
 
     int finalCount = getBatchUpdCount();
     Assert.assertEquals(
-        "Number of new rows in batchUpdCnt should match number of non-error betchResult items"
+        "Number of new rows in batchUpdCnt should match number of non-error batchResult items"
             + Arrays.toString(batchResult),
         expectedRows - 1, finalCount - 1);
 
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchedInsertReWriteEnabledTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchedInsertReWriteEnabledTest.java
new file mode 100644
index 0000000000..b5bef3eb22
--- /dev/null
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchedInsertReWriteEnabledTest.java
@@ -0,0 +1,399 @@
+/*-------------------------------------------------------------------------
+ *
+ * Copyright (c) 2003-2016, PostgreSQL Global Development Group
+ *
+ *
+ *-------------------------------------------------------------------------
+ */
+
+package org.postgresql.test.jdbc2;
+
+import org.postgresql.PGProperty;
+import org.postgresql.test.TestUtil;
+
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.sql.BatchUpdateException;
+import java.sql.PreparedStatement;
+import java.sql.SQLException;
+import java.sql.Statement;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Properties;
+
+@RunWith(Parameterized.class)
+public class BatchedInsertReWriteEnabledTest extends BaseTest4 {
+  private final AutoCommit autoCommit;
+
+  public BatchedInsertReWriteEnabledTest(AutoCommit autoCommit) {
+    this.autoCommit = autoCommit;
+  }
+
+  @Parameterized.Parameters(name = "{index}: autoCommit={0}")
+  public static Iterable<Object[]> data() {
+    Collection<Object[]> ids = new ArrayList<Object[]>();
+    for (AutoCommit autoCommit : AutoCommit.values()) {
+      ids.add(new Object[]{autoCommit});
+    }
+    return ids;
+  }
+
+  /* Set up the fixture for this testcase: a connection to a database with
+  a table for this test. */
+  public void setUp() throws Exception {
+    super.setUp();
+    TestUtil.createTable(con, "testbatch", "pk INTEGER, col1 VARCHAR, col2 INTEGER");
+    con.setAutoCommit(autoCommit == AutoCommit.YES);
+  }
+
+  // Tear down the fixture for this test case.
+  public void tearDown() throws SQLException {
+    TestUtil.dropTable(con, "testbatch");
+    super.tearDown();
+  }
+
+  @Override
+  protected void updateProperties(Properties props) {
+    super.updateProperties(props);
+    PGProperty.REWRITE_BATCHED_INSERTS.set(props, true);
+  }
+
+  /**
+   * Check batching using two individual statements that are both the same type.
+   * Test to check the re-write optimisation behaviour.
+   */
+
+  @Test
+  public void testBatchWithReWrittenRepeatedInsertStatementOptimizationEnabled()
+      throws SQLException {
+    PreparedStatement pstmt = null;
+    try {
+      pstmt = con.prepareStatement("INSERT INTO testbatch VALUES (?,?)");
+      pstmt.setInt(1, 1);
+      pstmt.setInt(2, 2);
+      pstmt.addBatch();
+      pstmt.setInt(1, 3);
+      pstmt.setInt(2, 4);
+      pstmt.addBatch();
+      pstmt.setInt(1, 5);
+      pstmt.setInt(2, 6);
+      pstmt.addBatch();
+      BatchExecuteTest.assertSimpleInsertBatch(3, pstmt.executeBatch());
+
+      /*
+       * Now check the ps can be reused. The batched statement should be reset
+       * and have no knowledge of prior re-written batch. This test uses a
+       * different batch size. To test if the driver detects the different size
+       * and prepares the statement on with the backend. If not then an
+       * exception will be thrown for an unknown prepared statement.
+       */
+      pstmt.setInt(1, 1);
+      pstmt.setInt(2, 2);
+      pstmt.addBatch();
+      pstmt.setInt(1, 3);
+      pstmt.setInt(2, 4);
+      pstmt.addBatch();
+      pstmt.setInt(1, 5);
+      pstmt.setInt(2, 6);
+      pstmt.addBatch();
+      pstmt.setInt(1, 7);
+      pstmt.setInt(2, 8);
+      pstmt.addBatch();
+      BatchExecuteTest.assertSimpleInsertBatch(4, pstmt.executeBatch());
+
+      pstmt.setInt(1, 1);
+      pstmt.setInt(2, 2);
+      pstmt.addBatch();
+      pstmt.setInt(1, 3);
+      pstmt.setInt(2, 4);
+      pstmt.addBatch();
+      pstmt.setInt(1, 5);
+      pstmt.setInt(2, 6);
+      pstmt.addBatch();
+      pstmt.setInt(1, 7);
+      pstmt.setInt(2, 8);
+      pstmt.addBatch();
+      BatchExecuteTest.assertSimpleInsertBatch(4, pstmt.executeBatch());
+
+    } finally {
+      TestUtil.closeQuietly(pstmt);
+    }
+  }
+
+  /**
+   * Check batching using a statement with fixed parameter.
+   */
+  @Test
+  public void testBatchWithReWrittenBatchStatementWithFixedParameter()
+      throws SQLException {
+    String[] odd = new String[]{
+        "INSERT INTO testbatch VALUES (?, '1, (, $1234, a''n?d )' /*xxxx)*/, ?) -- xxx",
+        // "INSERT /*xxx*/INTO testbatch VALUES (?, '1, (, $1234, a''n?d )' /*xxxx)*/, ?) -- xxx",
+    };
+    for (String s : odd) {
+      PreparedStatement pstmt = null;
+      try {
+        pstmt = con.prepareStatement(s);
+        pstmt.setInt(1, 1);
+        pstmt.setInt(2, 2);
+        pstmt.addBatch();
+        pstmt.setInt(1, 3);
+        pstmt.setInt(2, 4);
+        pstmt.addBatch();
+        pstmt.setInt(1, 5);
+        pstmt.setInt(2, 6);
+        pstmt.addBatch();
+        BatchExecuteTest.assertSimpleInsertBatch(3, pstmt.executeBatch());
+      } finally {
+        TestUtil.closeQuietly(pstmt);
+      }
+    }
+  }
+
+  /**
+   * Test to make sure a statement with a semicolon is not broken
+   */
+  private void simpleRewriteBatch(String values, String suffix)
+      throws SQLException {
+    PreparedStatement pstmt = null;
+    try {
+      pstmt = con.prepareStatement("INSERT INTO testbatch " +  values + "(?,?,?)" + suffix);
+      pstmt.setInt(1, 1);
+      pstmt.setString(2, "a");
+      pstmt.setInt(3, 2);
+      pstmt.addBatch();
+      pstmt.setInt(1, 3);
+      pstmt.setString(2, "b");
+      pstmt.setInt(3, 4);
+      pstmt.addBatch();
+      pstmt.setInt(1, 5);
+      pstmt.setString(2, "c");
+      pstmt.setInt(3, 6);
+      pstmt.addBatch();
+      BatchExecuteTest.assertSimpleInsertBatch(3, pstmt.executeBatch());
+    } finally {
+      TestUtil.closeQuietly(pstmt);
+    }
+  }
+
+  /**
+   * Test to make sure a statement with a semicolon is not broken
+   */
+  @Test
+  public void testBatchWithReWrittenBatchStatementWithSemiColon()
+      throws SQLException {
+    simpleRewriteBatch("values", ";");
+  }
+
+  /**
+   * Test to make sure a statement with a semicolon is not broken
+   */
+  @Test
+  public void testBatchWithReWrittenSpaceAfterValues()
+      throws SQLException {
+    simpleRewriteBatch("values ", "");
+    simpleRewriteBatch("values  ", "");
+    simpleRewriteBatch("values\t", "");
+  }
+
+  /**
+   * Test VALUES word with mixed case.
+   */
+  @Test
+  public void testBatchWithReWrittenMixedCaseValues()
+      throws SQLException {
+    simpleRewriteBatch("vAlues", "");
+    simpleRewriteBatch("vaLUES", "");
+    simpleRewriteBatch("VALUES", "");
+  }
+
+  /**
+   * Test to make sure a statement with a semicolon is not broken
+   */
+  @Test
+  public void testBindsInNestedParens()
+      throws SQLException {
+    PreparedStatement pstmt = null;
+    try {
+      pstmt = con.prepareStatement("INSERT INTO testbatch VALUES ((?),((?)),?);");
+      pstmt.setInt(1, 1);
+      pstmt.setString(2, "a");
+      pstmt.setInt(3, 2);
+      pstmt.addBatch();
+      pstmt.setInt(1, 3);
+      pstmt.setString(2, "b");
+      pstmt.setInt(3, 4);
+      pstmt.addBatch();
+      pstmt.setInt(1, 5);
+      pstmt.setString(2, "c");
+      pstmt.setInt(3, 6);
+      pstmt.addBatch();
+      BatchExecuteTest.assertSimpleInsertBatch(3, pstmt.executeBatch());
+    } finally {
+      TestUtil.closeQuietly(pstmt);
+    }
+  }
+
+  /**
+   * Test to make sure a statement with a semicolon is not broken
+   */
+  @Test
+  public void testMultiValues1bind()
+      throws SQLException {
+    PreparedStatement pstmt = null;
+    try {
+      pstmt = con.prepareStatement("INSERT INTO testbatch (pk) VALUES (?), (?)");
+      pstmt.setInt(1, 100);
+      pstmt.setInt(2, 200);
+      pstmt.addBatch();
+      pstmt.setInt(1, 300);
+      pstmt.setInt(2, 400);
+      pstmt.addBatch();
+      BatchExecuteTest.assertSimpleInsertBatch(2, pstmt.executeBatch());
+    } finally {
+      TestUtil.closeQuietly(pstmt);
+    }
+  }
+
+  /**
+   * Test case to check the outcome for a batch with a single row/batch is
+   * consistent across calls to executeBatch. Especially after a batch
+   * has been re-written.
+   */
+  @Test
+  public void testConsistentOutcome() throws SQLException {
+    PreparedStatement pstmt = null;
+    try {
+      pstmt = con.prepareStatement("INSERT INTO testbatch VALUES (?,?,?);");
+      pstmt.setInt(1, 1);
+      pstmt.setString(2, "a");
+      pstmt.setInt(3, 2);
+      pstmt.addBatch();
+      BatchExecuteTest.assertSimpleInsertBatch(1, pstmt.executeBatch());
+
+      pstmt.setInt(1, 1);
+      pstmt.setString(2, "b");
+      pstmt.setInt(3, 2);
+      pstmt.addBatch();
+      pstmt.setInt(1, 3);
+      pstmt.setString(2, "c");
+      pstmt.setInt(3, 4);
+      pstmt.addBatch();
+      BatchExecuteTest.assertSimpleInsertBatch(2, pstmt.executeBatch());
+
+      pstmt.setInt(1, 1);
+      pstmt.setString(2, "d");
+      pstmt.setInt(3, 2);
+      pstmt.addBatch();
+      BatchExecuteTest.assertSimpleInsertBatch(1, pstmt.executeBatch());
+    } finally {
+      TestUtil.closeQuietly(pstmt);
+    }
+  }
+
+  /**
+   * Test to check statement with named columns still work as expected.
+   */
+  @Test
+  public void testINSERTwithNamedColumnsNotBroken() throws SQLException {
+    PreparedStatement pstmt = null;
+    try {
+      pstmt = con
+          .prepareStatement("INSERT INTO testbatch (pk, col1, col2) VALUES (?,?,?);");
+      pstmt.setInt(1, 1);
+      pstmt.setString(2, "a");
+      pstmt.setInt(3, 2);
+      pstmt.addBatch();
+      BatchExecuteTest.assertSimpleInsertBatch(1, pstmt.executeBatch());
+    } finally {
+      TestUtil.closeQuietly(pstmt);
+    }
+  }
+
+  @Test
+  public void testMixedCaseInSeRtStatement() throws SQLException {
+    PreparedStatement pstmt = null;
+    try {
+      pstmt = con.prepareStatement("InSeRt INTO testbatch VALUES (?,?,?);");
+      pstmt.setInt(1, 1);
+      pstmt.setString(2, "a");
+      pstmt.setInt(3, 2);
+      pstmt.addBatch();
+      pstmt.setInt(1, 3);
+      pstmt.setString(2, "b");
+      pstmt.setInt(3, 4);
+      pstmt.addBatch();
+      BatchExecuteTest.assertSimpleInsertBatch(2, pstmt.executeBatch());
+    } finally {
+      TestUtil.closeQuietly(pstmt);
+    }
+  }
+
+  @Test
+  public void testReWriteDisabledForPlainBatch() throws Exception {
+    Statement stmt = null;
+    try {
+      con = TestUtil.openDB(new Properties());
+      stmt = con.createStatement();
+      stmt.addBatch("INSERT INTO testbatch VALUES (100,'a',200);");
+      stmt.addBatch("INSERT INTO testbatch VALUES (300,'b',400);");
+      Assert.assertEquals(
+          "Expected outcome not returned by batch execution. The driver"
+              + " allowed re-write in combination with plain statements.",
+          Arrays.toString(new int[]{1, 1}), Arrays.toString(stmt.executeBatch()));
+    } finally {
+      TestUtil.closeQuietly(stmt);
+    }
+  }
+
+  @Test
+  public void test32000Binds() throws Exception {
+    testNBinds(32000);
+  }
+
+  @Test
+  public void test17000Binds() throws Exception {
+    testNBinds(17000);
+  }
+
+  public void testNBinds(int nBinds) throws Exception {
+    PreparedStatement pstmt = null;
+    try {
+      StringBuilder sb = new StringBuilder();
+      sb.append("INSERT INTO testbatch(pk) VALUES (coalesce(?");
+      for (int i = 0; i < nBinds - 1 /* note one ? above */; i++) {
+        sb.append(",?");
+      }
+      sb.append("))");
+      pstmt = con.prepareStatement(sb.toString());
+      for (int k = 0; k < 2; k++) {
+        for (int i = 1; i <= nBinds; i++) {
+          pstmt.setInt(i, i + k * nBinds);
+        }
+        pstmt.addBatch();
+      }
+      Assert.assertEquals(
+          "Statement with " + nBinds
+              + " binds should not be batched => two executions with exactly one row inserted each",
+          Arrays.toString(new int[] { 1, 1 }),
+          Arrays.toString(pstmt.executeBatch()));
+    } catch (BatchUpdateException be) {
+      SQLException e = be;
+      while (true) {
+        e.printStackTrace();
+        SQLException next = e.getNextException();
+        if (next == null) {
+          break;
+        }
+        e = next;
+      }
+      throw e;
+    } finally {
+      TestUtil.closeQuietly(pstmt);
+    }
+  }
+}
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BlobTransactionTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BlobTransactionTest.java
index 023af6c6d0..13b9e6a8dd 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BlobTransactionTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BlobTransactionTest.java
@@ -48,13 +48,12 @@ protected void setUp() throws Exception {
 
     String sql;
 
-    Statement st;
     /*
      * this would have to be executed using the postgres user in order to get access to a C function
      *
      */
     Connection privilegedCon = TestUtil.openPrivilegedDB();
-    st = privilegedCon.createStatement();
+    Statement st = privilegedCon.createStatement();
     try {
       sql =
           "CREATE OR REPLACE FUNCTION lo_manage() RETURNS pg_catalog.trigger AS '$libdir/lo' LANGUAGE C";
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ConnectTimeoutTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ConnectTimeoutTest.java
index 20620e1ef2..8d315bd731 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ConnectTimeoutTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ConnectTimeoutTest.java
@@ -2,7 +2,6 @@
 
 import org.postgresql.test.TestUtil;
 
-import junit.framework.Assert;
 import junit.framework.TestCase;
 
 import java.net.SocketTimeoutException;
@@ -11,9 +10,10 @@
 import java.util.Properties;
 
 public class ConnectTimeoutTest extends TestCase {
-  private static final String UNREACHABLE_HOST = "1.0.0.0";
-  private static final String UNREACHABLE_URL = "jdbc:postgresql://" + UNREACHABLE_HOST + "/test";
-  private static final int CONNECT_TIMEOUT = 10;
+  // The IP below is non-routable (see http://stackoverflow.com/a/904609/1261287)
+  private static final String UNREACHABLE_HOST = "10.255.255.1";
+  private static final String UNREACHABLE_URL = "jdbc:postgresql://" + UNREACHABLE_HOST + ":5432/test";
+  private static final int CONNECT_TIMEOUT = 5;
 
   @Override
   protected void setUp() throws Exception {
@@ -32,13 +32,13 @@ public void testTimeout() {
     try {
       DriverManager.getConnection(UNREACHABLE_URL, props);
     } catch (SQLException e) {
-      Assert.assertTrue("Unexpected " + e.toString(),
+      assertTrue("Unexpected " + e.toString(),
           e.getCause() instanceof SocketTimeoutException);
       final long interval = System.currentTimeMillis() - startTime;
       final long connectTimeoutMillis = CONNECT_TIMEOUT * 1000;
       final long maxDeviation = connectTimeoutMillis / 10;
       // check that it was not a default system timeout, an approximate value is used
-      Assert.assertTrue(Math.abs(interval - connectTimeoutMillis) < maxDeviation);
+      assertTrue(Math.abs(interval - connectTimeoutMillis) < maxDeviation);
       return;
     }
     fail("SQLException expected");
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/CopyLargeFileTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/CopyLargeFileTest.java
index 9f67a5b2a2..4bd4d2cc35 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/CopyLargeFileTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/CopyLargeFileTest.java
@@ -28,7 +28,6 @@ public class CopyLargeFileTest extends TestCase {
 
 
   protected void setUp() throws Exception {
-
     super.setUp();
 
     con = TestUtil.openDB();
@@ -49,9 +48,8 @@ protected void setUp() throws Exception {
   private void feedTable() throws Exception {
     PreparedStatement stmt = con.prepareStatement(
         TestUtil.insertSQL("pgjdbc_issue366_test_glossary", "text_id, name", "?, ?"));
-    char ch = ' ';
     for (int i = 0; i < 26; i++) {
-      ch = (char) ('A' + i); // black magic
+      char ch = (char) ('A' + i); // black magic
       insertData(stmt, "VERY_LONG_STRING_TO_REPRODUCE_ISSUE_366_" + ch + ch + ch,
           "" + ch + ch + ch);
     }
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/CopyTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/CopyTest.java
index 875defdfa7..fe3a86e8ac 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/CopyTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/CopyTest.java
@@ -55,15 +55,13 @@ public CopyTest(String name) {
   private byte[] getData(String[] origData) {
     ByteArrayOutputStream buf = new ByteArrayOutputStream();
     PrintStream ps = new PrintStream(buf);
-    for (int i = 0; i < origData.length; i++) {
-      ps.print(origData[i]);
+    for (String anOrigData : origData) {
+      ps.print(anOrigData);
     }
     return buf.toByteArray();
   }
 
   protected void setUp() throws Exception {
-
-
     con = TestUtil.openDB();
 
     TestUtil.createTable(con, "copytest", "stringvalue text, intvalue int, numvalue numeric(5,2)");
@@ -154,7 +152,7 @@ public int read() {
         }
       }, 3);
     } catch (Exception e) {
-      if (e.toString().indexOf("COPYTEST") == -1) {
+      if (!e.toString().contains("COPYTEST")) {
         fail("should have failed trying to read from our bogus stream.");
       }
     }
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/CursorFetchTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/CursorFetchTest.java
index e456aa46aa..92ce9ed00d 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/CursorFetchTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/CursorFetchTest.java
@@ -53,20 +53,20 @@ public void testBasicFetch() throws Exception {
 
     PreparedStatement stmt = con.prepareStatement("select * from test_fetch order by value");
     int[] testSizes = {0, 1, 49, 50, 51, 99, 100, 101};
-    for (int i = 0; i < testSizes.length; ++i) {
-      stmt.setFetchSize(testSizes[i]);
-      assertEquals(testSizes[i], stmt.getFetchSize());
+    for (int testSize : testSizes) {
+      stmt.setFetchSize(testSize);
+      assertEquals(testSize, stmt.getFetchSize());
 
       ResultSet rs = stmt.executeQuery();
-      assertEquals(testSizes[i], rs.getFetchSize());
+      assertEquals(testSize, rs.getFetchSize());
 
       int count = 0;
       while (rs.next()) {
-        assertEquals("query value error with fetch size " + testSizes[i], count, rs.getInt(1));
+        assertEquals("query value error with fetch size " + testSize, count, rs.getInt(1));
         ++count;
       }
 
-      assertEquals("total query size error with fetch size " + testSizes[i], 100, count);
+      assertEquals("total query size error with fetch size " + testSize, 100, count);
     }
   }
 
@@ -79,17 +79,16 @@ public void testScrollableFetch() throws Exception {
         ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
 
     int[] testSizes = {0, 1, 49, 50, 51, 99, 100, 101};
-    for (int i = 0; i < testSizes.length; ++i) {
-      stmt.setFetchSize(testSizes[i]);
-      assertEquals(testSizes[i], stmt.getFetchSize());
+    for (int testSize : testSizes) {
+      stmt.setFetchSize(testSize);
+      assertEquals(testSize, stmt.getFetchSize());
 
       ResultSet rs = stmt.executeQuery();
-      assertEquals(testSizes[i], rs.getFetchSize());
+      assertEquals(testSize, rs.getFetchSize());
 
       for (int j = 0; j <= 50; ++j) {
-        assertTrue("ran out of rows at position " + j + " with fetch size " + testSizes[i],
-            rs.next());
-        assertEquals("query value error with fetch size " + testSizes[i], j, rs.getInt(1));
+        assertTrue("ran out of rows at position " + j + " with fetch size " + testSize, rs.next());
+        assertEquals("query value error with fetch size " + testSize, j, rs.getInt(1));
       }
 
       int position = 50;
@@ -98,17 +97,17 @@ public void testScrollableFetch() throws Exception {
           if (j % 2 == 0) {
             ++position;
             assertTrue("ran out of rows doing a forward fetch on iteration " + j + "/" + k
-                + " at position " + position + " with fetch size " + testSizes[i], rs.next());
+                + " at position " + position + " with fetch size " + testSize, rs.next());
           } else {
             --position;
             assertTrue(
                 "ran out of rows doing a reverse fetch on iteration " + j + "/" + k
-                    + " at position " + position + " with fetch size " + testSizes[i],
+                    + " at position " + position + " with fetch size " + testSize,
                 rs.previous());
           }
 
           assertEquals(
-              "query value error on iteration " + j + "/" + k + " with fetch size " + testSizes[i],
+              "query value error on iteration " + j + "/" + k + " with fetch size " + testSize,
               position, rs.getInt(1));
         }
       }
@@ -122,17 +121,17 @@ public void testScrollableAbsoluteFetch() throws Exception {
         ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
 
     int[] testSizes = {0, 1, 49, 50, 51, 99, 100, 101};
-    for (int i = 0; i < testSizes.length; ++i) {
-      stmt.setFetchSize(testSizes[i]);
-      assertEquals(testSizes[i], stmt.getFetchSize());
+    for (int testSize : testSizes) {
+      stmt.setFetchSize(testSize);
+      assertEquals(testSize, stmt.getFetchSize());
 
       ResultSet rs = stmt.executeQuery();
-      assertEquals(testSizes[i], rs.getFetchSize());
+      assertEquals(testSize, rs.getFetchSize());
 
       int position = 50;
       assertTrue("ran out of rows doing an absolute fetch at " + position + " with fetch size "
-          + testSizes[i], rs.absolute(position + 1));
-      assertEquals("query value error with fetch size " + testSizes[i], position, rs.getInt(1));
+          + testSize, rs.absolute(position + 1));
+      assertEquals("query value error with fetch size " + testSize, position, rs.getInt(1));
 
       for (int j = 1; j < 100; ++j) {
         if (j % 2 == 0) {
@@ -142,8 +141,8 @@ public void testScrollableAbsoluteFetch() throws Exception {
         }
 
         assertTrue("ran out of rows doing an absolute fetch at " + position + " on iteration " + j
-            + " with fetchsize" + testSizes[i], rs.absolute(position + 1));
-        assertEquals("query value error with fetch size " + testSizes[i], position, rs.getInt(1));
+            + " with fetchsize" + testSize, rs.absolute(position + 1));
+        assertEquals("query value error with fetch size " + testSize, position, rs.getInt(1));
       }
     }
   }
@@ -258,20 +257,20 @@ public void testSingleRowResultPositioning() throws Exception {
     createRows(1);
 
     int[] sizes = {0, 1, 10};
-    for (int i = 0; i < sizes.length; ++i) {
+    for (int size : sizes) {
       Statement stmt = con.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
-      stmt.setFetchSize(sizes[i]);
+      stmt.setFetchSize(size);
 
       // Create a one row result set.
       ResultSet rs = stmt.executeQuery("select * from test_fetch order by value");
 
-      msg = "before-first row positioning error with fetchsize=" + sizes[i];
+      msg = "before-first row positioning error with fetchsize=" + size;
       assertTrue(msg, rs.isBeforeFirst());
       assertTrue(msg, !rs.isAfterLast());
       assertTrue(msg, !rs.isFirst());
       assertTrue(msg, !rs.isLast());
 
-      msg = "row 1 positioning error with fetchsize=" + sizes[i];
+      msg = "row 1 positioning error with fetchsize=" + size;
       assertTrue(msg, rs.next());
 
       assertTrue(msg, !rs.isBeforeFirst());
@@ -280,7 +279,7 @@ public void testSingleRowResultPositioning() throws Exception {
       assertTrue(msg, rs.isLast());
       assertEquals(msg, 0, rs.getInt(1));
 
-      msg = "after-last row positioning error with fetchsize=" + sizes[i];
+      msg = "after-last row positioning error with fetchsize=" + size;
       assertTrue(msg, !rs.next());
 
       assertTrue(msg, !rs.isBeforeFirst());
@@ -299,19 +298,19 @@ public void testMultiRowResultPositioning() throws Exception {
     createRows(100);
 
     int[] sizes = {0, 1, 10, 100};
-    for (int i = 0; i < sizes.length; ++i) {
+    for (int size : sizes) {
       Statement stmt = con.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
-      stmt.setFetchSize(sizes[i]);
+      stmt.setFetchSize(size);
 
       ResultSet rs = stmt.executeQuery("select * from test_fetch order by value");
-      msg = "before-first row positioning error with fetchsize=" + sizes[i];
+      msg = "before-first row positioning error with fetchsize=" + size;
       assertTrue(msg, rs.isBeforeFirst());
       assertTrue(msg, !rs.isAfterLast());
       assertTrue(msg, !rs.isFirst());
       assertTrue(msg, !rs.isLast());
 
       for (int j = 0; j < 100; ++j) {
-        msg = "row " + j + " positioning error with fetchsize=" + sizes[i];
+        msg = "row " + j + " positioning error with fetchsize=" + size;
         assertTrue(msg, rs.next());
         assertEquals(msg, j, rs.getInt(1));
 
@@ -330,7 +329,7 @@ public void testMultiRowResultPositioning() throws Exception {
         }
       }
 
-      msg = "after-last row positioning error with fetchsize=" + sizes[i];
+      msg = "after-last row positioning error with fetchsize=" + size;
       assertTrue(msg, !rs.next());
 
       assertTrue(msg, !rs.isBeforeFirst());
@@ -411,18 +410,18 @@ public void testRowResultPositioningWithoutIsLast() throws Exception {
     createRows(rowCount);
 
     int[] sizes = {1, 2, 3, 4, 5};
-    for (int i = 0; i < sizes.length; ++i) {
+    for (int size : sizes) {
       Statement stmt = con.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
-      stmt.setFetchSize(sizes[i]);
+      stmt.setFetchSize(size);
 
       ResultSet rs = stmt.executeQuery("select * from test_fetch order by value");
-      msg = "before-first row positioning error with fetchsize=" + sizes[i];
+      msg = "before-first row positioning error with fetchsize=" + size;
       assertTrue(msg, rs.isBeforeFirst());
       assertTrue(msg, !rs.isAfterLast());
       assertTrue(msg, !rs.isFirst());
 
       for (int j = 0; j < rowCount; ++j) {
-        msg = "row " + j + " positioning error with fetchsize=" + sizes[i];
+        msg = "row " + j + " positioning error with fetchsize=" + size;
         assertTrue(msg, rs.next());
         assertEquals(msg, j, rs.getInt(1));
 
@@ -435,7 +434,7 @@ public void testRowResultPositioningWithoutIsLast() throws Exception {
         }
       }
 
-      msg = "after-last row positioning error with fetchsize=" + sizes[i];
+      msg = "after-last row positioning error with fetchsize=" + size;
       assertTrue(msg, !rs.next());
 
       assertTrue(msg, !rs.isBeforeFirst());
@@ -454,12 +453,12 @@ public void testNoRowResultPositioning() throws Exception {
     String msg;
 
     int[] sizes = {0, 1, 50, 100};
-    for (int i = 0; i < sizes.length; ++i) {
+    for (int size : sizes) {
       Statement stmt = con.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
-      stmt.setFetchSize(sizes[i]);
+      stmt.setFetchSize(size);
 
       ResultSet rs = stmt.executeQuery("select * from test_fetch order by value");
-      msg = "no row (empty resultset) positioning error with fetchsize=" + sizes[i];
+      msg = "no row (empty resultset) positioning error with fetchsize=" + size;
       assertTrue(msg, !rs.isBeforeFirst());
       assertTrue(msg, !rs.isAfterLast());
       assertTrue(msg, !rs.isFirst());
@@ -481,13 +480,13 @@ public void testScrollableNoRowResultPositioning() throws Exception {
     String msg;
 
     int[] sizes = {0, 1, 50, 100};
-    for (int i = 0; i < sizes.length; ++i) {
+    for (int size : sizes) {
       Statement stmt =
           con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
-      stmt.setFetchSize(sizes[i]);
+      stmt.setFetchSize(size);
 
       ResultSet rs = stmt.executeQuery("select * from test_fetch order by value");
-      msg = "no row (empty resultset) positioning error with fetchsize=" + sizes[i];
+      msg = "no row (empty resultset) positioning error with fetchsize=" + size;
       assertTrue(msg, !rs.isBeforeFirst());
       assertTrue(msg, !rs.isAfterLast());
       assertTrue(msg, !rs.isFirst());
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/DatabaseMetaDataTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/DatabaseMetaDataTest.java
index dca5742ac9..0813878728 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/DatabaseMetaDataTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/DatabaseMetaDataTest.java
@@ -50,6 +50,10 @@ protected void setUp() throws Exception {
     TestUtil.createTable(con, "\"a\\\"", "a int4");
     TestUtil.createTable(con, "\"a'\"", "a int4");
     TestUtil.createTable(con, "arraytable", "a numeric(5,2)[], b varchar(100)[]");
+    TestUtil.createTable(con, "intarraytable", "a int4[], b int4[][]");
+    TestUtil.createCompositeType(con, "custom", "i int");
+    TestUtil.createCompositeType(con, "_custom", "f float");
+    TestUtil.createTable(con, "customtable", "c1 custom, c2 _custom, c3 custom[], c4 _custom[]");
 
     Statement stmt = con.createStatement();
     // we add the following comments to ensure the joins to the comments
@@ -73,8 +77,8 @@ protected void setUp() throws Exception {
         "CREATE OR REPLACE FUNCTION f5() RETURNS TABLE (i int) LANGUAGE sql AS 'SELECT 1'");
 
     if (TestUtil.haveMinimumServerVersion(con, "7.3")) {
-      stmt.execute("CREATE DOMAIN nndom AS int not null");
-      stmt.execute("CREATE TABLE domaintable (id nndom)");
+      TestUtil.createDomain(con, "nndom", "int not null");
+      TestUtil.createTable(con, "domaintable", "id nndom");
     }
     stmt.close();
   }
@@ -92,6 +96,10 @@ protected void tearDown() throws Exception {
     TestUtil.dropTable(con, "\"a\\\"");
     TestUtil.dropTable(con, "\"a'\"");
     TestUtil.dropTable(con, "arraytable");
+    TestUtil.dropTable(con, "intarraytable");
+    TestUtil.dropTable(con, "customtable");
+    TestUtil.dropType(con, "custom");
+    TestUtil.dropType(con, "_custom");
 
     stmt.execute("DROP FUNCTION f1(int, varchar)");
     if (TestUtil.haveMinimumServerVersion(con, "8.0")) {
@@ -101,13 +109,60 @@ protected void tearDown() throws Exception {
       stmt.execute("DROP FUNCTION f3(int, varchar)");
     }
     if (TestUtil.haveMinimumServerVersion(con, "7.3")) {
-      stmt.execute("DROP TABLE domaintable");
-      stmt.execute("DROP DOMAIN nndom");
+      TestUtil.dropType(con, "domaintable");
+      TestUtil.dropDomain(con, "nndom");
     }
 
     TestUtil.closeDB(con);
   }
 
+  public void testArrayTypeInfo() throws SQLException {
+    DatabaseMetaData dbmd = con.getMetaData();
+    ResultSet rs = dbmd.getColumns(null, null, "intarraytable", "a");
+    assertTrue(rs.next());
+    assertEquals("_int4", rs.getString("TYPE_NAME"));
+    con.createArrayOf("integer", new Integer[] {});
+    TestUtil.closeQuietly(rs);
+    rs = dbmd.getColumns(null, null, "intarraytable", "a");
+    assertTrue(rs.next());
+    assertEquals("_int4", rs.getString("TYPE_NAME"));
+    TestUtil.closeQuietly(rs);
+  }
+
+  public void testArrayInt4DoubleDim() throws SQLException {
+    DatabaseMetaData dbmd = con.getMetaData();
+    ResultSet rs = dbmd.getColumns(null, null, "intarraytable", "b");
+    assertTrue(rs.next());
+    assertEquals("_int4", rs.getString("TYPE_NAME")); // even int4[][] is represented as _int4
+    con.createArrayOf("int4", new int[][]{{1, 2}, {3, 4}});
+    rs = dbmd.getColumns(null, null, "intarraytable", "b");
+    assertTrue(rs.next());
+    assertEquals("_int4", rs.getString("TYPE_NAME")); // even int4[][] is represented as _int4
+  }
+
+  public void testCustomArrayTypeInfo() throws SQLException {
+    DatabaseMetaData dbmd = con.getMetaData();
+    ResultSet res = dbmd.getColumns(null, null, "customtable", null);
+    assertTrue(res.next());
+    assertEquals("custom", res.getString("TYPE_NAME"));
+    assertTrue(res.next());
+    assertEquals("_custom", res.getString("TYPE_NAME"));
+    assertTrue(res.next());
+    assertEquals("__custom", res.getString("TYPE_NAME"));
+    assertTrue(res.next());
+    assertEquals("___custom", res.getString("TYPE_NAME"));
+    con.createArrayOf("custom", new Object[] {});
+    res = dbmd.getColumns(null, null, "customtable", null);
+    assertTrue(res.next());
+    assertEquals("custom", res.getString("TYPE_NAME"));
+    assertTrue(res.next());
+    assertEquals("_custom", res.getString("TYPE_NAME"));
+    assertTrue(res.next());
+    assertEquals("__custom", res.getString("TYPE_NAME"));
+    assertTrue(res.next());
+    assertEquals("___custom", res.getString("TYPE_NAME"));
+  }
+
   public void testTables() throws Exception {
     DatabaseMetaData dbmd = con.getMetaData();
     assertNotNull(dbmd);
@@ -590,6 +645,7 @@ public void testAscDescIndexInfo() throws SQLException {
     assertEquals("id", rs.getString("COLUMN_NAME"));
     assertEquals("A", rs.getString("ASC_OR_DESC"));
 
+
     assertTrue(rs.next());
     assertEquals("idx_a_d", rs.getString("INDEX_NAME"));
     assertEquals("quest", rs.getString("COLUMN_NAME"));
@@ -865,8 +921,8 @@ public void testGetUDTQualified() throws Exception {
       dataType = rs.getInt("data_type");
       remarks = rs.getString("remarks");
       baseType = rs.getInt("base_type");
-      this.assertEquals("type name ", "testint8", typeName);
-      this.assertEquals("schema name ", "jdbc", schema);
+      assertEquals("type name ", "testint8", typeName);
+      assertEquals("schema name ", "jdbc", schema);
 
       // now test to see if the fully qualified stuff works as planned
       rs = dbmd.getUDTs("catalog", "public", "catalog.jdbc.testint8", null);
@@ -878,8 +934,8 @@ public void testGetUDTQualified() throws Exception {
       dataType = rs.getInt("data_type");
       remarks = rs.getString("remarks");
       baseType = rs.getInt("base_type");
-      this.assertEquals("type name ", "testint8", typeName);
-      this.assertEquals("schema name ", "jdbc", schema);
+      assertEquals("type name ", "testint8", typeName);
+      assertEquals("schema name ", "jdbc", schema);
     } finally {
       try {
         if (stmt != null) {
@@ -922,10 +978,10 @@ public void testGetUDT1() throws Exception {
       remarks = rs.getString("remarks");
 
       baseType = rs.getInt("base_type");
-      this.assertTrue("base type", !rs.wasNull());
-      this.assertEquals("data type", Types.DISTINCT, dataType);
-      this.assertEquals("type name ", "testint8", typeName);
-      this.assertEquals("remarks", "jdbc123", remarks);
+      assertTrue("base type", !rs.wasNull());
+      assertEquals("data type", Types.DISTINCT, dataType);
+      assertEquals("type name ", "testint8", typeName);
+      assertEquals("remarks", "jdbc123", remarks);
 
     } finally {
       try {
@@ -965,10 +1021,10 @@ public void testGetUDT2() throws Exception {
       remarks = rs.getString("remarks");
 
       baseType = rs.getInt("base_type");
-      this.assertTrue("base type", !rs.wasNull());
-      this.assertEquals("data type", Types.DISTINCT, dataType);
-      this.assertEquals("type name ", "testint8", typeName);
-      this.assertEquals("remarks", "jdbc123", remarks);
+      assertTrue("base type", !rs.wasNull());
+      assertEquals("data type", Types.DISTINCT, dataType);
+      assertEquals("type name ", "testint8", typeName);
+      assertEquals("remarks", "jdbc123", remarks);
 
     } finally {
       try {
@@ -1007,10 +1063,10 @@ public void testGetUDT3() throws Exception {
       remarks = rs.getString("remarks");
 
       baseType = rs.getInt("base_type");
-      this.assertTrue("base type", !rs.wasNull());
-      this.assertEquals("data type", Types.DISTINCT, dataType);
-      this.assertEquals("type name ", "testint8", typeName);
-      this.assertEquals("remarks", "jdbc123", remarks);
+      assertTrue("base type", !rs.wasNull());
+      assertEquals("data type", Types.DISTINCT, dataType);
+      assertEquals("type name ", "testint8", typeName);
+      assertEquals("remarks", "jdbc123", remarks);
 
     } finally {
       try {
@@ -1048,9 +1104,9 @@ public void testGetUDT4() throws Exception {
       remarks = rs.getString("remarks");
 
       baseType = rs.getInt("base_type");
-      this.assertTrue("base type", rs.wasNull());
-      this.assertEquals("data type", Types.STRUCT, dataType);
-      this.assertEquals("type name ", "testint8", typeName);
+      assertTrue("base type", rs.wasNull());
+      assertEquals("data type", Types.STRUCT, dataType);
+      assertEquals("type name ", "testint8", typeName);
 
     } finally {
       try {
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/DriverTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/DriverTest.java
index 3441bf78f6..16b03ac592 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/DriverTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/DriverTest.java
@@ -69,9 +69,9 @@ private void verifyUrl(Driver drv, String url, String hosts, String ports, Strin
       throws Exception {
     assertTrue(url, drv.acceptsURL(url));
     Method parseMethod =
-        drv.getClass().getDeclaredMethod("parseURL", new Class[]{String.class, Properties.class});
+        drv.getClass().getDeclaredMethod("parseURL", String.class, Properties.class);
     parseMethod.setAccessible(true);
-    Properties p = (Properties) parseMethod.invoke(drv, new Object[]{url, null});
+    Properties p = (Properties) parseMethod.invoke(drv, url, null);
     assertEquals(url, dbName, p.getProperty("PGDBNAME"));
     assertEquals(url, hosts, p.getProperty("PGHOST"));
     assertEquals(url, ports, p.getProperty("PGPORT"));
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/EncodingTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/EncodingTest.java
index dfac7a87ab..a9101ea653 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/EncodingTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/EncodingTest.java
@@ -30,11 +30,10 @@ public EncodingTest(String name) {
   }
 
   public void testCreation() throws Exception {
-    Encoding encoding;
-    encoding = Encoding.getDatabaseEncoding("UTF8");
+    Encoding encoding = Encoding.getDatabaseEncoding("UTF8");
     assertEquals("UTF", encoding.name().substring(0, 3).toUpperCase(Locale.US));
     encoding = Encoding.getDatabaseEncoding("SQL_ASCII");
-    assertTrue(encoding.name().toUpperCase(Locale.US).indexOf("ASCII") != -1);
+    assertTrue(encoding.name().toUpperCase(Locale.US).contains("ASCII"));
     assertEquals("When encoding is unknown the default encoding should be used",
         Encoding.defaultEncoding(), Encoding.getDatabaseEncoding("UNKNOWN"));
   }
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/GeometricTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/GeometricTest.java
index 91dda13835..f1c78fc9df 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/GeometricTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/GeometricTest.java
@@ -125,9 +125,9 @@ public void testPGline() throws Exception {
       if (roundTripToDatabase) {
         try {
           checkReadWrite(new PGline(), columnName);
-          fail("Expected a PGSQLException to be thrown");
+          fail("Expected a PSQLException to be thrown");
         } catch (PSQLException e) {
-          assertTrue(e.getMessage().contains("A and B cannot both be zero"));
+          assertEquals("22P02", e.getSQLState());
         }
       }
 
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/GetXXXTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/GetXXXTest.java
index 4ea4a3b7ac..ea3ca12530 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/GetXXXTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/GetXXXTest.java
@@ -57,7 +57,7 @@ public void testGetObject() throws SQLException {
     Statement stmt = con.createStatement();
     ResultSet rs = stmt.executeQuery("select (final-initial) as diff from test_interval");
     while (rs.next()) {
-      String str = (String) rs.getString(1);
+      String str = rs.getString(1);
 
       assertNotNull(str);
       Object obj = rs.getObject(1);
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/Jdbc2TestSuite.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/Jdbc2TestSuite.java
index cbd042b55b..1dcc325e42 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/Jdbc2TestSuite.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/Jdbc2TestSuite.java
@@ -8,8 +8,12 @@
 
 package org.postgresql.test.jdbc2;
 
+import org.postgresql.core.v2.V2ParameterListTests;
+import org.postgresql.core.v3.V3ParameterListTests;
+import org.postgresql.jdbc.DeepBatchedInsertStatementTest;
 import org.postgresql.test.CursorFetchBinaryTest;
 import org.postgresql.test.TestUtil;
+import org.postgresql.test.core.NativeQueryBindLengthTest;
 
 import junit.framework.JUnit4TestAdapter;
 import junit.framework.TestSuite;
@@ -49,6 +53,8 @@ public static TestSuite suite() throws Exception {
 
     // Connectivity/Protocols
 
+    suite.addTest(new JUnit4TestAdapter(TypeCacheDLLStressTest.class));
+
     // ResultSet
     suite.addTestSuite(ResultSetTest.class);
     suite.addTestSuite(ResultSetMetaDataTest.class);
@@ -62,6 +68,7 @@ public static TestSuite suite() throws Exception {
     suite.addTestSuite(TimezoneTest.class);
     suite.addTestSuite(PGTimeTest.class);
     suite.addTestSuite(PGTimestampTest.class);
+    suite.addTest(new JUnit4TestAdapter(TimezoneCachingTest.class));
 
     // PreparedStatement
     suite.addTestSuite(PreparedStatementTest.class);
@@ -73,10 +80,12 @@ public static TestSuite suite() throws Exception {
     suite.addTestSuite(ServerPreparedStmtTest.class);
 
     // BatchExecute
-    suite.addTestSuite(BatchExecuteTest.class);
-    suite.addTestSuite(BatchExecuteBinaryTest.class);
+    suite.addTest(new JUnit4TestAdapter(BatchExecuteTest.class));
     suite.addTest(new JUnit4TestAdapter(BatchFailureTest.class));
 
+    suite.addTest(new JUnit4TestAdapter(BatchedInsertReWriteEnabledTest.class));
+    suite.addTest(new JUnit4TestAdapter(NativeQueryBindLengthTest.class));
+    suite.addTestSuite(DeepBatchedInsertStatementTest.class);
 
     // Other misc tests, based on previous problems users have had or specific
     // features some applications require.
@@ -107,6 +116,9 @@ public static TestSuite suite() throws Exception {
 
     suite.addTestSuite(PGPropertyTest.class);
 
+    suite.addTestSuite(V2ParameterListTests.class);
+    suite.addTestSuite(V3ParameterListTests.class);
+
     Connection conn = TestUtil.openDB();
     if (TestUtil.isProtocolVersion(conn, 3)) {
       suite.addTestSuite(CopyTest.class);
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/LoginTimeoutTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/LoginTimeoutTest.java
index 9c59a2e8dc..79fd8074d8 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/LoginTimeoutTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/LoginTimeoutTest.java
@@ -16,7 +16,9 @@
 import java.net.InetAddress;
 import java.net.ServerSocket;
 import java.net.Socket;
+import java.net.UnknownHostException;
 import java.sql.Connection;
+import java.sql.DriverManager;
 import java.sql.SQLException;
 import java.util.Properties;
 
@@ -35,7 +37,7 @@ public void testIntTimeout() throws Exception {
     props.setProperty("password", TestUtil.getPassword());
     props.setProperty("loginTimeout", "10");
 
-    Connection conn = java.sql.DriverManager.getConnection(TestUtil.getURL(), props);
+    Connection conn = DriverManager.getConnection(TestUtil.getURL(), props);
     conn.close();
   }
 
@@ -45,7 +47,7 @@ public void testFloatTimeout() throws Exception {
     props.setProperty("password", TestUtil.getPassword());
     props.setProperty("loginTimeout", "10.0");
 
-    Connection conn = java.sql.DriverManager.getConnection(TestUtil.getURL(), props);
+    Connection conn = DriverManager.getConnection(TestUtil.getURL(), props);
     conn.close();
   }
 
@@ -55,7 +57,7 @@ public void testZeroTimeout() throws Exception {
     props.setProperty("password", TestUtil.getPassword());
     props.setProperty("loginTimeout", "0");
 
-    Connection conn = java.sql.DriverManager.getConnection(TestUtil.getURL(), props);
+    Connection conn = DriverManager.getConnection(TestUtil.getURL(), props);
     conn.close();
   }
 
@@ -65,7 +67,7 @@ public void testNegativeTimeout() throws Exception {
     props.setProperty("password", TestUtil.getPassword());
     props.setProperty("loginTimeout", "-1");
 
-    Connection conn = java.sql.DriverManager.getConnection(TestUtil.getURL(), props);
+    Connection conn = DriverManager.getConnection(TestUtil.getURL(), props);
     conn.close();
   }
 
@@ -75,7 +77,7 @@ public void testBadTimeout() throws Exception {
     props.setProperty("password", TestUtil.getPassword());
     props.setProperty("loginTimeout", "zzzz");
 
-    Connection conn = java.sql.DriverManager.getConnection(TestUtil.getURL(), props);
+    Connection conn = DriverManager.getConnection(TestUtil.getURL(), props);
     conn.close();
   }
 
@@ -84,7 +86,7 @@ private static class TimeoutHelper implements Runnable {
       InetAddress localAddr;
       try {
         localAddr = InetAddress.getLocalHost();
-      } catch (java.net.UnknownHostException ex) {
+      } catch (UnknownHostException ex) {
         System.err.println("WARNING: Could not resolve local host name, trying 'localhost'. " + ex);
         localAddr = InetAddress.getByName("localhost");
       }
@@ -141,7 +143,7 @@ public void testTimeoutOccurs() throws Exception {
       long startTime = System.currentTimeMillis();
       Connection conn = null;
       try {
-        conn = java.sql.DriverManager.getConnection(url, props);
+        conn = DriverManager.getConnection(url, props);
         fail("connection was unexpectedly successful");
       } catch (SQLException e) {
         // Ignored.
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/OID74Test.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/OID74Test.java
index 8aba8df31a..5ab9e2b6a9 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/OID74Test.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/OID74Test.java
@@ -59,10 +59,7 @@ public void testSetNull() throws SQLException {
   }
 
   public void testBinaryStream() throws Exception {
-
-    PreparedStatement pstmt = null;
-
-    pstmt = conn.prepareStatement("INSERT INTO temp VALUES (?)");
+    PreparedStatement pstmt = conn.prepareStatement("INSERT INTO temp VALUES (?)");
     pstmt.setBinaryStream(1, new ByteArrayInputStream(new byte[]{1, 2, 3, 4, 5}), 5);
     assertTrue((pstmt.executeUpdate() == 1));
     pstmt.close();
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PGPropertyTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PGPropertyTest.java
index 5f50e53c2c..d44410563c 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PGPropertyTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PGPropertyTest.java
@@ -12,6 +12,7 @@
 import java.beans.BeanInfo;
 import java.beans.Introspector;
 import java.beans.PropertyDescriptor;
+import java.net.URLEncoder;
 import java.sql.DriverPropertyInfo;
 import java.util.Map;
 import java.util.Properties;
@@ -158,6 +159,21 @@ public void testNullValue() {
     assertNotNull(PGProperty.LOG_LEVEL.getSetString(withLogging));
   }
 
+  public void testEncodedUrlValues() {
+    String databaseName = "d&a%ta+base";
+    String userName = "&u%ser";
+    String password = "p%a&s^s#w!o@r*";
+    String url = "jdbc:postgresql://"
+            + "localhost" + ":" + 5432 + "/"
+            + URLEncoder.encode(databaseName)
+            + "?user=" + URLEncoder.encode(userName)
+            + "&password=" + URLEncoder.encode(password);
+    Properties parsed = Driver.parseURL(url, new Properties());
+    assertEquals("database", databaseName, PGProperty.PG_DBNAME.get(parsed));
+    assertEquals("user", userName, PGProperty.USER.get(parsed));
+    assertEquals("password", password, PGProperty.PASSWORD.get(parsed));
+  }
+
   public void setUp() {
     bootSSLPropertyValue = System.getProperty("ssl");
   }
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PGTimeTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PGTimeTest.java
index 3515bbc518..1f5e02fbf1 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PGTimeTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PGTimeTest.java
@@ -228,7 +228,7 @@ private void verifyInsertAndSelect(PGTime time, boolean useSetObject) throws SQL
   }
 
   /**
-   * Creates a <code>SimpleDateFormat</code> that is appropriate for the given time.
+   * Creates a {@code SimpleDateFormat} that is appropriate for the given time.
    *
    * @param time the time object.
    * @return the new format instance.
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PGTimestampTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PGTimestampTest.java
index b2d02c58f5..c6e1259b60 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PGTimestampTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PGTimestampTest.java
@@ -223,7 +223,7 @@ private void verifyInsertAndSelect(PGTimestamp timestamp, boolean useSetObject)
   }
 
   /**
-   * Creates a <code>SimpleDateFormat</code> that is appropriate for the given timestamp.
+   * Creates a {@code SimpleDateFormat} that is appropriate for the given timestamp.
    *
    * @param timestamp the timestamp object.
    * @return the new format instance.
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PreparedStatementTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PreparedStatementTest.java
index 53d2b7520c..715c6a9677 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PreparedStatementTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PreparedStatementTest.java
@@ -322,13 +322,13 @@ public void testDoubleQuotes() throws SQLException {
         "no backslash interpretation here: \\",
     };
 
-    for (int i = 0; i < testStrings.length; ++i) {
+    for (String testString : testStrings) {
       PreparedStatement pstmt =
-          con.prepareStatement("CREATE TABLE \"" + testStrings[i] + "\" (i integer)");
+          con.prepareStatement("CREATE TABLE \"" + testString + "\" (i integer)");
       pstmt.executeUpdate();
       pstmt.close();
 
-      pstmt = con.prepareStatement("DROP TABLE \"" + testStrings[i] + "\"");
+      pstmt = con.prepareStatement("DROP TABLE \"" + testString + "\"");
       pstmt.executeUpdate();
       pstmt.close();
     }
@@ -509,8 +509,8 @@ public void testBoolean() throws SQLException {
     ResultSet rs = pstmt.executeQuery();
     assertTrue(rs.next());
 
-    assertTrue("expected true,received " + rs.getBoolean(1), rs.getBoolean(1) == true);
-    assertTrue("expected false,received " + rs.getBoolean(2), rs.getBoolean(2) == false);
+    assertTrue("expected true,received " + rs.getBoolean(1), rs.getBoolean(1));
+    assertFalse("expected false,received " + rs.getBoolean(2), rs.getBoolean(2));
     rs.getFloat(3);
     assertTrue(rs.wasNull());
     rs.close();
@@ -542,9 +542,9 @@ public void testSetFloatInteger() throws SQLException {
     assertTrue(rs.next());
 
     assertTrue("expected " + maxFloat + " ,received " + rs.getObject(1),
-        ((Double) rs.getObject(1)).equals(maxFloat));
+        rs.getObject(1).equals(maxFloat));
     assertTrue("expected " + minFloat + " ,received " + rs.getObject(2),
-        ((Double) rs.getObject(2)).equals(minFloat));
+        rs.getObject(2).equals(minFloat));
     rs.getFloat(3);
     assertTrue(rs.wasNull());
     rs.close();
@@ -558,8 +558,8 @@ public void testSetFloatString() throws SQLException {
     pstmt.executeUpdate();
     pstmt.close();
 
-    String maxStringFloat = new String("1.0E37");
-    String minStringFloat = new String("1.0E-37");
+    String maxStringFloat = "1.0E37";
+    String minStringFloat = "1.0E-37";
     Double maxFloat = new Double(1.0E37);
     Double minFloat = new Double(1.0E-37);
 
@@ -696,14 +696,13 @@ public void testSetSmallIntFloat() throws SQLException {
     assertTrue(rs.next());
 
     assertTrue("expected " + maxInt + " ,received " + rs.getObject(1),
-        ((Integer) rs.getObject(1)).equals(maxInt));
+        rs.getObject(1).equals(maxInt));
     assertTrue("expected " + minInt + " ,received " + rs.getObject(2),
-        ((Integer) rs.getObject(2)).equals(minInt));
+        rs.getObject(2).equals(minInt));
     rs.getFloat(3);
     assertTrue(rs.wasNull());
     rs.close();
     pstmt.close();
-
   }
 
   public void testSetIntFloat() throws SQLException {
@@ -745,14 +744,12 @@ public void testSetBooleanDouble() throws SQLException {
     pstmt.executeUpdate();
     pstmt.close();
 
-    Boolean trueVal = Boolean.TRUE;
-    Boolean falseVal = Boolean.FALSE;
     Double dBooleanTrue = new Double(1);
     Double dBooleanFalse = new Double(0);
 
     pstmt = con.prepareStatement("insert into double_tab values (?,?,?)");
-    pstmt.setObject(1, trueVal, Types.DOUBLE);
-    pstmt.setObject(2, falseVal, Types.DOUBLE);
+    pstmt.setObject(1, Boolean.TRUE, Types.DOUBLE);
+    pstmt.setObject(2, Boolean.FALSE, Types.DOUBLE);
     pstmt.setNull(3, Types.DOUBLE);
     pstmt.executeUpdate();
     pstmt.close();
@@ -762,9 +759,9 @@ public void testSetBooleanDouble() throws SQLException {
     assertTrue(rs.next());
 
     assertTrue("expected " + dBooleanTrue + " ,received " + rs.getObject(1),
-        ((Double) rs.getObject(1)).equals(dBooleanTrue));
+        rs.getObject(1).equals(dBooleanTrue));
     assertTrue("expected " + dBooleanFalse + " ,received " + rs.getObject(2),
-        ((Double) rs.getObject(2)).equals(dBooleanFalse));
+        rs.getObject(2).equals(dBooleanFalse));
     rs.getFloat(3);
     assertTrue(rs.wasNull());
     rs.close();
@@ -778,14 +775,12 @@ public void testSetBooleanNumeric() throws SQLException {
     pstmt.executeUpdate();
     pstmt.close();
 
-    Boolean trueVal = Boolean.TRUE;
-    Boolean falseVal = Boolean.FALSE;
     BigDecimal dBooleanTrue = new BigDecimal(1);
     BigDecimal dBooleanFalse = new BigDecimal(0);
 
     pstmt = con.prepareStatement("insert into numeric_tab values (?,?,?)");
-    pstmt.setObject(1, trueVal, Types.NUMERIC, 2);
-    pstmt.setObject(2, falseVal, Types.NUMERIC, 2);
+    pstmt.setObject(1, Boolean.TRUE, Types.NUMERIC, 2);
+    pstmt.setObject(2, Boolean.FALSE, Types.NUMERIC, 2);
     pstmt.setNull(3, Types.DOUBLE);
     pstmt.executeUpdate();
     pstmt.close();
@@ -811,14 +806,12 @@ public void testSetBooleanDecimal() throws SQLException {
     pstmt.executeUpdate();
     pstmt.close();
 
-    Boolean trueVal = Boolean.TRUE;
-    Boolean falseVal = Boolean.FALSE;
     BigDecimal dBooleanTrue = new BigDecimal(1);
     BigDecimal dBooleanFalse = new BigDecimal(0);
 
     pstmt = con.prepareStatement("insert into DECIMAL_TAB values (?,?,?)");
-    pstmt.setObject(1, trueVal, Types.DECIMAL, 2);
-    pstmt.setObject(2, falseVal, Types.DECIMAL, 2);
+    pstmt.setObject(1, Boolean.TRUE, Types.DECIMAL, 2);
+    pstmt.setObject(2, Boolean.FALSE, Types.DECIMAL, 2);
     pstmt.setNull(3, Types.DOUBLE);
     pstmt.executeUpdate();
     pstmt.close();
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/QuotationTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/QuotationTest.java
index b49083a824..5ae2575a5e 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/QuotationTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/QuotationTest.java
@@ -15,7 +15,7 @@
 
 @RunWith(Parameterized.class)
 public class QuotationTest extends BaseTest4 {
-  enum QuoteStyle {
+  private enum QuoteStyle {
     SIMPLE("'"), DOLLAR_NOTAG("$$"), DOLLAR_A("$a$"), DOLLAR_DEF("$DEF$");
 
     private final String quote;
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ServerPreparedStmtTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ServerPreparedStmtTest.java
index 87011ba2e7..c4f294d79b 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ServerPreparedStmtTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ServerPreparedStmtTest.java
@@ -145,7 +145,7 @@ public void testBooleanObjectBind() throws Exception {
     ((PGStatement) pstmt).setUseServerPrepare(true);
     assertTrue(((PGStatement) pstmt).isUseServerPrepare());
 
-    pstmt.setObject(1, new Boolean(false), java.sql.Types.BIT);
+    pstmt.setObject(1, Boolean.FALSE, java.sql.Types.BIT);
     ResultSet rs = pstmt.executeQuery();
     assertTrue(rs.next());
     assertEquals(9, rs.getInt(1));
@@ -158,7 +158,7 @@ public void testBooleanIntegerBind() throws Exception {
     ((PGStatement) pstmt).setUseServerPrepare(true);
     assertTrue(((PGStatement) pstmt).isUseServerPrepare());
 
-    pstmt.setObject(1, new Boolean(true), java.sql.Types.INTEGER);
+    pstmt.setObject(1, Boolean.TRUE, java.sql.Types.INTEGER);
     ResultSet rs = pstmt.executeQuery();
     assertTrue(rs.next());
     assertEquals(1, rs.getInt(1));
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/StatementTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/StatementTest.java
index 103f47294f..bbd280b4d3 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/StatementTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/StatementTest.java
@@ -18,8 +18,6 @@
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Statement;
-import java.util.Timer;
-import java.util.TimerTask;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
@@ -57,8 +55,7 @@ protected void tearDown() throws Exception {
   }
 
   public void testClose() throws SQLException {
-    Statement stmt = null;
-    stmt = con.createStatement();
+    Statement stmt = con.createStatement();
     stmt.close();
 
     try {
@@ -486,23 +483,23 @@ public void testExecuteUpdateFailsOnMultiStatementSelect() throws SQLException {
 
   public void testSetQueryTimeout() throws SQLException {
     Statement stmt = con.createStatement();
-    Timer timer = new Timer(true);
+    long start = 0;
+    boolean cancelReceived = false;
     try {
-
-      timer.schedule(new TimerTask() {
-        public void run() {
-          fail("Query timeout should have occurred and cleaned this up");
-        }
-      }, 5000);
       stmt.setQueryTimeout(1);
+      start = System.currentTimeMillis();
       stmt.execute("select pg_sleep(10)");
-
     } catch (SQLException sqle) {
       // state for cancel
-      if (sqle.getSQLState().compareTo("57014") == 0) {
-        timer.cancel();
+      if ("57014".equals(sqle.getSQLState())) {
+        cancelReceived = true;
       }
     }
+    long duration = System.currentTimeMillis() - start;
+    if (!cancelReceived || duration > 5000) {
+      fail("Query should have been cancelled since the timeout was set to 1 sec."
+          + " Cancel state: " + cancelReceived + ", duration: " + duration);
+    }
   }
 
   /**
@@ -549,7 +546,7 @@ public void testSetQueryTimeoutOnPrepared() throws SQLException, InterruptedExce
     for (int i = 1; i <= 3; i++) {
       try {
         ResultSet rs = pstmt.executeQuery();
-        this.fail("statement should have been canceled by query timeout (execution #" + i + ")");
+        fail("statement should have been canceled by query timeout (execution #" + i + ")");
       } catch (SQLException sqle) {
         // state for cancel
         if (sqle.getSQLState().compareTo("57014") != 0) {
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/TimeTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/TimeTest.java
index 84e7bc8b34..e2556b5348 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/TimeTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/TimeTest.java
@@ -81,7 +81,6 @@ public void testGetTimeZone() throws Exception {
     Timestamp timestamptz = rs.getTimestamp(2);
     assertNotNull(timestamptz);
 
-    Time timetz = rs.getTime(2);
     assertEquals(midnight, time);
 
     time = rs.getTime(1, cal);
@@ -104,7 +103,7 @@ public void testGetTimeZone() throws Exception {
     }
     assertEquals(100000000, timestamp.getNanos());
 
-    timetz = rs.getTime(2);
+    Time timetz = rs.getTime(2);
     assertNotNull(timetz);
     assertEquals(10, extractMillis(timetz.getTime()));
     timestamptz = rs.getTimestamp(2);
@@ -168,16 +167,16 @@ public void testSetTime() throws SQLException {
     ps.setTime(1, makeTime(23, 59, 59));
     assertEquals(1, ps.executeUpdate());
 
-    ps.setObject(1, java.sql.Time.valueOf("12:00:00"), java.sql.Types.TIME);
+    ps.setObject(1, Time.valueOf("12:00:00"), java.sql.Types.TIME);
     assertEquals(1, ps.executeUpdate());
 
-    ps.setObject(1, java.sql.Time.valueOf("05:15:21"), java.sql.Types.TIME);
+    ps.setObject(1, Time.valueOf("05:15:21"), java.sql.Types.TIME);
     assertEquals(1, ps.executeUpdate());
 
-    ps.setObject(1, java.sql.Time.valueOf("16:21:51"), java.sql.Types.TIME);
+    ps.setObject(1, Time.valueOf("16:21:51"), java.sql.Types.TIME);
     assertEquals(1, ps.executeUpdate());
 
-    ps.setObject(1, java.sql.Time.valueOf("12:15:12"), java.sql.Types.TIME);
+    ps.setObject(1, Time.valueOf("12:15:12"), java.sql.Types.TIME);
     assertEquals(1, ps.executeUpdate());
 
     ps.setObject(1, "22:12:1", java.sql.Types.TIME);
@@ -209,7 +208,7 @@ public void testSetTime() throws SQLException {
   private void timeTest() throws SQLException {
     Statement st = con.createStatement();
     ResultSet rs;
-    java.sql.Time t;
+    Time t;
 
     rs = st.executeQuery(TestUtil.selectSQL("testtime", "tm"));
     assertNotNull(rs);
@@ -259,19 +258,19 @@ private void timeTest() throws SQLException {
       assertTrue(rs.next());
       t = rs.getTime(1);
       assertNotNull(t);
-      java.sql.Time tmpTime = java.sql.Time.valueOf("5:1:2");
-      int localoffset = java.util.Calendar.getInstance().getTimeZone().getOffset(tmpTime.getTime());
-      int Timeoffset = 3 * 60 * 60 * 1000;
-      tmpTime.setTime(tmpTime.getTime() + Timeoffset + localoffset);
+      Time tmpTime = Time.valueOf("5:1:2");
+      int localOffset = Calendar.getInstance().getTimeZone().getOffset(tmpTime.getTime());
+      int timeOffset = 3 * 60 * 60 * 1000;
+      tmpTime.setTime(tmpTime.getTime() + timeOffset + localOffset);
       assertEquals(makeTime(tmpTime.getHours(), tmpTime.getMinutes(), tmpTime.getSeconds()), t);
 
       assertTrue(rs.next());
       t = rs.getTime(1);
       assertNotNull(t);
-      tmpTime = java.sql.Time.valueOf("23:59:59");
-      localoffset = java.util.Calendar.getInstance().getTimeZone().getOffset(tmpTime.getTime());
-      Timeoffset = -11 * 60 * 60 * 1000;
-      tmpTime.setTime(tmpTime.getTime() + Timeoffset + localoffset);
+      tmpTime = Time.valueOf("23:59:59");
+      localOffset = Calendar.getInstance().getTimeZone().getOffset(tmpTime.getTime());
+      timeOffset = -11 * 60 * 60 * 1000;
+      tmpTime.setTime(tmpTime.getTime() + timeOffset + localOffset);
       assertEquals(makeTime(tmpTime.getHours(), tmpTime.getMinutes(), tmpTime.getSeconds()), t);
     }
 
@@ -280,8 +279,7 @@ private void timeTest() throws SQLException {
     rs.close();
   }
 
-  private java.sql.Time makeTime(int h, int m, int s) {
-    return java.sql.Time
-        .valueOf(TestUtil.fix(h, 2) + ":" + TestUtil.fix(m, 2) + ":" + TestUtil.fix(s, 2));
+  private Time makeTime(int h, int m, int s) {
+    return Time.valueOf(TestUtil.fix(h, 2) + ":" + TestUtil.fix(m, 2) + ":" + TestUtil.fix(s, 2));
   }
 }
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/TimestampTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/TimestampTest.java
index 18bc6ea47f..cf51a07033 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/TimestampTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/TimestampTest.java
@@ -23,6 +23,8 @@
 import java.sql.Statement;
 import java.sql.Time;
 import java.sql.Timestamp;
+import java.sql.Types;
+import java.text.SimpleDateFormat;
 import java.util.Calendar;
 import java.util.GregorianCalendar;
 import java.util.TimeZone;
@@ -229,43 +231,43 @@ public void testSetTimestampWTZ() throws SQLException {
     assertEquals(1, pstmt.executeUpdate());
 
     // With java.sql.Timestamp
-    pstmt.setObject(1, TS1WTZ, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, TS1WTZ, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, TS2WTZ, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, TS2WTZ, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, TS3WTZ, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, TS3WTZ, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, TS4WTZ, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, TS4WTZ, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
 
     // With Strings
-    pstmt.setObject(1, TS1WTZ_PGFORMAT, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, TS1WTZ_PGFORMAT, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, TS2WTZ_PGFORMAT, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, TS2WTZ_PGFORMAT, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, TS3WTZ_PGFORMAT, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, TS3WTZ_PGFORMAT, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, TS4WTZ_PGFORMAT, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, TS4WTZ_PGFORMAT, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
 
     // With java.sql.Date
-    pstmt.setObject(1, tmpDate1, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, tmpDate1, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, tmpDate2, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, tmpDate2, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, tmpDate3, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, tmpDate3, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, tmpDate4, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, tmpDate4, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
 
     // With java.sql.Time
-    pstmt.setObject(1, tmpTime1, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, tmpTime1, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, tmpTime2, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, tmpTime2, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, tmpTime3, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, tmpTime3, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, tmpTime4, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, tmpTime4, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
     // Fall through helper
     timestampTestWTZ();
@@ -383,59 +385,59 @@ public void testSetTimestampWOTZ() throws SQLException {
     assertEquals(1, pstmt.executeUpdate());
 
     // With java.sql.Timestamp
-    pstmt.setObject(1, TS1WOTZ, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, TS1WOTZ, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, TS2WOTZ, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, TS2WOTZ, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, TS3WOTZ, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, TS3WOTZ, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, TS4WOTZ, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, TS4WOTZ, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, TS5WOTZ, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, TS5WOTZ, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, TS6WOTZ, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, TS6WOTZ, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
 
     // With Strings
-    pstmt.setObject(1, TS1WOTZ_PGFORMAT, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, TS1WOTZ_PGFORMAT, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, TS2WOTZ_PGFORMAT, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, TS2WOTZ_PGFORMAT, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, TS3WOTZ_PGFORMAT, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, TS3WOTZ_PGFORMAT, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, TS4WOTZ_PGFORMAT, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, TS4WOTZ_PGFORMAT, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, TS5WOTZ_PGFORMAT, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, TS5WOTZ_PGFORMAT, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, TS6WOTZ_PGFORMAT, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, TS6WOTZ_PGFORMAT, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
 
     // With java.sql.Date
-    pstmt.setObject(1, tmpDate1WOTZ, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, tmpDate1WOTZ, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, tmpDate2WOTZ, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, tmpDate2WOTZ, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, tmpDate3WOTZ, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, tmpDate3WOTZ, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, tmpDate4WOTZ, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, tmpDate4WOTZ, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, tmpDate5WOTZ, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, tmpDate5WOTZ, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, tmpDate6WOTZ, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, tmpDate6WOTZ, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
 
     // With java.sql.Time
-    pstmt.setObject(1, tmpTime1WOTZ, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, tmpTime1WOTZ, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, tmpTime2WOTZ, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, tmpTime2WOTZ, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, tmpTime3WOTZ, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, tmpTime3WOTZ, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, tmpTime4WOTZ, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, tmpTime4WOTZ, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, tmpTime5WOTZ, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, tmpTime5WOTZ, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
-    pstmt.setObject(1, tmpTime6WOTZ, java.sql.Types.TIMESTAMP);
+    pstmt.setObject(1, tmpTime6WOTZ, Types.TIMESTAMP);
     assertEquals(1, pstmt.executeUpdate());
     // Fall through helper
     timestampTestWOTZ();
@@ -652,10 +654,10 @@ private static java.sql.Timestamp getTimestamp(int y, int m, int d, int h, int m
           + TestUtil.fix(se, 2) + " ";
 
       if (tz == null) {
-        l_df = new java.text.SimpleDateFormat("y-M-d H:m:s");
+        l_df = new SimpleDateFormat("y-M-d H:m:s");
       } else {
         l_ts = l_ts + tz;
-        l_df = new java.text.SimpleDateFormat("y-M-d H:m:s z");
+        l_df = new SimpleDateFormat("y-M-d H:m:s z");
       }
       java.util.Date l_date = l_df.parse(l_ts);
       l_return = new java.sql.Timestamp(l_date.getTime());
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/TimezoneCachingTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/TimezoneCachingTest.java
new file mode 100644
index 0000000000..08ac8f8151
--- /dev/null
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/TimezoneCachingTest.java
@@ -0,0 +1,399 @@
+/*-------------------------------------------------------------------------
+ *
+ * Copyright (c) 2003-2016, PostgreSQL Global Development Group
+ *
+ *
+ *-------------------------------------------------------------------------
+ */
+
+package org.postgresql.test.jdbc2;
+
+import static org.junit.Assert.assertEquals;
+
+import org.postgresql.core.BaseConnection;
+import org.postgresql.jdbc.TimestampUtils;
+import org.postgresql.test.TestUtil;
+
+import org.junit.Assume;
+import org.junit.Test;
+
+import java.lang.reflect.Field;
+import java.sql.BatchUpdateException;
+import java.sql.Date;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Statement;
+import java.sql.Time;
+import java.sql.Timestamp;
+import java.util.Calendar;
+import java.util.GregorianCalendar;
+import java.util.TimeZone;
+
+public class TimezoneCachingTest extends BaseTest4 {
+
+  /**
+   * Test to check the internal cached timezone of a prepared statement is set/cleared as expected.
+   */
+  @Test
+  public void testPreparedStatementCachedTimezoneInstance() throws SQLException {
+    Timestamp ts = new Timestamp(2016 - 1900, 0, 31, 0, 0, 0, 0);
+    Date date = new Date(2016 - 1900, 0, 31);
+    Time time = new Time(System.currentTimeMillis());
+    TimeZone tz = TimeZone.getDefault();
+    PreparedStatement pstmt = null;
+    try {
+      pstmt = con.prepareStatement("INSERT INTO testtz VALUES (?,?)");
+      assertEquals(
+          "Cache never initialized: must be null",
+          null, getTimeZoneCache(pstmt));
+      pstmt.setInt(1, 1);
+      assertEquals(
+          "Cache never initialized: must be null",
+          null, getTimeZoneCache(pstmt));
+      pstmt.setTimestamp(2, ts);
+      assertEquals(
+          "Cache initialized by setTimestamp(xx): must not be null",
+          tz, getTimeZoneCache(pstmt));
+      pstmt.addBatch();
+      assertEquals(
+          "Cache was initialized, addBatch does not change that: must not be null",
+          tz, getTimeZoneCache(pstmt));
+      pstmt.setInt(1, 2);
+      pstmt.setNull(2, java.sql.Types.DATE);
+      assertEquals(
+          "Cache was initialized, setNull does not change that: must not be null",
+          tz, getTimeZoneCache(pstmt));
+      pstmt.addBatch();
+      assertEquals(
+          "Cache was initialized, addBatch does not change that: must not be null",
+          tz, getTimeZoneCache(pstmt));
+      pstmt.executeBatch();
+      assertEquals(
+          "Cache reset by executeBatch(): must be null",
+          null, getTimeZoneCache(pstmt));
+      pstmt.setInt(1, 3);
+      assertEquals(
+          "Cache not initialized: must be null",
+          null, getTimeZoneCache(pstmt));
+      pstmt.setInt(1, 4);
+      pstmt.setNull(2, java.sql.Types.DATE);
+      assertEquals(
+          "Cache was not initialized, setNull does not change that: must be null",
+          null, getTimeZoneCache(pstmt));
+      pstmt.setTimestamp(2, ts);
+      assertEquals(
+          "Cache initialized by setTimestamp(xx): must not be null",
+          tz, getTimeZoneCache(pstmt));
+      pstmt.clearParameters();
+      assertEquals(
+          "Cache was initialized, clearParameters does not change that: must not be null",
+          tz, getTimeZoneCache(pstmt));
+      pstmt.setInt(1, 5);
+      pstmt.setTimestamp(2, ts);
+      pstmt.addBatch();
+      pstmt.executeBatch();
+      pstmt.close();
+      pstmt = con.prepareStatement("UPDATE testtz SET col2 = ? WHERE col1 = 1");
+      assertEquals(
+          "Cache not initialized: must be null",
+          null, getTimeZoneCache(pstmt));
+      pstmt.setDate(1, date);
+      assertEquals(
+          "Cache initialized by setDate(xx): must not be null",
+          tz, getTimeZoneCache(pstmt));
+      pstmt.execute();
+      assertEquals(
+          "Cache reset by execute(): must be null",
+          null, getTimeZoneCache(pstmt));
+      pstmt.setDate(1, date);
+      assertEquals(
+          "Cache initialized by setDate(xx): must not be null",
+          tz, getTimeZoneCache(pstmt));
+      pstmt.executeUpdate();
+      assertEquals(
+          "Cache reset by executeUpdate(): must be null",
+          null, getTimeZoneCache(pstmt));
+      pstmt.setTime(1, time);
+      assertEquals(
+          "Cache initialized by setTime(xx): must not be null",
+          tz, getTimeZoneCache(pstmt));
+      pstmt.close();
+      pstmt = con.prepareStatement("SELECT * FROM testtz WHERE col2 = ?");
+      pstmt.setDate(1, date);
+      assertEquals(
+          "Cache initialized by setDate(xx): must not be null",
+          tz, getTimeZoneCache(pstmt));
+      pstmt.executeQuery();
+      assertEquals(
+          "Cache reset by executeQuery(): must be null",
+          null, getTimeZoneCache(pstmt));
+    } finally {
+      TestUtil.closeQuietly(pstmt);
+    }
+  }
+
+  /**
+   * Test to check the internal cached timezone of a prepared statement is used as expected.
+   */
+  @Test
+  public void testPreparedStatementCachedTimezoneUsage() throws SQLException {
+    Timestamp ts = new Timestamp(2016 - 1900, 0, 31, 0, 0, 0, 0);
+    Statement stmt = null;
+    PreparedStatement pstmt = null;
+    TimeZone tz1 = TimeZone.getTimeZone("GMT+8:00");
+    TimeZone tz2 = TimeZone.getTimeZone("GMT-2:00");
+    TimeZone tz3 = TimeZone.getTimeZone("UTC+2");
+    TimeZone tz4 = TimeZone.getTimeZone("UTC+3");
+    Calendar c3 = new GregorianCalendar(tz3);
+    Calendar c4 = new GregorianCalendar(tz4);
+    try {
+      stmt = con.createStatement();
+      TimeZone.setDefault(tz1);
+      pstmt = con.prepareStatement("INSERT INTO testtz VALUES(1, ?)");
+      pstmt.setTimestamp(1, ts);
+      pstmt.executeUpdate();
+      checkTimestamp("Default is tz2, was saved as tz1, expecting tz1", stmt, ts, tz1);
+      pstmt.close();
+      pstmt = con.prepareStatement("UPDATE testtz SET col2 = ? WHERE col1 = ?");
+      pstmt.setTimestamp(1, ts);
+      TimeZone.setDefault(tz2);
+      pstmt.setInt(2, 1);
+      pstmt.addBatch();
+      pstmt.executeBatch();
+      checkTimestamp("Default is tz2, but was saved as tz1, expecting tz1", stmt, ts, tz1);
+      pstmt.setTimestamp(1, ts);
+      pstmt.setInt(2, 1);
+      pstmt.addBatch();
+      pstmt.executeBatch();
+      checkTimestamp("Default is tz2, was saved as tz2, expecting tz2", stmt, ts, tz2);
+      pstmt.setTimestamp(1, ts);
+      pstmt.setInt(2, 1);
+      pstmt.clearParameters();
+      TimeZone.setDefault(tz1);
+      pstmt.setTimestamp(1, ts);
+      pstmt.setInt(2, 1);
+      pstmt.addBatch();
+      pstmt.executeBatch();
+      checkTimestamp(
+          "Default is tz1, but was first saved as tz2, next save used tz2 cache, expecting tz2",
+          stmt, ts, tz2);
+      pstmt.setTimestamp(1, ts, c3);
+      pstmt.setInt(2, 1);
+      pstmt.addBatch();
+      pstmt.executeBatch();
+      checkTimestamp("Explicit use of tz3, expecting tz3", stmt, ts, tz3);
+      pstmt.setTimestamp(1, ts, c3);
+      pstmt.setInt(2, 1);
+      pstmt.addBatch();
+      pstmt.setTimestamp(1, ts, c4);
+      pstmt.setInt(2, 1);
+      pstmt.addBatch();
+      pstmt.executeBatch();
+      checkTimestamp("Last set explicitly used tz4, expecting tz4", stmt, ts, tz4);
+      pstmt.setTimestamp(1, ts, c3);
+      pstmt.setInt(2, 1);
+      pstmt.addBatch();
+      pstmt.setTimestamp(1, ts);
+      pstmt.setInt(2, 1);
+      pstmt.addBatch();
+      pstmt.setTimestamp(1, ts, c4);
+      pstmt.setInt(2, 1);
+      pstmt.addBatch();
+      pstmt.executeBatch();
+      checkTimestamp("Last set explicitly used tz4, expecting tz4", stmt, ts, tz4);
+      pstmt.setTimestamp(1, ts, c3);
+      pstmt.setInt(2, 1);
+      pstmt.addBatch();
+      pstmt.setTimestamp(1, ts);
+      pstmt.setInt(2, 1);
+      pstmt.addBatch();
+      pstmt.executeBatch();
+      checkTimestamp(
+          "Default is tz1, was first saved as tz1, last save used tz1 cache, expecting tz1", stmt,
+          ts, tz1);
+      pstmt.setTimestamp(1, ts);
+      pstmt.setInt(2, 1);
+      pstmt.addBatch();
+      pstmt.setTimestamp(1, ts, c4);
+      pstmt.setInt(2, 1);
+      pstmt.addBatch();
+      pstmt.setTimestamp(1, ts);
+      pstmt.setInt(2, 1);
+      pstmt.addBatch();
+      pstmt.executeBatch();
+      checkTimestamp(
+          "Default is tz1, was first saved as tz1, last save used tz1 cache, expecting tz1", stmt,
+          ts, tz1);
+    } catch (BatchUpdateException ex) {
+      SQLException nextException = ex.getNextException();
+      nextException.printStackTrace();
+    } finally {
+      TimeZone.setDefault(null);
+      TestUtil.closeQuietly(pstmt);
+      TestUtil.closeQuietly(stmt);
+    }
+  }
+
+  /**
+   * Test to check the internal cached timezone of a result set is set/cleared as expected.
+   */
+  @Test
+  public void testResultSetCachedTimezoneInstance() throws SQLException {
+    Timestamp ts = new Timestamp(2016 - 1900, 0, 31, 0, 0, 0, 0);
+    TimeZone tz = TimeZone.getDefault();
+    Statement stmt = null;
+    PreparedStatement pstmt = null;
+    ResultSet rs = null;
+    try {
+      pstmt = con.prepareStatement("INSERT INTO testtz VALUES (?,?)");
+      pstmt.setInt(1, 1);
+      pstmt.setTimestamp(2, ts);
+      pstmt.addBatch();
+      pstmt.executeBatch();
+      stmt = con.createStatement();
+      rs = stmt.executeQuery("SELECT col1, col2 FROM testtz");
+      rs.next();
+      assertEquals("Cache never initialized: must be null", null, getTimeZoneCache(rs));
+      rs.getInt(1);
+      assertEquals("Cache never initialized: must be null", null, getTimeZoneCache(rs));
+      rs.getTimestamp(2);
+      assertEquals("Cache initialized by getTimestamp(x): must not be null",
+          tz, getTimeZoneCache(rs));
+      rs.close();
+      rs = stmt.executeQuery("SELECT col1, col2 FROM testtz");
+      rs.next();
+      rs.getInt(1);
+      assertEquals("Cache never initialized: must be null", null, getTimeZoneCache(rs));
+      rs.getObject(2);
+      assertEquals("Cache initialized by getObject(x) on a DATE column: must not be null",
+          tz, getTimeZoneCache(rs));
+      rs.close();
+      rs = stmt.executeQuery("SELECT col1, col2 FROM testtz");
+      rs.next();
+      assertEquals("Cache should NOT be set", null, getTimeZoneCache(rs));
+      rs.getInt(1);
+      assertEquals("Cache never initialized: must be null", null, getTimeZoneCache(rs));
+      rs.getDate(2);
+      assertEquals("Cache initialized by getDate(x): must not be null", tz, getTimeZoneCache(rs));
+      rs.close();
+    } finally {
+      TestUtil.closeQuietly(rs);
+      TestUtil.closeQuietly(pstmt);
+      TestUtil.closeQuietly(stmt);
+    }
+  }
+
+  /**
+   * Test to check the internal cached timezone of a result set is used as expected.
+   */
+  @Test
+  public void testResultSetCachedTimezoneUsage() throws SQLException {
+    Statement stmt = null;
+    PreparedStatement pstmt = null;
+    ResultSet rs = null;
+    TimeZone tz1 = TimeZone.getTimeZone("GMT+8:00");
+    TimeZone tz2 = TimeZone.getTimeZone("GMT-2:00"); // 10 hour difference
+    Timestamp ts1 = new Timestamp(2016 - 1900, 0, 31, 3, 0, 0, 0);
+    Timestamp ts2 = new Timestamp(2016 - 1900, 0, 31, 13, 0, 0, 0); // 10 hour difference
+    Calendar c1 = new GregorianCalendar(tz1);
+    Calendar c2 = new GregorianCalendar(tz2);
+    try {
+      TimeZone.setDefault(tz1);
+      pstmt = con.prepareStatement("INSERT INTO testtz VALUES (?,?)");
+      pstmt.setInt(1, 1);
+      // We are in tz1, so timestamp added as tz1.
+      pstmt.setTimestamp(2, ts1);
+      pstmt.addBatch();
+      pstmt.executeBatch();
+      stmt = con.createStatement();
+      rs = stmt.executeQuery("SELECT col1, col2 FROM testtz");
+      rs.next();
+      rs.getInt(1);
+      assertEquals(
+          "Current TZ is tz1, empty cache to be initialized to tz1 => retrieve in tz1, timestamps must be equal",
+          ts1, rs.getTimestamp(2));
+      rs.close();
+      rs = stmt.executeQuery("SELECT col1, col2 FROM testtz");
+      rs.next();
+      rs.getInt(1);
+      TimeZone.setDefault(tz2);
+      assertEquals(
+          "Current TZ is tz2, empty cache to be initialized to tz2 => retrieve in tz2, timestamps cannot be equal",
+          ts2, rs.getTimestamp(2));
+      assertEquals(
+          "Explicit tz1 calendar, so timestamps must be equal",
+          ts1, rs.getTimestamp(2, c1));
+      assertEquals(
+          "Cache was initialized to tz2, so timestamps cannot be equal",
+          ts2, rs.getTimestamp(2));
+      TimeZone.setDefault(tz1);
+      assertEquals(
+          "Cache was initialized to tz2, so timestamps cannot be equal",
+          ts2, rs.getTimestamp(2));
+      rs.close();
+      rs = stmt.executeQuery("SELECT col1, col2 FROM testtz");
+      rs.next();
+      rs.getInt(1);
+      assertEquals(
+          "Explicit tz2 calendar, so timestamps cannot be equal",
+          ts2, rs.getTimestamp(2, c2));
+      assertEquals(
+          "Current TZ is tz1, empty cache to be initialized to tz1 => retrieve in tz1, timestamps must be equal",
+          ts1, rs.getTimestamp(2));
+      assertEquals(
+          "Explicit tz2 calendar, so timestamps cannot be equal",
+          ts2, rs.getTimestamp(2, c2));
+      assertEquals(
+          "Explicit tz2 calendar, so timestamps must be equal",
+          ts1, rs.getTimestamp(2, c1));
+      rs.close();
+    } finally {
+      TimeZone.setDefault(null);
+      TestUtil.closeQuietly(rs);
+      TestUtil.closeQuietly(pstmt);
+      TestUtil.closeQuietly(stmt);
+    }
+  }
+
+  private void checkTimestamp(String checkText, Statement stmt, Timestamp ts, TimeZone tz)
+      throws SQLException {
+    TimeZone prevTz = TimeZone.getDefault();
+    TimeZone.setDefault(tz);
+    ResultSet rs = stmt.executeQuery("SELECT col2 FROM testtz");
+    rs.next();
+    Timestamp dbTs = rs.getTimestamp(1);
+    rs.close();
+    TimeZone.setDefault(prevTz);
+    assertEquals(checkText, ts, dbTs);
+  }
+
+  private TimeZone getTimeZoneCache(Object stmt) {
+    try {
+      Field defaultTimeZoneField = stmt.getClass().getDeclaredField("defaultTimeZone");
+      defaultTimeZoneField.setAccessible(true);
+      return (TimeZone) defaultTimeZoneField.get(stmt);
+    } catch (Exception e) {
+    }
+    return null;
+  }
+
+  /* Set up the fixture for this test case: a connection to a database with
+  a table for this test. */
+  public void setUp() throws Exception {
+    super.setUp();
+    TimestampUtils timestampUtils = ((BaseConnection) con).getTimestampUtils();
+    Assume.assumeFalse("If connection has fast access to TimeZone.getDefault,"
+        + " then no cache is needed", timestampUtils.hasFastDefaultTimeZone());
+    /* Drop the test table if it already exists for some reason. It is
+    not an error if it doesn't exist. */
+    TestUtil.createTable(con, "testtz", "col1 INTEGER, col2 TIMESTAMP");
+  }
+
+  // Tear down the fixture for this test case.
+  public void tearDown() throws SQLException {
+    TestUtil.dropTable(con, "testtz");
+    super.tearDown();
+  }
+
+}
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/TimezoneTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/TimezoneTest.java
index dcd4e85be8..213608c9e2 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/TimezoneTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/TimezoneTest.java
@@ -51,10 +51,11 @@
  */
 public class TimezoneTest extends TestCase {
   private static final int DAY = 24 * 3600 * 1000;
-  private Connection con;
   private static final TimeZone saveTZ = TimeZone.getDefault();
   private static final int PREPARE_THRESHOLD = 2;
 
+  private Connection con;
+
   //
   // We set up everything in different timezones to try to exercise many cases:
   //
@@ -122,6 +123,7 @@ public void testGetTimestamp() throws Exception {
         "INSERT INTO testtimezone(tstz,ts,t,tz,d) VALUES('2005-01-01 15:00:00 +0300', '2005-01-01 15:00:00', '15:00:00', '15:00:00 +0300', '2005-01-01')");
 
     for (int i = 0; i < PREPARE_THRESHOLD; i++) {
+      String format = i == 0 ? ", text" : ", binary";
       PreparedStatement ps = con.prepareStatement("SELECT tstz,ts,t,tz,d from testtimezone");
       ResultSet rs = ps.executeQuery();
 
@@ -131,6 +133,7 @@ public void testGetTimestamp() throws Exception {
               "2005-01-01"});
 
       Timestamp ts;
+      String str;
 
       // timestamptz: 2005-01-01 15:00:00+03
       ts = rs.getTimestamp(1); // Represents an instant in time, timezone is irrelevant.
@@ -143,6 +146,8 @@ public void testGetTimestamp() throws Exception {
       assertEquals(1104580800000L, ts.getTime()); // 2005-01-01 12:00:00 UTC
       ts = rs.getTimestamp(1, cGMT13); // Represents an instant in time, timezone is irrelevant.
       assertEquals(1104580800000L, ts.getTime()); // 2005-01-01 12:00:00 UTC
+      str = rs.getString(1);
+      assertEquals("tstz -> getString" + format, "2005-01-01 15:00:00+03", str);
 
       // timestamp: 2005-01-01 15:00:00
       ts = rs.getTimestamp(2); // Convert timestamp to +0100
@@ -155,6 +160,8 @@ public void testGetTimestamp() throws Exception {
       assertEquals(1104609600000L, ts.getTime()); // 2005-01-01 15:00:00 -0500
       ts = rs.getTimestamp(2, cGMT13); // Convert timestamp to +1300
       assertEquals(1104544800000L, ts.getTime()); // 2005-01-01 15:00:00 +1300
+      str = rs.getString(2);
+      assertEquals("ts -> getString" + format, "2005-01-01 15:00:00", str);
 
       // time: 15:00:00
       ts = rs.getTimestamp(3);
@@ -167,6 +174,8 @@ public void testGetTimestamp() throws Exception {
       assertEquals(72000000L, ts.getTime()); // 1970-01-01 15:00:00 -0500
       ts = rs.getTimestamp(3, cGMT13);
       assertEquals(7200000L, ts.getTime()); // 1970-01-01 15:00:00 +1300
+      str = rs.getString(3);
+      assertEquals("time -> getString" + format, "15:00:00", str);
 
       // timetz: 15:00:00+03
       ts = rs.getTimestamp(4);
@@ -184,6 +193,8 @@ public void testGetTimestamp() throws Exception {
       ts = rs.getTimestamp(4, cGMT13);
       // 1970-01-01 15:00:00 +0300 -> 1970-01-02 01:00:00 +1300 (CHECK ME)
       assertEquals(-43200000L, ts.getTime());
+      str = rs.getString(3);
+      assertEquals("timetz -> getString" + format, "15:00:00", str);
 
       // date: 2005-01-01
       ts = rs.getTimestamp(5);
@@ -196,6 +207,8 @@ public void testGetTimestamp() throws Exception {
       assertEquals(1104555600000L, ts.getTime()); // 2005-01-01 00:00:00 -0500
       ts = rs.getTimestamp(5, cGMT13);
       assertEquals(1104490800000L, ts.getTime()); // 2005-01-01 00:00:00 +1300
+      str = rs.getString(5);
+      assertEquals("date -> getString" + format, "2005-01-01", str);
 
       assertTrue(!rs.next());
       ps.close();
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/TypeCacheDLLStressTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/TypeCacheDLLStressTest.java
new file mode 100644
index 0000000000..7d1c399ee6
--- /dev/null
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/TypeCacheDLLStressTest.java
@@ -0,0 +1,97 @@
+package org.postgresql.test.jdbc2;
+
+import org.postgresql.test.TestUtil;
+
+import org.junit.Test;
+
+import java.sql.Connection;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Statement;
+import java.util.Properties;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+public class TypeCacheDLLStressTest extends BaseTest4 {
+  private final static int DURATION = Integer.getInteger("TypeCacheDLLStressTest.DURATION", 5);
+
+  private Connection con2;
+
+  @Override
+  protected void updateProperties(Properties props) {
+    try {
+      con2 = TestUtil.openDB(props);
+    } catch (Exception e) {
+      throw new IllegalStateException("Unable to open second DB connection", e);
+    }
+  }
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    TestUtil.createTable(con, "create_and_drop_table", "user_id serial PRIMARY KEY");
+  }
+
+  @Override
+  public void tearDown() throws SQLException {
+    TestUtil.closeDB(con2);
+  }
+
+  @Test
+  public void createDropTableAndGetTypeInfo() throws Throwable {
+    ExecutorService executor = Executors.newFixedThreadPool(2);
+
+    Future<Void> typeInfoCache = executor.submit(new Callable<Void>() {
+      public Void call() throws Exception {
+        while (!Thread.currentThread().isInterrupted()) {
+          ResultSet rs = con.getMetaData().getTypeInfo();
+          rs.close();
+        }
+        return null;
+      }
+    });
+
+    Future<Void> createAndDrop = executor.submit(new Callable<Void>() {
+      public Void call() throws Exception {
+        Statement stmt = con2.createStatement();
+
+        while (!Thread.currentThread().isInterrupted()) {
+          stmt.execute("drop TABLE create_and_drop_table");
+          stmt.execute("CREATE TABLE create_and_drop_table"
+              + "( user_id serial PRIMARY KEY, username VARCHAR (50) UNIQUE NOT NULL"
+              + ", password VARCHAR (50) NOT NULL, email VARCHAR (355) UNIQUE NOT NULL"
+              + ", created_on TIMESTAMP NOT NULL, last_login TIMESTAMP)");
+        }
+        return null;
+      }
+    });
+
+    try {
+      typeInfoCache.get(DURATION, TimeUnit.SECONDS);
+    } catch (ExecutionException e) {
+      createAndDrop.cancel(true);
+      throw e.getCause();
+    } catch (TimeoutException e) {
+      // Test is expected to run as long as it can
+    }
+
+    typeInfoCache.cancel(true);
+    createAndDrop.cancel(true);
+
+    try {
+      createAndDrop.get(DURATION, TimeUnit.SECONDS);
+    } catch (ExecutionException e) {
+      throw e.getCause();
+    } catch (TimeoutException e) {
+      // Test is expected to run as long as it can
+    } catch (CancellationException e) {
+      // Ignore
+    }
+  }
+}
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/optional/ConnectionPoolTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/optional/ConnectionPoolTest.java
index 27be250238..73c25bfe24 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/optional/ConnectionPoolTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/optional/ConnectionPoolTest.java
@@ -24,7 +24,6 @@
 import java.sql.SQLException;
 import java.sql.Statement;
 import java.util.ArrayList;
-import java.util.Iterator;
 
 import javax.sql.ConnectionEvent;
 import javax.sql.ConnectionEventListener;
@@ -57,9 +56,7 @@ protected void initializeDataSource() {
   }
 
   protected void tearDown() throws Exception {
-    Iterator<PooledConnection> i = connections.iterator();
-    while (i.hasNext()) {
-      PooledConnection c = i.next();
+    for (PooledConnection c : connections) {
       try {
         c.close();
       } catch (Exception ex) {
@@ -375,7 +372,7 @@ public void testStatementProxy() {
       s.executeQuery("SELECT * FROM THIS_TABLE_SHOULD_NOT_EXIST");
       fail("An SQL exception was not thrown that should have been");
     } catch (SQLException e) {
-      ; // This is the expected and correct path
+      // This is the expected and correct path
     } catch (Exception e) {
       fail("bad exception; was expecting SQLException, not" + e.getClass().getName());
     }
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc3/CompositeQueryParseTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc3/CompositeQueryParseTest.java
index 670ed388a3..92855b9c1b 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc3/CompositeQueryParseTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc3/CompositeQueryParseTest.java
@@ -2,6 +2,7 @@
 
 import org.postgresql.core.NativeQuery;
 import org.postgresql.core.Parser;
+import org.postgresql.core.SqlCommandType;
 
 import junit.framework.TestCase;
 
@@ -67,6 +68,66 @@ public void testMultipleTrailingSemicolons() {
     assertEquals("select 1", reparse("select 1;;;", true, false, true));
   }
 
+  public void testHasReturning() {
+
+    List<NativeQuery> queries = Parser.parseJdbcSql("insert into foo (a,b,c) values (?,?,?) RetuRning a", true, true, false, true, true);
+    NativeQuery query = queries.get(0);
+    assertTrue("The parser should find the word returning", query.command.isReturningKeywordPresent());
+
+    queries = Parser.parseJdbcSql("insert into foo (a,b,c) values (?,?,?)", true, true, false, true, true);
+    query = queries.get(0);
+    assertFalse("The parser should not find the word returning", query.command.isReturningKeywordPresent());
+
+    queries = Parser.parseJdbcSql("insert into foo (a,b,c) values ('returning',?,?)", true, true, false, true, true);
+    query = queries.get(0);
+    assertFalse("The parser should not find the word returning as it is in quotes ", query.command.isReturningKeywordPresent());
+
+    queries = Parser.parseJdbcSql("select 1 as returning", true, true, false, true, true);
+    query = queries.get(0);
+    assertFalse("This is not an insert command", query.command.getType() == SqlCommandType.INSERT);
+    assertTrue("Returning is OK here as it is not an insert command ", query.command.isReturningKeywordPresent());
+
+  }
+
+  public void testHasDelete() {
+    List<NativeQuery> queries = Parser.parseJdbcSql("DeLeTe from foo where a=1", true, true, false, true, true);
+    NativeQuery query = queries.get(0);
+    assertTrue("This is a delete command", query.command.getType() == SqlCommandType.DELETE);
+
+    queries = Parser.parseJdbcSql("update foo set (a=?,b=?,c=?)", true, true, false, true, true);
+    query = queries.get(0);
+    assertFalse("This is not a delete command", query.command.getType() == SqlCommandType.DELETE);
+
+  }
+
+
+  public void testisMove() {
+
+    List<NativeQuery> queries = Parser.parseJdbcSql("MoVe NEXT FROM FOO", true, true, false, true, true);
+    NativeQuery query = queries.get(0);
+    assertTrue("This is a move command", query.command.getType() == SqlCommandType.MOVE);
+
+    queries = Parser.parseJdbcSql("update foo set (a=?,b=?,c=?)", true, true, false, true, true);
+    query = queries.get(0);
+    assertFalse("This is not a move command", query.command.getType() == SqlCommandType.MOVE);
+
+  }
+
+  public void testIsInsert() {
+
+    List<NativeQuery> queries = Parser.parseJdbcSql("InSeRt into foo (a,b,c) values (?,?,?) returning a", true, true, false, true, true);
+    NativeQuery query = queries.get(0);
+    assertTrue("This is an insert command", query.command.getType() == SqlCommandType.INSERT);
+
+    queries = Parser.parseJdbcSql("update foo set (a=?,b=?,c=?)", true, true, false, true, true);
+    query = queries.get(0);
+    assertFalse("This is not an insert command", query.command.getType() == SqlCommandType.INSERT);
+
+    queries = Parser.parseJdbcSql("select 1 as insert", true, true, false, true, true);
+    query = queries.get(0);
+    assertFalse("This is not insert command", query.command.getType() == SqlCommandType.INSERT);
+  }
+
   public void testMultipleEmptyQueries() {
     assertEquals("select 1;/*cut*/\n" + "select 2",
         reparse("select 1; ;\t;select 2", true, false, true));
@@ -80,7 +141,7 @@ public void testCompositeWithComments() {
   private String reparse(String query, boolean standardConformingStrings, boolean withParameters,
       boolean splitStatements) {
     return toString(
-        Parser.parseJdbcSql(query, standardConformingStrings, withParameters, splitStatements));
+        Parser.parseJdbcSql(query, standardConformingStrings, withParameters, splitStatements, true, false));
   }
 
   private String toString(List<NativeQuery> queries) {
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc3/Jdbc3CallableStatementTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc3/Jdbc3CallableStatementTest.java
index 12b575e6a9..9b7cc46e3e 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc3/Jdbc3CallableStatementTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc3/Jdbc3CallableStatementTest.java
@@ -27,7 +27,7 @@
  */
 public class Jdbc3CallableStatementTest extends TestCase {
 
-  Connection con;
+  private Connection con;
 
   /*
    * (non-Javadoc)
@@ -304,8 +304,8 @@ public void testInOut() throws Throwable {
       cstmt.registerOutParameter(3, Types.BIT);
       cstmt.executeUpdate();
 
-      assertTrue(cstmt.getBoolean(1) == true);
-      assertTrue(cstmt.getBoolean(2) == false);
+      assertTrue(cstmt.getBoolean(1));
+      assertFalse(cstmt.getBoolean(2));
       cstmt.getBoolean(3);
       assertTrue(cstmt.wasNull());
     } finally {
@@ -349,8 +349,8 @@ public void testSetObjectBit() throws Throwable {
       ResultSet rs = con.createStatement().executeQuery("select * from bit_tab");
 
       assertTrue(rs.next());
-      assertTrue(rs.getBoolean(1) == true);
-      assertTrue(rs.getBoolean(2) == false);
+      assertTrue(rs.getBoolean(1));
+      assertFalse(rs.getBoolean(2));
       rs.getBoolean(3);
       assertTrue(rs.wasNull());
     } catch (Exception ex) {
@@ -893,7 +893,7 @@ public void testGetBoolean01() throws Throwable {
       cstmt.registerOutParameter(3, java.sql.Types.BIT);
       cstmt.executeUpdate();
       assertTrue(cstmt.getBoolean(1));
-      assertTrue(cstmt.getBoolean(2) == false);
+      assertFalse(cstmt.getBoolean(2));
       cstmt.getBoolean(3);
       assertTrue(cstmt.wasNull());
     } catch (Exception ex) {
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc4/ArrayTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc4/ArrayTest.java
index 9b69dd4934..5bc63142ee 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc4/ArrayTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc4/ArrayTest.java
@@ -53,7 +53,8 @@ public void setUp() throws Exception {
     _conn = con;
 
     TestUtil.createTable(_conn, "arrtest",
-        "intarr int[], decarr decimal(2,1)[], strarr text[], uuidarr uuid[], floatarr float8[]");
+        "intarr int[], decarr decimal(2,1)[], strarr text[], uuidarr uuid[], floatarr float8[]"
+        + ", intarr2 int4[][]");
     TestUtil.createTable(_conn, "arrcompprnttest", "id serial, name character(10)");
     TestUtil.createTable(_conn, "arrcompchldttest",
         "id serial, name character(10), description character varying, parent integer");
@@ -470,4 +471,43 @@ public void testToString() throws SQLException {
       TestUtil.closeQuietly(stmt);
     }
   }
+
+  @Test
+  public void nullArray() throws SQLException {
+    PreparedStatement ps = con.prepareStatement("INSERT INTO arrtest(floatarr) VALUES (?)");
+
+    ps.setNull(1, Types.ARRAY, "float8");
+    ps.execute();
+
+    ps.close();
+    ps = con.prepareStatement("select floatarr from arrtest");
+    ResultSet rs = ps.executeQuery();
+    Assert.assertTrue("arrtest should contain a row", rs.next());
+    Array getArray = rs.getArray(1);
+    Assert.assertNull("null array should return null value on getArray", getArray);
+    Object getObject = rs.getObject(1);
+    Assert.assertNull("null array should return null on getObject", getObject);
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void createNullArray() throws SQLException {
+    Array arr = con.createArrayOf("float8", null);
+    Assert.fail("createArrayOf(float8, null) should fail with NPE");
+  }
+
+  @Test
+  public void multiDimIntArray() throws SQLException {
+    Array arr = con.createArrayOf("int4", new int[][]{{1,2}, {3,4}});
+    PreparedStatement ps = con.prepareStatement("select ?::int4[][]");
+    ps.setArray(1, arr);
+    ResultSet rs = ps.executeQuery();
+    rs.next();
+    Array resArray = rs.getArray(1);
+    String stringValue = resArray.toString();
+    // Both {{"1","2"},{"3","4"}} and {{1,2},{3,4}} are the same array representation
+    stringValue = stringValue.replaceAll("\"", "");
+    Assert.assertEquals("{{1,2},{3,4}}", stringValue);
+    TestUtil.closeQuietly(rs);
+    TestUtil.closeQuietly(ps);
+  }
 }
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc4/BlobTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc4/BlobTest.java
index 64893ce9a2..41e1b10014 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc4/BlobTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc4/BlobTest.java
@@ -47,9 +47,8 @@ protected void tearDown() throws Exception {
   }
 
   public void testSetBlobWithStream() throws Exception {
-    byte[] data = new String(
-        "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque bibendum dapibus varius.")
-            .getBytes("UTF-8");
+    byte[] data = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque bibendum dapibus varius."
+        .getBytes("UTF-8");
     PreparedStatement insertPS = _conn.prepareStatement(TestUtil.insertSQL("testblob", "lo", "?"));
     try {
       insertPS.setBlob(1, new ByteArrayInputStream(data));
@@ -73,11 +72,10 @@ public void testSetBlobWithStream() throws Exception {
   }
 
   public void testSetBlobWithStreamAndLength() throws Exception {
-    byte[] fullData = new String(
-        "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse placerat tristique tellus, id tempus lectus.")
+    byte[] fullData = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse placerat tristique tellus, id tempus lectus."
             .getBytes("UTF-8");
     byte[] data =
-        new String("Lorem ipsum dolor sit amet, consectetur adipiscing elit.").getBytes("UTF-8");
+       "Lorem ipsum dolor sit amet, consectetur adipiscing elit.".getBytes("UTF-8");
     PreparedStatement insertPS = _conn.prepareStatement(TestUtil.insertSQL("testblob", "lo", "?"));
     try {
       insertPS.setBlob(1, new ByteArrayInputStream(fullData), data.length);
@@ -102,7 +100,7 @@ public void testSetBlobWithStreamAndLength() throws Exception {
 
   public void testGetBinaryStreamWithBoundaries() throws Exception {
     byte[] data =
-        new String("Cras vestibulum tellus eu sapien imperdiet ornare.").getBytes("UTF-8");
+        "Cras vestibulum tellus eu sapien imperdiet ornare.".getBytes("UTF-8");
     PreparedStatement insertPS = _conn.prepareStatement(TestUtil.insertSQL("testblob", "lo", "?"));
     try {
       insertPS.setBlob(1, new ByteArrayInputStream(data), data.length);
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc4/ClientInfoTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc4/ClientInfoTest.java
index ee737cabbd..c8d146f287 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc4/ClientInfoTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc4/ClientInfoTest.java
@@ -56,6 +56,22 @@ public void testSetAppName() throws SQLException {
     assertEquals("my app", _conn.getClientInfo().getProperty("ApplicationName"));
   }
 
+  public void testExplicitSetAppNameNotificationIsParsed() throws SQLException {
+    if (!TestUtil.haveMinimumServerVersion(_conn, "9.0")) {
+      return;
+    }
+
+    String appName = "test-42";
+
+    Statement s = _conn.createStatement();
+    s.execute("set application_name='" + appName + "'");
+    s.close();
+    assertEquals("application_name was set to " + appName + ", and it should be visible via "
+        + "con.getClientInfo", appName, _conn.getClientInfo("ApplicationName"));
+    assertEquals("application_name was set to " + appName + ", and it should be visible via "
+        + "con.getClientInfo", appName, _conn.getClientInfo().get("ApplicationName"));
+  }
+
   public void testSetAppNameProps() throws SQLException {
     if (!TestUtil.haveMinimumServerVersion(_conn, "9.0")) {
       return;
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc4/WrapperTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc4/WrapperTest.java
index 39a41144e3..525d9e0545 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc4/WrapperTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc4/WrapperTest.java
@@ -10,6 +10,7 @@
 
 import org.postgresql.PGConnection;
 import org.postgresql.PGStatement;
+import org.postgresql.ds.PGSimpleDataSource;
 import org.postgresql.test.TestUtil;
 
 import junit.framework.TestCase;
@@ -43,8 +44,6 @@ protected void tearDown() throws SQLException {
   private static interface PrivateInterface {
   }
 
-  ;
-
   public void testConnectionIsWrapperForPrivate() throws SQLException {
     assertFalse(_conn.isWrapperFor(PrivateInterface.class));
   }
@@ -77,6 +76,19 @@ public void testConnectionUnwrapPGConnection() throws SQLException {
     assertTrue(v instanceof PGConnection);
   }
 
+  public void testConnectionUnwrapPGDataSource() throws SQLException {
+    PGSimpleDataSource dataSource = new PGSimpleDataSource();
+    dataSource.setDatabaseName(TestUtil.getDatabase());
+    dataSource.setServerName(TestUtil.getServer());
+    dataSource.setPortNumber(TestUtil.getPort());
+    Connection connection = dataSource.getConnection(TestUtil.getUser(), TestUtil.getPassword());
+    assertNotNull("Unable to obtain a connection from PGSimpleDataSource", connection);
+    Object v = connection.unwrap(PGConnection.class);
+    assertTrue("connection.unwrap(PGConnection.class) should return PGConnection instance"
+            + ", actual instance is " + v,
+        v instanceof PGConnection);
+  }
+
   public void testStatementIsWrapperForPrivate() throws SQLException {
     assertFalse(_statement.isWrapperFor(PrivateInterface.class));
   }
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc42/CustomizeDefaultFetchSizeTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc42/CustomizeDefaultFetchSizeTest.java
index 8153fd4753..02f84ec832 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc42/CustomizeDefaultFetchSizeTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc42/CustomizeDefaultFetchSizeTest.java
@@ -1,7 +1,7 @@
 package org.postgresql.test.jdbc42;
 
-import static junit.framework.Assert.fail;
 import static org.hamcrest.MatcherAssert.assertThat;
+import static org.junit.Assert.fail;
 
 import org.postgresql.PGProperty;
 import org.postgresql.test.TestUtil;
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc42/Jdbc42TestSuite.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc42/Jdbc42TestSuite.java
index 3a53c15377..faf86cc7c8 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc42/Jdbc42TestSuite.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc42/Jdbc42TestSuite.java
@@ -17,6 +17,7 @@
     SimpleJdbc42Test.class,
     CustomizeDefaultFetchSizeTest.class,
     GetObject310Test.class,
+    PreparedStatementTest.class,
     GetObject310BinaryTest.class,
     SetObject310Test.class})
 public class Jdbc42TestSuite {
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc42/PreparedStatementTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc42/PreparedStatementTest.java
new file mode 100644
index 0000000000..a0601a70cc
--- /dev/null
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc42/PreparedStatementTest.java
@@ -0,0 +1,64 @@
+/*-------------------------------------------------------------------------
+*
+* Copyright (c) 2004-2014, PostgreSQL Global Development Group
+*
+*
+*-------------------------------------------------------------------------
+*/
+
+package org.postgresql.test.jdbc42;
+
+import org.postgresql.test.TestUtil;
+import org.postgresql.test.jdbc2.BaseTest;
+
+import java.sql.PreparedStatement;
+import java.sql.SQLException;
+import java.sql.Types;
+
+
+public class PreparedStatementTest extends BaseTest {
+
+  public PreparedStatementTest(String name) {
+    super(name);
+  }
+
+  protected void setUp() throws Exception {
+    super.setUp();
+    TestUtil.createTable(con, "timestamptztable", "tstz timestamptz");
+    TestUtil.createTable(con, "timetztable", "ttz timetz");
+  }
+
+  protected void tearDown() throws SQLException {
+    TestUtil.dropTable(con, "timestamptztable");
+    TestUtil.dropTable(con, "timetztable");
+    super.tearDown();
+  }
+
+  public void testTimestampTzSetNull() throws SQLException {
+    PreparedStatement pstmt = con.prepareStatement("INSERT INTO timestamptztable (tstz) VALUES (?)");
+
+    // valid: fully qualified type to setNull()
+    pstmt.setNull(1, Types.TIMESTAMP_WITH_TIMEZONE);
+    pstmt.executeUpdate();
+
+    // valid: fully qualified type to setObject()
+    pstmt.setObject(1, null, Types.TIMESTAMP_WITH_TIMEZONE);
+    pstmt.executeUpdate();
+
+    pstmt.close();
+  }
+
+  public void testTimeTzSetNull() throws SQLException {
+    PreparedStatement pstmt = con.prepareStatement("INSERT INTO timetztable (ttz) VALUES (?)");
+
+    // valid: fully qualified type to setNull()
+    pstmt.setNull(1, Types.TIME_WITH_TIMEZONE);
+    pstmt.executeUpdate();
+
+    // valid: fully qualified type to setObject()
+    pstmt.setObject(1, null, Types.TIME_WITH_TIMEZONE);
+    pstmt.executeUpdate();
+
+    pstmt.close();
+  }
+}
diff --git a/pgjdbc/src/test/java/org/postgresql/test/socketfactory/SocketFactoryTestSuite.java b/pgjdbc/src/test/java/org/postgresql/test/socketfactory/SocketFactoryTestSuite.java
index 3fc0a66692..ccebc2213f 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/socketfactory/SocketFactoryTestSuite.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/socketfactory/SocketFactoryTestSuite.java
@@ -1,9 +1,11 @@
 package org.postgresql.test.socketfactory;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
 import org.postgresql.PGProperty;
 import org.postgresql.test.TestUtil;
 
-import junit.framework.TestCase;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -11,7 +13,7 @@
 import java.sql.Connection;
 import java.util.Properties;
 
-public class SocketFactoryTestSuite extends TestCase {
+public class SocketFactoryTestSuite {
 
   private static final String STRING_ARGUMENT = "name of a socket";
 
diff --git a/pgjdbc/src/test/java/org/postgresql/test/ssl/SingleCertValidatingFactoryTestSuite.java b/pgjdbc/src/test/java/org/postgresql/test/ssl/SingleCertValidatingFactoryTestSuite.java
index 3e93cc7fb3..539ebaeb0c 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/ssl/SingleCertValidatingFactoryTestSuite.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/ssl/SingleCertValidatingFactoryTestSuite.java
@@ -354,7 +354,7 @@ public static String loadFile(String path) {
     try {
       br = new BufferedReader(new InputStreamReader(new FileInputStream(path)));
       StringBuilder sb = new StringBuilder();
-      String line = null;
+      String line;
       while ((line = br.readLine()) != null) {
         sb.append(line);
         sb.append("\n");
diff --git a/pgjdbc/src/test/java/org/postgresql/test/ssl/SslTest.java b/pgjdbc/src/test/java/org/postgresql/test/ssl/SslTest.java
index 746889bb0e..81e8032fb8 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/ssl/SslTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/ssl/SslTest.java
@@ -87,28 +87,26 @@ static TestSuite getSuite(Properties prop, String param) {
     String certdir = certDirFile.getAbsolutePath();
     String sconnstr = prop.getProperty(param);
     String sprefix = prop.getProperty(param + "prefix");
-    String[] csslmode = {"disable", "allow", "prefer", "require", "verify-ca", "verify-full"};
+    String[] sslModes = {"disable", "allow", "prefer", "require", "verify-ca", "verify-full"};
 
     TestSuite suite = new TestSuite();
     Map<String, Object[]> expected = expectedmap.get(param);
     if (expected == null) {
-      ;
       expected = defaultexpected;
     }
-    int j = 0;
-    for (int i = 0; i < csslmode.length; i++) {
-      suite.addTest(new SslTest(param + "-" + csslmode[i] + "GG2", certdir, sconnstr, csslmode[i],
-          2, true, true, sprefix, expected.get(csslmode[i] + "GG")));
-      suite.addTest(new SslTest(param + "-" + csslmode[i] + "GG3", certdir, sconnstr, csslmode[i],
-          3, true, true, sprefix, expected.get(csslmode[i] + "GG")));
-      suite.addTest(new SslTest(param + "-" + csslmode[i] + "GB2", certdir, sconnstr, csslmode[i],
-          2, true, false, sprefix, expected.get(csslmode[i] + "GB")));
-      suite.addTest(new SslTest(param + "-" + csslmode[i] + "GB3", certdir, sconnstr, csslmode[i],
-          3, true, false, sprefix, expected.get(csslmode[i] + "GB")));
-      suite.addTest(new SslTest(param + "-" + csslmode[i] + "BG2", certdir, sconnstr, csslmode[i],
-          2, false, true, sprefix, expected.get(csslmode[i] + "BG")));
-      suite.addTest(new SslTest(param + "-" + csslmode[i] + "BG3", certdir, sconnstr, csslmode[i],
-          3, false, true, sprefix, expected.get(csslmode[i] + "BG")));
+    for (String sslMode : sslModes) {
+      suite.addTest(new SslTest(param + "-" + sslMode + "GG2", certdir, sconnstr, sslMode,
+          2, true, true, sprefix, expected.get(sslMode + "GG")));
+      suite.addTest(new SslTest(param + "-" + sslMode + "GG3", certdir, sconnstr, sslMode,
+          3, true, true, sprefix, expected.get(sslMode + "GG")));
+      suite.addTest(new SslTest(param + "-" + sslMode + "GB2", certdir, sconnstr, sslMode,
+          2, true, false, sprefix, expected.get(sslMode + "GB")));
+      suite.addTest(new SslTest(param + "-" + sslMode + "GB3", certdir, sconnstr, sslMode,
+          3, true, false, sprefix, expected.get(sslMode + "GB")));
+      suite.addTest(new SslTest(param + "-" + sslMode + "BG2", certdir, sconnstr, sslMode,
+          2, false, true, sprefix, expected.get(sslMode + "BG")));
+      suite.addTest(new SslTest(param + "-" + sslMode + "BG3", certdir, sconnstr, sslMode,
+          3, false, true, sprefix, expected.get(sslMode + "BG")));
     }
     return suite;
   }
diff --git a/pgjdbc/src/test/java/org/postgresql/test/ssl/SslTestSuite.java b/pgjdbc/src/test/java/org/postgresql/test/ssl/SslTestSuite.java
index 0b41bf23c8..f984aed652 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/ssl/SslTestSuite.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/ssl/SslTestSuite.java
@@ -7,6 +7,7 @@
 import java.util.Properties;
 
 public class SslTestSuite extends TestSuite {
+  private static Properties prop;
 
   private static void add(TestSuite suite, String param) {
     if (prop.getProperty(param, "").equals("")) {
@@ -16,8 +17,6 @@ private static void add(TestSuite suite, String param) {
     }
   }
 
-  static Properties prop;
-
   /*
    * The main entry point for JUnit
    */
@@ -29,13 +28,13 @@ public static TestSuite suite() throws Exception {
     add(suite, "ssloff9");
     add(suite, "sslhostnossl9");
 
-    String[] hostmode = {"sslhost", "sslhostssl", "sslhostsslcert", "sslcert"};
-    String[] certmode = {"gh", "bh"};
+    String[] hostModes = {"sslhost", "sslhostssl", "sslhostsslcert", "sslcert"};
+    String[] certModes = {"gh", "bh"};
 
-    for (int i = 0; i < hostmode.length; i++) {
-      for (int j = 0; j < certmode.length; j++) {
-        add(suite, hostmode[i] + certmode[j] + "8");
-        add(suite, hostmode[i] + certmode[j] + "9");
+    for (String hostMode : hostModes) {
+      for (String certMode : certModes) {
+        add(suite, hostMode + certMode + "8");
+        add(suite, hostMode + certMode + "9");
       }
     }
 
diff --git a/pgjdbc/src/test/java/org/postgresql/test/sspi/SSPITest.java b/pgjdbc/src/test/java/org/postgresql/test/sspi/SSPITest.java
new file mode 100644
index 0000000000..b17e90d85a
--- /dev/null
+++ b/pgjdbc/src/test/java/org/postgresql/test/sspi/SSPITest.java
@@ -0,0 +1,71 @@
+package org.postgresql.test.sspi;
+
+import static org.hamcrest.CoreMatchers.containsString;
+import static org.hamcrest.CoreMatchers.is;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeThat;
+
+import org.postgresql.test.TestUtil;
+import org.postgresql.util.PSQLException;
+import org.postgresql.util.PSQLState;
+
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import java.sql.Connection;
+import java.sql.Statement;
+import java.util.Properties;
+
+/*
+ * These tests require a working SSPI authentication setup
+ * in the database server that allows the executing user
+ * to authenticate as the "sspiusername" in the build
+ * configuration.
+ */
+public class SSPITest {
+
+  /*
+   * SSPI only exists on Windows.
+   */
+  @BeforeClass
+  public static void checkPlatform() {
+    assumeThat("SSPI not supported on this platform",
+               System.getProperty("os.name").toLowerCase(),
+               containsString("windows"));
+  }
+
+  /*
+   * Tests that SSPI login succeeds and a query can be run.
+   */
+  @Test
+  public void testAuthorized() throws Exception {
+    Properties props = new Properties();
+    props.setProperty("username", TestUtil.getSSPIUser());
+    Connection con = TestUtil.openDB(props);
+
+    Statement stmt = con.createStatement();
+    stmt.executeQuery("SELECT 1");
+
+    TestUtil.closeDB(con);
+  }
+
+  /*
+   * Tests that SSPI login fails with an unknown/unauthorized
+   * user name.
+   */
+  @Test
+  public void testUnauthorized() throws Exception {
+    Properties props = new Properties();
+    props.setProperty("username", "invalid" + TestUtil.getSSPIUser());
+
+    try {
+      Connection con = TestUtil.openDB(props);
+      TestUtil.closeDB(con);
+      fail("Expected a PSQLException");
+    } catch (PSQLException e) {
+      assertThat(e.getSQLState(), is(PSQLState.INVALID_AUTHORIZATION_SPECIFICATION.getState()));
+    }
+  }
+
+}
diff --git a/pgjdbc/src/test/java/org/postgresql/test/sspi/SSPITestSuite.java b/pgjdbc/src/test/java/org/postgresql/test/sspi/SSPITestSuite.java
new file mode 100644
index 0000000000..652a72dfc1
--- /dev/null
+++ b/pgjdbc/src/test/java/org/postgresql/test/sspi/SSPITestSuite.java
@@ -0,0 +1,13 @@
+package org.postgresql.test.sspi;
+
+import org.junit.runner.RunWith;
+import org.junit.runners.Suite;
+
+/*
+ * Executes all known tests for SSPI.
+ */
+@RunWith(Suite.class)
+@Suite.SuiteClasses({ SSPITest.class })
+public class SSPITestSuite {
+  // Empty.
+}
diff --git a/pgjdbc/src/test/java/org/postgresql/test/util/LruCacheTest.java b/pgjdbc/src/test/java/org/postgresql/test/util/LruCacheTest.java
index f670e0a767..e3da341050 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/util/LruCacheTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/util/LruCacheTest.java
@@ -22,7 +22,7 @@
  * Tests {@link org.postgresql.util.LruCache}
  */
 public class LruCacheTest extends TestCase {
-  static class Entry implements CanEstimateSize {
+  private static class Entry implements CanEstimateSize {
     private final int id;
 
     Entry(int id) {
@@ -48,7 +48,7 @@ public String toString() {
 
   @Override
   protected void setUp() throws Exception {
-    cache = new LruCache<Integer, Entry>(3, 1000, new LruCache.CreateAction<Integer, Entry>() {
+    cache = new LruCache<Integer, Entry>(3, 1000, false, new LruCache.CreateAction<Integer, Entry>() {
       @Override
       public Entry create(Integer key) throws SQLException {
         assertEquals("Unexpected create", expectCreate[0], key);
@@ -142,11 +142,10 @@ public void testCaching() throws SQLException {
   }
 
   private Entry use(int expectCreate, Entry... expectEvict) throws SQLException {
-    Entry a;
     this.expectCreate[0] = expectCreate <= 0 ? -1 : expectCreate;
     this.expectEvict.clear();
     this.expectEvict.addAll(Arrays.asList(expectEvict));
-    a = cache.borrow(Math.abs(expectCreate));
+    Entry a = cache.borrow(Math.abs(expectCreate));
     cache.put(a.id, a); // a
     return a;
   }
diff --git a/pom.xml b/pom.xml
index de368a9cf8..70e9b2d3e3 100644
--- a/pom.xml
+++ b/pom.xml
@@ -3,13 +3,13 @@
   <parent>
     <groupId>org.postgresql</groupId>
     <artifactId>pgjdbc-versions</artifactId>
-    <version>1.0.5</version>
+    <version>1.0.8</version>
   </parent>
 
   <artifactId>pgjdbc-aggregate</artifactId>
   <packaging>pom</packaging>
   <name>PostgreSQL JDBC Driver aggregate</name>
-  <version>9.4.1208</version>
+  <version>9.4.1209</version>
   <description>PgJDBC aggregate project</description>
   <url>https://github.com/pgjdbc/pgjdbc</url>
 
@@ -23,7 +23,7 @@
     <url>https://github.com/pgjdbc/pgjdbc</url>
     <connection>scm:git:https://github.com/pgjdbc/pgjdbc.git</connection>
     <developerConnection>scm:git:git@github.com:pgjdbc/pgjdbc.git</developerConnection>
-    <tag>REL9.4.1208</tag>
+    <tag>REL9.4.1209</tag>
   </scm>
 
 </project>
diff --git a/toolchains.xml b/toolchains.xml
index edc125e656..3cd8f87941 100644
--- a/toolchains.xml
+++ b/toolchains.xml
@@ -39,4 +39,14 @@
       <jdkHome>${JDK8_HOME}</jdkHome>
     </configuration>
   </toolchain>
+  <toolchain>
+    <type>jdk</type>
+    <provides>
+      <version>1.9</version>
+      <vendor>oracle</vendor>
+    </provides>
+    <configuration>
+      <jdkHome>${JDK9_HOME}</jdkHome>
+    </configuration>
+  </toolchain>
 </toolchains>
diff --git a/travis_build.sh b/travis_build.sh
index f08416550f..c18ffd2021 100755
--- a/travis_build.sh
+++ b/travis_build.sh
@@ -1,16 +1,38 @@
 #!/usr/bin/env bash
 set -x -e
 
+if [[ "${FEDORA_CI}" == *"Y" ]];
+then
+  PARENT_VERSION=$(mvn -B -N org.apache.maven.plugins:maven-help-plugin:2.1.1:evaluate -Dexpression=project.parent.version | grep -v '\[')
+  sed -i "s/^%global parent_ver	.*/%global parent_ver	${PARENT_VERSION}/" packaging/rpm/postgresql-jdbc.spec.tpl
+  exec ./packaging/rpm_ci
+fi
+
 # Build project
-MVN_ARGS="clean package -B -V"
+MVN_ARGS="clean package -B -V $MVN_CUSTOM_ARGS"
 MVN_PROFILES="release"
 
+if [[ "${NO_WAFFLE_NO_OSGI}" == *"Y"* ]];
+then
+    MVN_ARGS="$MVN_ARGS -DwaffleEnabled=false -DosgiEnabled=false -DexcludePackageNames=org.postgresql.osgi:org.postgresql.sspi"
+fi
+
 if [[ "${COVERAGE}" == *"Y"* ]];
 then
     MVN_PROFILES="$MVN_PROFILES,coverage"
 fi
 
-if [[ "${TRAVIS_JDK_VERSION}" == *"jdk6"* ]];
+if [[ "${JDK}" == *"9"* ]];
+then
+    export MAVEN_SKIP_RC=true
+    MVN_ARGS="$MVN_ARGS -Dcurrent.jdk=1.9 -Djavac.target=1.9"
+fi
+
+if [[ "$JDOC" == *"Y"* ]];
+then
+    # Build javadocs for Java 8 only
+    mvn ${MVN_ARGS} -P ${MVN_PROFILES},release-artifacts
+elif [[ "${TRAVIS_JDK_VERSION}" == *"jdk6"* ]];
 then
     git clone --depth=50 https://github.com/pgjdbc/pgjdbc-jre6.git pgjdbc-jre6
     cd pgjdbc-jre6
@@ -20,10 +42,6 @@ then
     git clone --depth=50 https://github.com/pgjdbc/pgjdbc-jre7.git pgjdbc-jre7
     cd pgjdbc-jre7
     mvn ${MVN_ARGS} -P ${MVN_PROFILES},skip-unzip-jdk
-elif [ "${PG_VERSION}" == "9.4" ];
-then
-# Build javadocs for Java 8 and PG 9.4 only
-    mvn ${MVN_ARGS} -P ${MVN_PROFILES},release-artifacts
 else
     mvn ${MVN_ARGS} -P ${MVN_PROFILES}
 fi
diff --git a/travis_install_dependencies.sh b/travis_install_dependencies.sh
index 105850d570..7633b86ff2 100755
--- a/travis_install_dependencies.sh
+++ b/travis_install_dependencies.sh
@@ -6,7 +6,7 @@ sudo service postgresql stop
 sudo cp /etc/postgresql/9.1/main/pg_hba.conf ./
 sudo apt-get remove postgresql libpq-dev libpq5 postgresql-client-common postgresql-common -qq --purge
 source /etc/lsb-release
-echo "deb http://apt.postgresql.org/pub/repos/apt/ $DISTRIB_CODENAME-pgdg main" > pgdg.list
+echo "deb http://apt.postgresql.org/pub/repos/apt/ $DISTRIB_CODENAME-pgdg main ${PG_VERSION}" > pgdg.list
 sudo mv pgdg.list /etc/apt/sources.list.d/
 wget --quiet -O - https://apt.postgresql.org/pub/repos/apt/ACCC4CF8.asc | sudo apt-key add -
 sudo apt-get update
diff --git a/ubenchmark/pom.xml b/ubenchmark/pom.xml
index d20f17a44f..e94b6c7859 100644
--- a/ubenchmark/pom.xml
+++ b/ubenchmark/pom.xml
@@ -31,14 +31,14 @@ POSSIBILITY OF SUCH DAMAGE.
   <parent>
     <groupId>org.postgresql</groupId>
     <artifactId>pgjdbc-versions</artifactId>
-    <version>1.0.4</version>
+    <version>1.0.8</version>
     <relativePath />
   </parent>
 
   <artifactId>pgjdbc-benchmark</artifactId>
   <packaging>jar</packaging>
   <name>PostgreSQL JDBC Driver - benchmarks</name>
-  <version>9.4.1208</version>
+  <version>9.4.1209</version>
   <description>PostgreSQL JDBC Driver - benchmarks</description>
   <url>https://github.com/pgjdbc/pgjdbc</url>
 
@@ -67,12 +67,38 @@ POSSIBILITY OF SUCH DAMAGE.
   </dependencies>
 
   <properties>
-    <jmh.version>1.11.2</jmh.version>
+    <jmh.version>1.12</jmh.version>
     <uberjar.name>benchmarks</uberjar.name>
     <current.jdk>1.8</current.jdk>
+    <javac.target>${current.jdk}</javac.target>
   </properties>
 
   <build>
+    <pluginManagement>
+      <plugins>
+        <plugin>
+          <groupId>org.apache.maven.plugins</groupId>
+          <artifactId>maven-checkstyle-plugin</artifactId>
+          <version>2.17</version>
+          <dependencies>
+            <dependency>
+              <groupId>com.puppycrawl.tools</groupId>
+              <artifactId>checkstyle</artifactId>
+              <version>6.13</version>
+            </dependency>
+          </dependencies>
+          <configuration>
+            <configLocation>../pgjdbc/src/main/checkstyle/checks.xml</configLocation>
+            <violationSeverity>error</violationSeverity>
+            <failOnViolation>true</failOnViolation>
+            <failsOnError>true</failsOnError>
+            <consoleOutput>true</consoleOutput>
+            <includeTestSourceDirectory>true</includeTestSourceDirectory>
+          </configuration>
+        </plugin>
+      </plugins>
+    </pluginManagement>
+
     <plugins>
       <plugin>
         <groupId>com.igormaznitsa</groupId>
@@ -129,7 +155,7 @@ POSSIBILITY OF SUCH DAMAGE.
         <jdk>1.6</jdk>
       </activation>
       <properties>
-        <current.jdk>1.7</current.jdk>
+        <current.jdk>1.6</current.jdk>
       </properties>
     </profile>
     <profile>
@@ -156,9 +182,63 @@ POSSIBILITY OF SUCH DAMAGE.
         </plugins>
       </build>
     </profile>
+    <profile>
+      <id>jdk9-workarounds</id>
+      <!-- see https://github.com/pgjdbc/pgjdbc/pull/565 -->
+      <activation>
+        <property>
+          <name>javac.target</name>
+          <value>1.9</value>
+        </property>
+      </activation>
+      <build>
+        <pluginManagement>
+          <plugins>
+            <plugin>
+              <groupId>org.apache.maven.plugins</groupId>
+              <artifactId>maven-source-plugin</artifactId>
+              <dependencies>
+                <dependency>
+                  <groupId>org.codehaus.plexus</groupId>
+                  <artifactId>plexus-archiver</artifactId>
+                  <version>2.4.4</version>
+                  <!-- newer versions fail as described in http://stackoverflow.com/a/36605759/1261287
+                       Caused by: java.lang.ArrayIndexOutOfBoundsException: 1
+                        at org.codehaus.plexus.archiver.zip.AbstractZipArchiver.<clinit>(AbstractZipArchiver.java:116)
+                  -->
+                </dependency>
+              </dependencies>
+            </plugin>
+            <plugin>
+              <groupId>org.apache.maven.plugins</groupId>
+              <artifactId>maven-jar-plugin</artifactId>
+              <dependencies>
+                <dependency>
+                  <groupId>org.codehaus.plexus</groupId>
+                  <artifactId>plexus-archiver</artifactId>
+                  <version>2.4.4</version>
+                </dependency>
+              </dependencies>
+            </plugin>
+            <plugin>
+              <groupId>org.apache.maven.plugins</groupId>
+              <artifactId>maven-assembly-plugin</artifactId>
+              <version>2.4.1</version> <!-- override version to older one -->
+              <dependencies>
+                <dependency>
+                  <groupId>org.codehaus.plexus</groupId>
+                  <artifactId>plexus-archiver</artifactId>
+                  <version>2.4.4</version>
+                </dependency>
+              </dependencies>
+            </plugin>
+          </plugins>
+        </pluginManagement>
+      </build>
+    </profile>
   </profiles>
 
   <scm>
-    <tag>REL9.4.1208</tag>
+    <tag>REL9.4.1209</tag>
   </scm>
 </project>
diff --git a/ubenchmark/src/main/java/org/postgresql/benchmark/statement/InsertBatch.java b/ubenchmark/src/main/java/org/postgresql/benchmark/statement/InsertBatch.java
index bf50b09b2a..fa2e0438fd 100644
--- a/ubenchmark/src/main/java/org/postgresql/benchmark/statement/InsertBatch.java
+++ b/ubenchmark/src/main/java/org/postgresql/benchmark/statement/InsertBatch.java
@@ -28,13 +28,11 @@
 import org.openjdk.jmh.annotations.Warmup;
 import org.openjdk.jmh.infra.BenchmarkParams;
 import org.openjdk.jmh.infra.Blackhole;
-import org.openjdk.jmh.profile.GCProfiler;
 import org.openjdk.jmh.runner.Runner;
 import org.openjdk.jmh.runner.RunnerException;
 import org.openjdk.jmh.runner.options.Options;
 import org.openjdk.jmh.runner.options.OptionsBuilder;
 
-import java.io.CharArrayReader;
 import java.io.CharArrayWriter;
 import java.io.IOException;
 import java.sql.Connection;
@@ -79,6 +77,11 @@ public void setUp(BenchmarkParams bp) throws SQLException {
 
     Properties props = ConnectionUtil.getProperties();
 
+    if (bp.getBenchmark().contains("insertBatchWithRewrite")) {
+      // PGProperty.REWRITE_BATCHED_INSERTS is not used for easier use with previous pgjdbc versions
+      props.put("reWriteBatchedInserts", "true");
+    }
+
     connection = DriverManager.getConnection(ConnectionUtil.getURL(), props);
     Statement s = connection.createStatement();
     ;
@@ -118,9 +121,12 @@ public int[] insertBatch() throws SQLException {
       // Multi values(),(),() case
       for (int i = 0; i < p1nrows; ) {
         for (int k = 0, pos = 1; k < p2multi; k++, i++) {
-          ps.setInt(pos, i); pos++;
-          ps.setString(pos, strings[i]); pos++;
-          ps.setInt(pos, i); pos++;
+          ps.setInt(pos, i);
+          pos++;
+          ps.setString(pos, strings[i]);
+          pos++;
+          ps.setInt(pos, i);
+          pos++;
         }
         ps.addBatch();
       }
@@ -136,6 +142,11 @@ public int[] insertBatch() throws SQLException {
     return ps.executeBatch();
   }
 
+  @Benchmark
+  public int[] insertBatchWithRewrite() throws SQLException {
+    return insertBatch();
+  }
+
   @Benchmark
   public void insertExecute(Blackhole b) throws SQLException {
     for (int i = 0; i < p1nrows; i++) {
@@ -220,8 +231,8 @@ public static void main(String[] args) throws RunnerException {
     //Driver.setLogLevel(2);
     Options opt = new OptionsBuilder()
         .include(InsertBatch.class.getSimpleName())
-//        .addProfiler(GCProfiler.class)
-//        .addProfiler(FlightRecorderProfiler.class)
+        //.addProfiler(org.openjdk.jmh.profile.GCProfiler.class)
+        //.addProfiler(org.postgresql.benchmark.profilers.FlightRecorderProfiler.class)
         .detectJvmArgs()
         .build();