diff --git a/.travis.yml b/.travis.yml
index 725ed447ec..30bfbc2b38 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -2,7 +2,10 @@ sudo: false
 language: java
 
 before_script:
-  - test "x$XA" == 'x' || ./travis_install_dependencies.sh
+  - export PG_DATADIR="/etc/postgresql/${PG_VERSION}/main"
+  -  ./.travis/travis_install_postgres.sh
+  - test "x$XA" == 'x' || ./.travis/travis_configure_xa.sh
+  - ./.travis/travis_start_postgres.sh
   - psql -U postgres -c "create user test with password 'test';"
   - psql -c 'create database test owner test;' -U postgres
   - echo "MAVEN_OPTS='-Xmx1g -Dgpg.skip=true'" > ~/.mavenrc
@@ -25,7 +28,7 @@ script:
   - export JDK9_HOME=/usr/lib/jvm/java-9-oracle
   - test -d "${JDK9_HOME}" || export JDK9_HOME=$(jdk_switcher home oraclejdk8)
   - envsubst < toolchains.xml > ~/.m2/toolchains.xml
-  - ./travis_build.sh
+  - ./.travis/travis_build.sh
   # To avoid useless S3 cache updates (https://github.com/travis-ci/travis-ci/issues/1441#issuecomment-67607074)
   #- mkdir /tmp/cache-trick
   #- mv $HOME/.m2/repository/org/postgresql /tmp/cache-trick/
@@ -59,6 +62,8 @@ matrix:
     - jdk: oraclejdk8
       sudo: required
       dist: trusty
+      addons:
+        postgresql: "9.5"
       env:
         - PG_VERSION=9.5
         - XA=true
@@ -76,11 +81,20 @@ matrix:
     - jdk: oraclejdk8
       addons:
         postgresql: "9.4"
+        apt:
+          packages:
+            - oracle-java8-installer
       env:
         - PG_VERSION=9.4
         - COVERAGE=Y
         - MCENTRAL=Y
         - JDOC=Y
+    - jdk: oraclejdk8
+      sudo: required
+      dist: trusty
+      env:
+        - PG_VERSION=HEAD
+        - XA=true
     - jdk: openjdk7
       addons:
         postgresql: "9.4"
@@ -95,12 +109,26 @@ matrix:
         - MCENTRAL=Y
     - jdk: oraclejdk8 # this will be overwritten by before_install above
       addons:
+        postgresql: "9.4"
         apt:
           packages:
             - oracle-java9-installer
       env:
-        - PG_VERSION=9.5
+        - PG_VERSION=9.4
         - JDK=9
+    - jdk: oraclejdk8
+      addons:
+        postgresql: "9.4"
+      env:
+        - PG_VERSION=9.4
+        - QUERY_MODE=simple
+        - COVERAGE=Y
+    - jdk: oraclejdk8
+      addons:
+        postgresql: "9.4"
+      env:
+        - PG_VERSION=9.4
+        - QUERY_MODE=extendedForPrepared
     - jdk: oraclejdk8
       addons:
         postgresql: "9.4"
@@ -129,4 +157,4 @@ matrix:
 
 # Deploy snapshots to Maven Central
 after_success:
-  - "test $MCENTRAL == 'Y' && ./travis_deploy.sh"
+  - "$TRAVIS_PULL_REQUEST == 'false' && test $TRAVIS_BRANCH == 'master' && test $MCENTRAL == 'Y' && ./.travis/travis_deploy.sh"
diff --git a/travis_build.sh b/.travis/travis_build.sh
similarity index 93%
rename from travis_build.sh
rename to .travis/travis_build.sh
index c18ffd2021..f35bb506b4 100755
--- a/travis_build.sh
+++ b/.travis/travis_build.sh
@@ -17,6 +17,11 @@ then
     MVN_ARGS="$MVN_ARGS -DwaffleEnabled=false -DosgiEnabled=false -DexcludePackageNames=org.postgresql.osgi:org.postgresql.sspi"
 fi
 
+if [[ "x${QUERY_MODE}" == *"x"* ]];
+then
+    MVN_ARGS="$MVN_ARGS -DpreferQueryMode=$QUERY_MODE"
+fi
+
 if [[ "${COVERAGE}" == *"Y"* ]];
 then
     MVN_PROFILES="$MVN_PROFILES,coverage"
diff --git a/.travis/travis_configure_xa.sh b/.travis/travis_configure_xa.sh
new file mode 100755
index 0000000000..58c82a637d
--- /dev/null
+++ b/.travis/travis_configure_xa.sh
@@ -0,0 +1,4 @@
+#!/usr/bin/env bash
+set -x -e
+
+sudo sed -i -e 's/#max_prepared_transactions = 0/max_prepared_transactions = 64/g' /etc/postgresql/${PG_VERSION}/main/postgresql.conf
diff --git a/travis_deploy.sh b/.travis/travis_deploy.sh
similarity index 100%
rename from travis_deploy.sh
rename to .travis/travis_deploy.sh
diff --git a/.travis/travis_install_head_postgres.sh b/.travis/travis_install_head_postgres.sh
new file mode 100755
index 0000000000..24c0ea3784
--- /dev/null
+++ b/.travis/travis_install_head_postgres.sh
@@ -0,0 +1,27 @@
+#!/usr/bin/env bash
+set -x -e
+
+sudo service postgresql stop
+sudo apt-get remove postgresql libpq-dev libpq5 postgresql-client-common postgresql-common -qq --purge
+sudo apt-get -y install libxml2
+
+git clone --depth=1 https://github.com/postgres/postgres.git
+cd postgres
+
+# Build PostgreSQL from source
+sudo ./configure --with-libxml && sudo make && sudo make install
+sudo ln -s /usr/local/pgsql/bin/psql /usr/bin/psql
+# Build contrib from source
+cd contrib
+sudo make all && sudo make install
+
+#Post compile actions
+LD_LIBRARY_PATH=/usr/local/pgsql/lib
+export LD_LIBRARY_PATH
+sudo /sbin/ldconfig /usr/local/pgsql/lib
+
+sudo mkdir -p ${PG_DATADIR}
+sudo chmod 777 ${PG_DATADIR}
+sudo chown -R postgres:postgres ${PG_DATADIR}
+
+sudo su postgres -c "/usr/local/pgsql/bin/pg_ctl -D ${PG_DATADIR} -U postgres initdb"
\ No newline at end of file
diff --git a/.travis/travis_install_postgres.sh b/.travis/travis_install_postgres.sh
new file mode 100755
index 0000000000..cd69101f48
--- /dev/null
+++ b/.travis/travis_install_postgres.sh
@@ -0,0 +1,30 @@
+#!/usr/bin/env bash
+# Adapted from https://github.com/dockyard/reefpoints/blob/master/source/posts/2013-03-29-running-postgresql-9-2-on-travis-ci.md
+set -x -e
+
+if [ -z "$PG_VERSION" ]
+then
+    echo "env PG_VERSION not define";
+elif [ "${PG_VERSION}" = "HEAD" ]
+then
+    ./.travis/travis_install_head_postgres.sh
+elif [ ! -d "${PG_DATADIR}" ]
+then
+    sudo cp /etc/postgresql/9.1/main/pg_hba.conf ./
+    sudo apt-get remove postgresql libpq-dev libpq5 postgresql-client-common postgresql-common -qq --purge
+    source /etc/lsb-release
+    echo "deb http://apt.postgresql.org/pub/repos/apt/ $DISTRIB_CODENAME-pgdg main ${PG_VERSION}" > pgdg.list
+    sudo mv pgdg.list /etc/apt/sources.list.d/
+    wget --quiet -O - https://apt.postgresql.org/pub/repos/apt/ACCC4CF8.asc | sudo apt-key add -
+    sudo apt-get update
+    sudo apt-get -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confnew" install postgresql-${PG_VERSION} postgresql-contrib-${PG_VERSION} -qq
+
+    sudo cp ./pg_hba.conf /etc/postgresql/${PG_VERSION}/main
+    if [ ${PG_VERSION} = '8.4' ]
+    then
+      sudo sed -i -e 's/port = 5433/port = 5432/g' /etc/postgresql/8.4/main/postgresql.conf
+    fi
+
+    sudo service postgresql restart ${PG_VERSION}
+    sudo tail /var/log/postgresql/postgresql-${PG_VERSION}-main.log
+fi
\ No newline at end of file
diff --git a/.travis/travis_start_postgres.sh b/.travis/travis_start_postgres.sh
new file mode 100755
index 0000000000..1f8a000198
--- /dev/null
+++ b/.travis/travis_start_postgres.sh
@@ -0,0 +1,17 @@
+#!/usr/bin/env bash
+set -x -e
+
+if [ -z "$PG_VERSION" ]
+then
+    echo "env PG_VERSION not define";
+elif [ "x${PG_VERSION}" = "xHEAD" ]
+then
+    #Start head postgres
+    sudo su postgres -c "/usr/local/pgsql/bin/pg_ctl -D ${PG_DATADIR} -w -t 300 -o '-p 5432' -l /tmp/postgres.log start"
+    sudo tail /tmp/postgres.log
+elif [ "$XA" = "true" ]
+then
+    sudo service postgresql stop
+    sudo service postgresql start ${PG_VERSION}
+    sudo tail /var/log/postgresql/postgresql-${PG_VERSION}-main.log
+fi
\ No newline at end of file
diff --git a/README.md b/README.md
index 17834b6ae4..bc5489a222 100644
--- a/README.md
+++ b/README.md
@@ -3,6 +3,7 @@
 
 [![Build Status](https://travis-ci.org/pgjdbc/pgjdbc.svg?branch=master)](https://travis-ci.org/pgjdbc/pgjdbc)
 [![Maven Central](https://maven-badges.herokuapp.com/maven-central/org.postgresql/postgresql/badge.svg)](https://maven-badges.herokuapp.com/maven-central/org.postgresql/postgresql)
+[![Javadocs](http://javadoc.io/badge/org.postgresql/postgresql.svg)](http://javadoc.io/doc/org.postgresql/postgresql)
 [![Join the chat at https://gitter.im/pgjdbc/pgjdbc](https://badges.gitter.im/pgjdbc/pgjdbc.svg)](https://gitter.im/pgjdbc/pgjdbc?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
 
 This is a simple readme describing how to compile and use the PostgreSQL JDBC driver.
@@ -20,6 +21,16 @@ For problems with this driver, refer to driver's [home page](http://jdbc.postgre
 Most people do not need to compile PgJDBC. You can download prebuilt versions of the driver 
 from the [Postgresql JDBC site](http://jdbc.postgresql.org/) or using your chosen dependency management tool:
 
+## Changelog
+
+Notable changes for 9.4.1209:
+* Many improvements to `insert into .. values(?,?)` => `insert .. values(?,?), (?,?)...` rewriter. Give it a try by using `reWriteBatchedInserts=true` connection property. 2-3x improvements for insert batch can be expected
+* Full test suite passes against PostgreSQL 9.6, and OpenJDK 9
+* Performance optimization for timestamps (~`TimeZone.getDefault` optimization)
+* Allow build-from-source on GNU/Linux without maven repositories, and add Fedora Copr test to the regression suite
+
+Full change log can be found here: https://jdbc.postgresql.org/documentation/changelog.html#introduction
+
 ## Supported PostgreSQL versions
 
 Pgjdbc regression tests are run against PostgreSQL 8.4, 9.1, 9.2, 9.3, 9.4, 9.5, 9.6.
@@ -29,36 +40,36 @@ Pgjdbc regression tests are run against PostgreSQL 8.4, 9.1, 9.2, 9.3, 9.4, 9.5,
 <dependency>
   <groupId>org.postgresql</groupId>
   <artifactId>postgresql</artifactId>
-  <version>9.4.1208</version> <!-- Java 8 -->
-  <version>9.4.1208.jre7</version> <!-- Java 7 -->
-  <version>9.4.1208.jre6</version> <!-- Java 6 -->
+  <version>9.4.1209</version> <!-- Java 8 -->
+  <version>9.4.1209.jre7</version> <!-- Java 7 -->
+  <version>9.4.1209.jre6</version> <!-- Java 6 -->
 </dependency>
 ```
 ### Gradle
 Java 8:
 ```
-'org.postgresql:postgresql:9.4.1208'
+'org.postgresql:postgresql:9.4.1209'
 ```
 Java 7:
 ```
-'org.postgresql:postgresql:9.4.1208.jre7'
+'org.postgresql:postgresql:9.4.1209.jre7'
 ```
 Java 6:
 ```
-'org.postgresql:postgresql:9.4.1208.jre6'
+'org.postgresql:postgresql:9.4.1209.jre6'
 ```
 ### Ivy
 Java 8:
 ```xml
-<dependency org="org.postgresql" name="postgresql" rev="9.4.1208"/>
+<dependency org="org.postgresql" name="postgresql" rev="9.4.1209"/>
 ```
 Java 7:
 ```xml
-<dependency org="org.postgresql" name="postgresql" rev="9.4.1208.jre7"/>
+<dependency org="org.postgresql" name="postgresql" rev="9.4.1209.jre7"/>
 ```
 Java 6:
 ```xml
-<dependency org="org.postgresql" name="postgresql" rev="9.4.1208.jre6"/>
+<dependency org="org.postgresql" name="postgresql" rev="9.4.1209.jre6"/>
 ```
 
 ### Development snapshots
@@ -68,9 +79,9 @@ Snapshot builds (builds from `master` branch) are deployed to Maven Central, so
 <dependency>
   <groupId>org.postgresql</groupId>
   <artifactId>postgresql</artifactId>
-  <version>9.4.1209-SNAPSHOT</version> <!-- Java 8 -->
-  <version>9.4.1209.jre7-SNAPSHOT</version> <!-- Java 7 -->
-  <version>9.4.1209.jre6-SNAPSHOT</version> <!-- Java 6 -->
+  <version>9.4.1210-SNAPSHOT</version> <!-- Java 8 -->
+  <version>9.4.1210.jre7-SNAPSHOT</version> <!-- Java 7 -->
+  <version>9.4.1210.jre6-SNAPSHOT</version> <!-- Java 6 -->
 </dependency>
 ```
 
@@ -377,7 +388,7 @@ You can get old JDK versions from the [Oracle Java Archive](http://www.oracle.co
 Then, to test against old JDK, run `mvn test` in `pgjdbc-jre6` or `pgjdbc-jre7` modules.
 
 For information about the unit tests and how to run them, see
-  [org/postgresql/test/README](pgjdbc/src/test/java/org/postgresql/test/README)
+  [org/postgresql/test/README](pgjdbc/src/test/java/org/postgresql/test/README.md)
 
 ### Ideas
 
diff --git a/codecov.yml b/codecov.yml
index 083a32cc25..00ae5376eb 100644
--- a/codecov.yml
+++ b/codecov.yml
@@ -1,6 +1,6 @@
 codecov:
   notify:
-    after_n_builds: 7
+    after_n_builds: 8
     require_ci_to_pass: false
 comment:
   layout: header, changes, diff
diff --git a/packaging/rpm/.srpmgen b/packaging/rpm/.srpmgen
index 3ccc06d9f0..f9af4cb879 100644
--- a/packaging/rpm/.srpmgen
+++ b/packaging/rpm/.srpmgen
@@ -6,4 +6,5 @@ spec: postgresql-jdbc.spec
 
 source0:
   git_archive:
-    prefix: postgresql-jdbc-9.5.git
+    prefix: pgjdbc-REL9.5.git
+    tarball_base: REL9.5.git
diff --git a/packaging/rpm/fedora-image/Dockerfile b/packaging/rpm/fedora-image/Dockerfile
index e156c91ab9..26a0141112 100644
--- a/packaging/rpm/fedora-image/Dockerfile
+++ b/packaging/rpm/fedora-image/Dockerfile
@@ -1,4 +1,4 @@
-FROM index.docker.io/fedora:23
+FROM index.docker.io/fedora:24
 MAINTAINER pgjdbc team
 
 ENV HOME=/rpm
diff --git a/packaging/rpm/fedora-image/srpmgen b/packaging/rpm/fedora-image/srpmgen
index aa90334a96..05d70629fb 100755
--- a/packaging/rpm/fedora-image/srpmgen
+++ b/packaging/rpm/fedora-image/srpmgen
@@ -30,9 +30,14 @@ sub obtain_source
         chomp ($topleveldir);
 
         my $pfx = $config->{prefix};
-        system ("git archive --remote $topleveldir --prefix $pfx/ HEAD | gzip > $pfx.tar.gz");
+        my $tarball_base = $pfx;
+        info ("generating tarball $tarball_base.tar.gz from git repository");
+        if (defined ($config->{tarball_base})) {
+            $tarball_base = $config->{tarball_base};
+        }
+        system ("git archive --remote $topleveldir --prefix $pfx/ HEAD | gzip > $tarball_base.tar.gz");
         if ($? >> 8) {
-            die ("can't generate tarball $pfx.tar.gz");
+            die ("can't generate tarball $tarball_base.tar.gz");
         }
         return;
     }
diff --git a/packaging/rpm/postgresql-jdbc.spec.tpl b/packaging/rpm/postgresql-jdbc.spec.tpl
index 75f352e3d4..739e95397f 100644
--- a/packaging/rpm/postgresql-jdbc.spec.tpl
+++ b/packaging/rpm/postgresql-jdbc.spec.tpl
@@ -36,23 +36,22 @@
 
 %global section		devel
 %global upstreamrel	git
+%global upstreammajor	9.5
 %global source_path	pgjdbc/src/main/java/org/postgresql
-%global parent_ver	1.0.8
+%global parent_ver	1.1.0
 %global parent_poms_builddir	./pgjdbc-parent-poms
 
 %global pgjdbc_mvn_options -DwaffleEnabled=false -DosgiEnabled=false \\\
-    -DexcludePackageNames=org.postgresql.osgi:org.postgresql.sspi
+	-DexcludePackageNames=org.postgresql.osgi:org.postgresql.sspi
 
 Summary:	JDBC driver for PostgreSQL
 Name:		postgresql-jdbc
-Version:	9.5.%{upstreamrel}
+Version:	%upstreammajor.%{upstreamrel}
 Release:	1%{?dist}
-# ASL 2.0 applies only to postgresql-jdbc.pom file, the rest is BSD
-License:	BSD and ASL 2.0
-Group:		Applications/Databases
+License:	BSD
 URL:		http://jdbc.postgresql.org/
 
-SOURCE0:	%{name}-%{version}.tar.gz
+Source0:	REL%{version}.tar.gz
 Source1:	postgres-testing.sh
 
 # Upstream moved parent pom.xml into separate project (even though there is only
@@ -62,7 +61,6 @@ Source2:	https://github.com/pgjdbc/pgjdbc-parent-poms/archive/REL%parent_ver.tar
 
 BuildArch:	noarch
 BuildRequires:	java-devel >= 1.8
-BuildRequires:	jpackage-utils
 BuildRequires:	maven-local
 BuildRequires:	java-comment-preprocessor
 BuildRequires:	properties-maven-plugin
@@ -77,8 +75,6 @@ BuildRequires:	postgresql-contrib
 
 # gettext is only needed if we try to update translations
 #BuildRequires:	gettext
-Requires:	jpackage-utils
-Requires:	java-headless >= 1:1.8
 
 %description
 PostgreSQL is an advanced Object-Relational database management
@@ -87,7 +83,7 @@ Java programs to access a PostgreSQL database.
 
 
 %package	parent-poms
-Summary:	Build dependency management for pgjdbc.
+Summary:	Build dependency management for PostgreSQL JDBC driver.
 
 %description parent-poms
 Pom files bringing dependencies required for successful PostgreSQL JDBC driver
@@ -96,33 +92,36 @@ build.
 
 %package javadoc
 Summary:	API docs for %{name}
-Group:		Documentation
 
 %description javadoc
 This package contains the API Documentation for %{name}.
 
 
 %prep
-%setup -c -q -a 2
+%setup -c -q -a 2 -n pgjdbc-REL%version
 
-mv %name-%version/* .
-mv ./pgjdbc-parent-poms-REL%parent_ver %parent_poms_builddir
+mv pgjdbc-REL%version/* .
+mv pgjdbc-parent-poms-REL%parent_ver pgjdbc-parent-poms
 
 # remove any binary libs
 find -name "*.jar" -or -name "*.class" | xargs rm -f
 
-
 %pom_disable_module ubenchmark
 
-# Hack #0!  For upstream it is to some extent important to have the parent-poms
-# project separated.  Having it like that on downstream level does not help at
-# all.  Note that we have to revert this patch before we do the installation.
-sed -i.hack-parent-poms \
-  's!<relativePath />!<relativePath>../pgjdbc-parent-poms/pgjdbc-core-parent/pom.xml</relativePath>!' \
-  pgjdbc/pom.xml
-sed -i.hack-parent-poms \
-  '/<artifactId>pgjdbc-versions/a <relativePath>pgjdbc-parent-poms/pgjdbc-versions/pom.xml</relativePath>' \
-  pom.xml
+# Build parent POMs in the same Maven call.
+%pom_xpath_inject pom:modules "<module>%parent_poms_builddir</module>"
+%pom_xpath_inject pom:parent "<relativePath>pgjdbc-parent-poms/pgjdbc-versions</relativePath>"
+%pom_xpath_set pom:relativePath ../pgjdbc-parent-poms/pgjdbc-core-parent pgjdbc
+
+# compat symlink: requested by dtardon (libreoffice), reverts part of
+# 0af97ce32de877 commit.
+%mvn_file org.postgresql:postgresql %{name}/postgresql %{name}
+
+# Parent POMs should be installed in a separate subpackage.
+%mvn_package ":*{parent,versions,prevjre}*" parent-poms
+
+# For compat reasons, make Maven artifact available under older coordinates.
+%mvn_alias org.postgresql:postgresql postgresql:postgresql
 
 # Hack #1!  This directory is missing for some reason, it is most probably some
 # misunderstanding between maven, maven-compiler-plugin and
@@ -158,61 +157,35 @@ EOF
 
 # Start the local PG cluster.
 pgtests_start
-%endif
-
-# First "build" the parent-poms ..
-cd %parent_poms_builddir
-%mvn_build -- %pgjdbc_mvn_options
-cd ..
-# .. and then build pgjdbc.
-
-%if %runselftest
-%mvn_build -- %pgjdbc_mvn_options
 %else
-%mvn_build -- %pgjdbc_mvn_options -Dmaven.test.skip=true
+# -f is equal to -Dmaven.test.skip=true
+opts="-f"
 %endif
 
-# Hack #0!  Revert the patch above.
-for i in `find -name '*.hack-parent-poms'`
-do
-	mv $i ${i%%%%.hack-parent-poms}
-done
-
+%mvn_build $opts -- %pgjdbc_mvn_options
 
 %install
 %mvn_install
-cd %parent_poms_builddir
-%mvn_install
-
-pushd $RPM_BUILD_ROOT%{_javadir}
-# Also, for backwards compatibility with our old postgresql-jdbc packages,
-# add these symlinks.  (Probably only the jdbc3 symlink really makes sense?)
-ln -s %{name}/postgresql.jar postgresql-jdbc.jar
-ln -s %{name}/postgresql.jar postgresql-jdbc2.jar
-ln -s %{name}/postgresql.jar postgresql-jdbc2ee.jar
-ln -s %{name}/postgresql.jar postgresql-jdbc3.jar
-popd
-
-
-%check
 
 
 %files -f .mfiles
 %license LICENSE
 %doc README.md
-%{_javadir}/%{name}.jar
-%{_javadir}/%{name}2.jar
-%{_javadir}/%{name}2ee.jar
-%{_javadir}/%{name}3.jar
 
-%files parent-poms -f %parent_poms_builddir/.mfiles
 
-%files javadoc
+%files parent-poms -f .mfiles-parent-poms
+%license LICENSE
+%doc pgjdbc-parent-poms/CHANGELOG.md pgjdbc-parent-poms/README.md
+
+
+%files javadoc -f .mfiles-javadoc
 %license LICENSE
-%doc %{_javadocdir}/%{name}
 
 
 %changelog
+* Mon Aug 29 2016 Pavel Raiskup <praiskup@redhat.com> - 9.4.1209-6
+- sync with latest Fedora
+
 * Wed Jun 01 2016 Pavel Raiskup <praiskup@redhat.com> - 9.5.git-1
 - update to work with tarball from git version of jdbc
 
diff --git a/pgjdbc/pom.xml b/pgjdbc/pom.xml
index b3d5c54ac7..272fdaa750 100644
--- a/pgjdbc/pom.xml
+++ b/pgjdbc/pom.xml
@@ -3,14 +3,14 @@
   <parent>
     <groupId>org.postgresql</groupId>
     <artifactId>pgjdbc-core-parent</artifactId>
-    <version>1.0.8</version>
+    <version>1.1.1</version>
     <relativePath />
   </parent>
 
   <artifactId>postgresql</artifactId>
   <packaging>bundle</packaging>
   <name>PostgreSQL JDBC Driver - JDBC 4.2</name>
-  <version>9.4.1209</version>
+  <version>9.4.1210</version>
   <description>Java JDBC 4.2 (JRE 8+) driver for PostgreSQL database</description>
   <url>https://github.com/pgjdbc/pgjdbc</url>
 
@@ -277,6 +277,6 @@
   </build>
 
   <scm>
-    <tag>REL9.4.1209</tag>
+    <tag>REL9.4.1210</tag>
   </scm>
 </project>
diff --git a/pgjdbc/src/main/java/org/postgresql/PGConnection.java b/pgjdbc/src/main/java/org/postgresql/PGConnection.java
index b83a0bcf5e..95c4763ea0 100644
--- a/pgjdbc/src/main/java/org/postgresql/PGConnection.java
+++ b/pgjdbc/src/main/java/org/postgresql/PGConnection.java
@@ -10,6 +10,8 @@
 
 import org.postgresql.copy.CopyManager;
 import org.postgresql.fastpath.Fastpath;
+import org.postgresql.jdbc.AutoSave;
+import org.postgresql.jdbc.PreferQueryMode;
 import org.postgresql.largeobject.LargeObjectManager;
 import org.postgresql.util.PGobject;
 
@@ -167,4 +169,30 @@ public interface PGConnection {
    * @throws SQLException if something goes wrong
    */
   String escapeLiteral(String literal) throws SQLException;
+
+  /**
+   * Returns true if the connection is configured to use "simple 'Q' execute" commands only
+   * When running in simple protocol only, certain features are not available: callable statements,
+   * partial result set fetch, bytea type, etc.
+   * The list of supported features is subject to change.
+   *
+   * @return true if the connection is configured to use "simple 'Q' execute" commands only
+   */
+  PreferQueryMode getPreferQueryMode();
+
+
+  /**
+   * Connection configuration regarding automatic per-query savepoints.
+   *
+   * @see PGProperty#AUTOSAVE
+   * @return connection configuration regarding automatic per-query savepoints
+   */
+  AutoSave getAutosave();
+
+  /**
+   * Configures if connection should use automatic savepoints.
+   * @see PGProperty#AUTOSAVE
+   * @param autoSave connection configuration regarding automatic per-query savepoints
+   */
+  void setAutosave(AutoSave autoSave);
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/PGProperty.java b/pgjdbc/src/main/java/org/postgresql/PGProperty.java
index 9270902870..47b277eba7 100644
--- a/pgjdbc/src/main/java/org/postgresql/PGProperty.java
+++ b/pgjdbc/src/main/java/org/postgresql/PGProperty.java
@@ -138,7 +138,7 @@ public enum PGProperty {
    */
   STRING_TYPE("stringtype", null,
       "The type to bind String parameters as (usually 'varchar', 'unspecified' allows implicit casting to other types)",
-      false, new String[]{"unspecified", "varchar"}),
+      false, "unspecified", "varchar"),
 
   /**
    * Specifies the length to return for types of unknown length.
@@ -356,6 +356,32 @@ public enum PGProperty {
   HOST_RECHECK_SECONDS("hostRecheckSeconds", "10",
       "Specifies period (seconds) after host statuses are checked again in case they have changed"),
 
+  /**
+   * Specifies which mode is used to execute queries to database: simple means ('Q' execute, no parse, no bind, text mode only),
+   * extended means always use bind/execute messages, extendedForPrepared means extended for prepared statements only,
+   * extendedCacheEveryting means use extended protocol and try cache every statement (including Statement.execute(String sql)) in a query cache.
+   *
+   * This mode is meant for debugging purposes and/or for cases when extended protocol cannot be used (e.g. logical replication protocol)
+   */
+  PREFER_QUERY_MODE("preferQueryMode", "extended",
+      "Specifies which mode is used to execute queries to database: simple means ('Q' execute, no parse, no bind, text mode only), "
+          + "extended means always use bind/execute messages, extendedForPrepared means extended for prepared statements only, "
+          + "extendedCacheEveryting means use extended protocol and try cache every statement (including Statement.execute(String sql)) in a query cache.", false,
+      "extended", "extendedForPrepared", "extendedCacheEveryting", "simple"),
+
+  /**
+   * Specifies what the driver should do if a query fails. In {@code autosave=always} mode, JDBC driver sets a safepoint before each query,
+   * and rolls back to that safepoint in case of failure. In {@code autosave=never} mode (default), no safepoint dance is made ever.
+   * In {@code autosave=conservative} mode, safepoint is set for each query, however the rollback is done only for rare cases
+   * like 'cached statement cannot change return type' or 'statement XXX is not valid' so JDBC driver rollsback and retries
+   */
+  AUTOSAVE("autosave", "never",
+      "Specifies what the driver should do if a query fails. In autosave=always mode, JDBC driver sets a safepoint before each query, "
+          + "and rolls back to that safepoint in case of failure. In autosave=never mode (default), no safepoint dance is made ever. "
+          + "In autosave=conservative mode, safepoint is set for each query, however the rollback is done only for rare cases"
+          + " like 'cached statement cannot change return type' or 'statement XXX is not valid' so JDBC driver rollsback and retries", false,
+      "always", "never", "conservative"),
+
   /**
    * Configure optimization to enable batch insert re-writing.
    */
@@ -474,7 +500,7 @@ public int getInt(Properties properties) throws PSQLException {
       return Integer.parseInt(value);
     } catch (NumberFormatException nfe) {
       throw new PSQLException(GT.tr("{0} parameter value must be an integer but was: {1}",
-          new Object[]{getName(), value}), PSQLState.INVALID_PARAMETER_VALUE, nfe);
+          getName(), value), PSQLState.INVALID_PARAMETER_VALUE, nfe);
     }
   }
 
@@ -494,7 +520,7 @@ public Integer getInteger(Properties properties) throws PSQLException {
       return Integer.parseInt(value);
     } catch (NumberFormatException nfe) {
       throw new PSQLException(GT.tr("{0} parameter value must be an integer but was: {1}",
-          new Object[]{getName(), value}), PSQLState.INVALID_PARAMETER_VALUE, nfe);
+          getName(), value), PSQLState.INVALID_PARAMETER_VALUE, nfe);
     }
   }
 
diff --git a/pgjdbc/src/main/java/org/postgresql/core/BaseConnection.java b/pgjdbc/src/main/java/org/postgresql/core/BaseConnection.java
index fce4dbd648..09ea65865b 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/BaseConnection.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/BaseConnection.java
@@ -184,7 +184,7 @@ ResultSet execSQLQuery(String s, int resultSetType, int resultSetConcurrency)
    * <tt>standard_conforming_strings</tt> server variable.
    *
    * @return true if the server treats string literals according to the SQL standard
-   * @see ProtocolConnection#getStandardConformingStrings()
+   * @see QueryExecutor#getStandardConformingStrings()
    */
   boolean getStandardConformingStrings();
 
@@ -200,9 +200,9 @@ ResultSet execSQLQuery(String s, int resultSetType, int resultSetConcurrency)
   /**
    * Get the current transaction state of this connection.
    *
-   * @return a ProtocolConnection.TRANSACTION_* constant.
+   * @return current transaction state of this connection
    */
-  int getTransactionState();
+  TransactionState getTransactionState();
 
   /**
    * Returns true if value for the given oid should be sent using binary transfer. False if value
@@ -234,16 +234,23 @@ ResultSet execSQLQuery(String s, int resultSetType, int resultSetConcurrency)
    */
   void purgeTimerTasks();
 
-  /**
-   * To be used for checking if the batched insert re-write optimization is enabled.
-   * @return true if re-write feature is enabled
-   */
-  boolean isReWriteBatchedInsertsEnabled();
-
   /**
    * Return metadata cache for given connection
    *
    * @return metadata cache
    */
   LruCache<FieldMetadata.Key, FieldMetadata> getFieldMetadataCache();
+
+  CachedQuery createQuery(String sql, boolean escapeProcessing, boolean isParameterized,
+      String... columnNames)
+      throws SQLException;
+
+  /**
+   * By default, the connection resets statement cache in case deallocate all/discard all
+   * message is observed.
+   * This API allows to disable that feature for testing purposes.
+   *
+   * @param flushCacheOnDeallocate true if statement cache should be reset when "deallocate/discard" message observed
+   */
+  void setFlushCacheOnDeallocate(boolean flushCacheOnDeallocate);
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/BaseQueryKey.java b/pgjdbc/src/main/java/org/postgresql/core/BaseQueryKey.java
new file mode 100644
index 0000000000..abbbf0092e
--- /dev/null
+++ b/pgjdbc/src/main/java/org/postgresql/core/BaseQueryKey.java
@@ -0,0 +1,57 @@
+package org.postgresql.core;
+
+/**
+ * This class is used as a cache key for simple statements that have no "returning columns".
+ * Prepared statements that have no returning columns use just {@code String sql} as a key.
+ * Simple and Prepared statements that have returning columns use {@link QueryWithReturningColumnsKey}
+ * as a cache key.
+ */
+class BaseQueryKey {
+  public final String sql;
+  public final boolean isParameterized;
+  public final boolean escapeProcessing;
+
+  BaseQueryKey(String sql, boolean isParameterized, boolean escapeProcessing) {
+    this.sql = sql;
+    this.isParameterized = isParameterized;
+    this.escapeProcessing = escapeProcessing;
+  }
+
+  @Override
+  public String toString() {
+    return "BaseQueryKey{"
+        + "sql='" + sql + '\''
+        + ", isParameterized=" + isParameterized
+        + ", escapeProcessing=" + escapeProcessing
+        + '}';
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) {
+      return true;
+    }
+    if (o == null || getClass() != o.getClass()) {
+      return false;
+    }
+
+    BaseQueryKey that = (BaseQueryKey) o;
+
+    if (isParameterized != that.isParameterized) {
+      return false;
+    }
+    if (escapeProcessing != that.escapeProcessing) {
+      return false;
+    }
+    return sql != null ? sql.equals(that.sql) : that.sql == null;
+
+  }
+
+  @Override
+  public int hashCode() {
+    int result = sql != null ? sql.hashCode() : 0;
+    result = 31 * result + (isParameterized ? 1 : 0);
+    result = 31 * result + (escapeProcessing ? 1 : 0);
+    return result;
+  }
+}
diff --git a/pgjdbc/src/main/java/org/postgresql/core/BaseStatement.java b/pgjdbc/src/main/java/org/postgresql/core/BaseStatement.java
index 7e387c949d..51d306cb35 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/BaseStatement.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/BaseStatement.java
@@ -47,7 +47,7 @@ ResultSet createResultSet(Query originalQuery, Field[] fields, List<byte[][]> tu
   /**
    * Execute a query, passing additional query flags.
    *
-   * @param p_sql the query to execute
+   * @param p_sql the query to execute (JDBC-style query)
    * @param flags additional {@link QueryExecutor} flags for execution; these are bitwise-ORed into
    *        the default flags.
    * @return true if there is a result set
@@ -55,6 +55,17 @@ ResultSet createResultSet(Query originalQuery, Field[] fields, List<byte[][]> tu
    */
   boolean executeWithFlags(String p_sql, int flags) throws SQLException;
 
+  /**
+   * Execute a query, passing additional query flags.
+   *
+   * @param cachedQuery the query to execute (native to PostgreSQL)
+   * @param flags additional {@link QueryExecutor} flags for execution; these are bitwise-ORed into
+   *        the default flags.
+   * @return true if there is a result set
+   * @throws SQLException if something goes wrong.
+   */
+  boolean executeWithFlags(CachedQuery cachedQuery, int flags) throws SQLException;
+
   /**
    * Execute a prepared query, passing additional query flags.
    *
diff --git a/pgjdbc/src/main/java/org/postgresql/core/CachedQuery.java b/pgjdbc/src/main/java/org/postgresql/core/CachedQuery.java
index 52a327983a..0333137136 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/CachedQuery.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/CachedQuery.java
@@ -62,4 +62,14 @@ public long getSize() {
     return queryLength * 2 /* original query and native sql */
         + 100L /* entry in hash map, CachedQuery wrapper, etc */;
   }
+
+  @Override
+  public String toString() {
+    return "CachedQuery{"
+        + "executeCount=" + executeCount
+        + ", query=" + query
+        + ", isFunction=" + isFunction
+        + ", outParmBeforeFunc=" + outParmBeforeFunc
+        + '}';
+  }
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/CachedQueryCreateAction.java b/pgjdbc/src/main/java/org/postgresql/core/CachedQueryCreateAction.java
new file mode 100644
index 0000000000..69ce9fc9cf
--- /dev/null
+++ b/pgjdbc/src/main/java/org/postgresql/core/CachedQueryCreateAction.java
@@ -0,0 +1,75 @@
+/*-------------------------------------------------------------------------
+*
+* Copyright (c) 2015, PostgreSQL Global Development Group
+*
+*
+*-------------------------------------------------------------------------
+*/
+
+package org.postgresql.core;
+
+import org.postgresql.util.LruCache;
+
+import java.sql.SQLException;
+import java.util.List;
+
+/**
+ * Creates an instance of {@link CachedQuery} for a given connection.
+ */
+class CachedQueryCreateAction implements LruCache.CreateAction<Object, CachedQuery> {
+  private final static String[] EMPTY_RETURNING = new String[0];
+  private final QueryExecutor queryExecutor;
+
+  public CachedQueryCreateAction(QueryExecutor queryExecutor) {
+    this.queryExecutor = queryExecutor;
+  }
+
+  @Override
+  public CachedQuery create(Object key) throws SQLException {
+    assert key instanceof String || key instanceof BaseQueryKey
+        : "Query key should be String or BaseQueryKey. Given " + key.getClass() + ", sql: "
+        + String.valueOf(key);
+    BaseQueryKey queryKey;
+    String parsedSql;
+    if (key instanceof BaseQueryKey) {
+      queryKey = (BaseQueryKey) key;
+      parsedSql = queryKey.sql;
+    } else {
+      queryKey = null;
+      parsedSql = (String) key;
+    }
+    if (key instanceof String || queryKey.escapeProcessing) {
+      parsedSql =
+          Parser.replaceProcessing(parsedSql, true, queryExecutor.getStandardConformingStrings());
+    }
+    boolean isFunction;
+    boolean outParmBeforeFunc;
+    if (key instanceof CallableQueryKey) {
+      JdbcCallParseInfo callInfo =
+          Parser.modifyJdbcCall(parsedSql, queryExecutor.getStandardConformingStrings(),
+              queryExecutor.getServerVersionNum(), queryExecutor.getProtocolVersion());
+      parsedSql = callInfo.getSql();
+      isFunction = callInfo.isFunction();
+      outParmBeforeFunc = callInfo.isOutParmBeforeFunc();
+    } else {
+      isFunction = false;
+      outParmBeforeFunc = false;
+    }
+    boolean isParameterized = key instanceof String || queryKey.isParameterized;
+    boolean splitStatements = isParameterized;
+
+    String[] returningColumns;
+    if (key instanceof QueryWithReturningColumnsKey) {
+      returningColumns = ((QueryWithReturningColumnsKey) key).columnNames;
+    } else {
+      returningColumns = EMPTY_RETURNING;
+    }
+
+    List<NativeQuery> queries = Parser.parseJdbcSql(parsedSql,
+        queryExecutor.getStandardConformingStrings(), isParameterized, splitStatements,
+        queryExecutor.isReWriteBatchedInsertsEnabled(), returningColumns);
+
+    Query query = queryExecutor.wrap(queries);
+    return new CachedQuery(key, query, isFunction, outParmBeforeFunc);
+  }
+}
diff --git a/pgjdbc/src/main/java/org/postgresql/core/CallableQueryKey.java b/pgjdbc/src/main/java/org/postgresql/core/CallableQueryKey.java
new file mode 100644
index 0000000000..de586d102f
--- /dev/null
+++ b/pgjdbc/src/main/java/org/postgresql/core/CallableQueryKey.java
@@ -0,0 +1,34 @@
+/*-------------------------------------------------------------------------
+*
+* Copyright (c) 2015, PostgreSQL Global Development Group
+*
+*
+*-------------------------------------------------------------------------
+*/
+
+package org.postgresql.core;
+
+/**
+ * Serves as a cache key for {@link java.sql.CallableStatement}.
+ * Callable statements require some special parsing before use (due to JDBC {@code {?= call...}}
+ * syntax, thus a special cache key class is used to trigger proper parsing for callable statements.
+ */
+class CallableQueryKey extends BaseQueryKey {
+  public CallableQueryKey(String sql) {
+    super(sql, true, true);
+  }
+
+  @Override
+  public String toString() {
+    return "CallableQueryKey{"
+        + "sql='" + sql + '\''
+        + ", isParameterized=" + isParameterized
+        + ", escapeProcessing=" + escapeProcessing
+        + '}';
+  }
+
+  @Override
+  public int hashCode() {
+    return super.hashCode() * 31;
+  }
+}
diff --git a/pgjdbc/src/main/java/org/postgresql/core/ConnectionFactory.java b/pgjdbc/src/main/java/org/postgresql/core/ConnectionFactory.java
index 7d43d5a64c..b5cce03b9d 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/ConnectionFactory.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/ConnectionFactory.java
@@ -10,6 +10,7 @@
 package org.postgresql.core;
 
 import org.postgresql.PGProperty;
+import org.postgresql.core.v3.ConnectionFactoryImpl;
 import org.postgresql.util.GT;
 import org.postgresql.util.HostSpec;
 import org.postgresql.util.PSQLException;
@@ -25,15 +26,6 @@
  * @author Oliver Jowett (oliver@opencloud.com)
  */
 public abstract class ConnectionFactory {
-  /**
-   * Protocol version to implementation instance map. If no protocol version is specified, instances
-   * are tried in order until an exception is thrown or a non-null connection is returned.
-   */
-  private static final Object[][] versions = {
-      {"3", new org.postgresql.core.v3.ConnectionFactoryImpl()},
-      {"2", new org.postgresql.core.v2.ConnectionFactoryImpl()},
-  };
-
   /**
    * Establishes and initializes a new connection.
    * <p>
@@ -52,21 +44,17 @@ public abstract class ConnectionFactory {
    * @return the new, initialized, connection
    * @throws SQLException if the connection could not be established.
    */
-  public static ProtocolConnection openConnection(HostSpec[] hostSpecs, String user,
+  public static QueryExecutor openConnection(HostSpec[] hostSpecs, String user,
       String database, Properties info, Logger logger) throws SQLException {
     String protoName = PGProperty.PROTOCOL_VERSION.get(info);
 
-    for (Object[] version : versions) {
-      String versionProtoName = (String) version[0];
-      if (protoName != null && !protoName.equals(versionProtoName)) {
-        continue;
-      }
-
-      ConnectionFactory factory = (ConnectionFactory) version[1];
-      ProtocolConnection connection =
-          factory.openConnectionImpl(hostSpecs, user, database, info, logger);
-      if (connection != null) {
-        return connection;
+    if (protoName == null || "".equals(protoName)
+        || "2".equals(protoName) || "3".equals(protoName)) {
+      ConnectionFactory connectionFactory = new ConnectionFactoryImpl();
+      QueryExecutor queryExecutor =
+          connectionFactory.openConnectionImpl(hostSpecs, user, database, info, logger);
+      if (queryExecutor != null) {
+        return queryExecutor;
       }
     }
 
@@ -91,7 +79,7 @@ public static ProtocolConnection openConnection(HostSpec[] hostSpecs, String use
    * @throws SQLException if the connection could not be established for a reason other than
    *         protocol version incompatibility.
    */
-  public abstract ProtocolConnection openConnectionImpl(HostSpec[] hostSpecs, String user,
+  public abstract QueryExecutor openConnectionImpl(HostSpec[] hostSpecs, String user,
       String database, Properties info, Logger logger) throws SQLException;
 
   /**
diff --git a/pgjdbc/src/main/java/org/postgresql/core/EncodingPredictor.java b/pgjdbc/src/main/java/org/postgresql/core/EncodingPredictor.java
new file mode 100644
index 0000000000..ebaa2edbb5
--- /dev/null
+++ b/pgjdbc/src/main/java/org/postgresql/core/EncodingPredictor.java
@@ -0,0 +1,138 @@
+package org.postgresql.core;
+
+import java.io.IOException;
+
+/**
+ * Predicts encoding for error messages based on some heuristics:
+ * 1) For certain languages, it is known how "FATAL" is translated
+ * 2) For Japanese, several common words are hardcoded
+ * 3) Then try various LATIN encodings
+ */
+public class EncodingPredictor {
+  /**
+   * In certain cases the encoding is not known for sure (e.g. before authentication).
+   * In such cases, backend might send messages in "native to database" encoding,
+   * thus pgjdbc has to guess the encoding nad
+   */
+  public static class DecodeResult {
+    public final String result;
+    public final String encoding; // JVM name
+
+    DecodeResult(String result, String encoding) {
+      this.result = result;
+      this.encoding = encoding;
+    }
+  }
+
+  static class Translation {
+    public final String fatalText;
+    private final String[] texts;
+    public final String language;
+    public final String[] encodings;
+
+    Translation(String fatalText, String[] texts, String language, String... encodings) {
+      this.fatalText = fatalText;
+      this.texts = texts;
+      this.language = language;
+      this.encodings = encodings;
+    }
+  }
+
+  private final static Translation[] FATAL_TRANSLATIONS =
+      new Translation[]{
+          new Translation("ВАЖНО", null, "ru", "WIN", "ALT", "KOI8"),
+          new Translation("致命错误", null, "zh_CN", "EUC_CN", "GBK", "BIG5"),
+          new Translation("KATASTROFALNY", null, "pl", "LATIN2"),
+          new Translation("FATALE", null, "it", "LATIN1", "LATIN9"),
+          new Translation("FATAL", new String[]{"は存在しません" /* ~ does not exist */,
+              "ロール" /* ~ role */, "ユーザ" /* ~ user */}, "ja", "EUC_JP", "SJIS"),
+          new Translation(null, null, "fr/de/es/pt_BR", "LATIN1", "LATIN3", "LATIN4", "LATIN5",
+              "LATIN7", "LATIN9"),
+      };
+
+  public static DecodeResult decode(byte[] bytes, int offset, int length) {
+    Encoding defaultEncoding = Encoding.defaultEncoding();
+    for (Translation tr : FATAL_TRANSLATIONS) {
+      for (String encoding : tr.encodings) {
+        Encoding encoder = Encoding.getDatabaseEncoding(encoding);
+        if (encoder == defaultEncoding) {
+          continue;
+        }
+
+        // If there is a translation for "FATAL", then try typical encodings for that language
+        if (tr.fatalText != null) {
+          byte[] encoded;
+          try {
+            byte[] tmp = encoder.encode(tr.fatalText);
+            encoded = new byte[tmp.length + 2];
+            encoded[0] = 'S';
+            encoded[encoded.length - 1] = 0;
+            System.arraycopy(tmp, 0, encoded, 1, tmp.length);
+          } catch (IOException e) {
+            continue;// should not happen
+          }
+
+          if (!arrayContains(bytes, offset, length, encoded, 0, encoded.length)) {
+            continue;
+          }
+        }
+
+        // No idea how to tell Japanese from Latin languages, thus just hard-code certain Japanese words
+        if (tr.texts != null) {
+          boolean foundOne = false;
+          for (String text : tr.texts) {
+            try {
+              byte[] textBytes = encoder.encode(text);
+              if (arrayContains(bytes, offset, length, textBytes, 0, textBytes.length)) {
+                foundOne = true;
+                break;
+              }
+            } catch (IOException e) {
+              // do not care, will try other encodings
+            }
+          }
+          if (!foundOne) {
+            // Error message does not have key parts, will try other encodings
+            continue;
+          }
+        }
+
+        try {
+          String decoded = encoder.decode(bytes, offset, length);
+          if (decoded.indexOf(65533) != -1) {
+            // bad character in string, try another encoding
+            continue;
+          }
+          return new DecodeResult(decoded, encoder.name());
+        } catch (IOException e) {
+          // do not care
+        }
+      }
+    }
+    return null;
+  }
+
+  private static boolean arrayContains(
+      byte[] first, int firstOffset, int firstLength,
+      byte[] second, int secondOffset, int secondLength
+  ) {
+    if (firstLength < secondLength) {
+      return false;
+    }
+
+    for (int i = 0; i < firstLength; i++) {
+      for (; i < firstLength && first[firstOffset + i] != second[secondOffset]; i++) {
+        // find the first matching byte
+      }
+
+      int j = 1;
+      for (; j < secondLength && first[firstOffset + i + j] == second[secondOffset + j]; j++) {
+        // compare arrays
+      }
+      if (j == secondLength) {
+        return true;
+      }
+    }
+    return false;
+  }
+}
diff --git a/pgjdbc/src/main/java/org/postgresql/core/NativeQuery.java b/pgjdbc/src/main/java/org/postgresql/core/NativeQuery.java
index 0d0daa2f8f..0af317b8dd 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/NativeQuery.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/NativeQuery.java
@@ -20,6 +20,7 @@ public class NativeQuery {
   public final String nativeSql;
   public final int[] bindPositions;
   public final SqlCommand command;
+  public final boolean multiStatement;
 
   static {
     for (int i = 1; i < BIND_NAMES.length; i++) {
@@ -28,13 +29,14 @@ public class NativeQuery {
   }
 
   public NativeQuery(String nativeSql, SqlCommand dml) {
-    this(nativeSql, NO_BINDS, dml);
+    this(nativeSql, NO_BINDS, true, dml);
   }
 
-  public NativeQuery(String nativeSql, int[] bindPositions, SqlCommand dml) {
+  public NativeQuery(String nativeSql, int[] bindPositions, boolean multiStatement, SqlCommand dml) {
     this.nativeSql = nativeSql;
     this.bindPositions =
         bindPositions == null || bindPositions.length == 0 ? NO_BINDS : bindPositions;
+    this.multiStatement = multiStatement;
     this.command = dml;
   }
 
@@ -54,7 +56,7 @@ public String toString(ParameterList parameters) {
     int queryLength = nativeSql.length();
     String[] params = new String[bindPositions.length];
     for (int i = 1; i <= bindPositions.length; ++i) {
-      String param = parameters == null ? "?" : parameters.toString(i);
+      String param = parameters == null ? "?" : parameters.toString(i, true);
       params[i - 1] = param;
       queryLength += param.length() - bindName(i).length();
     }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/Oid.java b/pgjdbc/src/main/java/org/postgresql/core/Oid.java
index 6ee71ff7d9..8127d51e54 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/Oid.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/Oid.java
@@ -71,8 +71,13 @@ public class Oid {
   public static final int XML = 142;
   public static final int XML_ARRAY = 143;
   public static final int POINT = 600;
+  public static final int POINT_ARRAY = 1017;
   public static final int BOX = 603;
   public static final int JSONB_ARRAY = 3807;
+  public static final int JSON = 114;
+  public static final int JSON_ARRAY = 199;
+  public static final int REF_CURSOR = 1790;
+  public static final int REF_CURSOR_ARRAY = 2201;
 
   /**
    * Returns the name of the oid as string.
diff --git a/pgjdbc/src/main/java/org/postgresql/core/PGStream.java b/pgjdbc/src/main/java/org/postgresql/core/PGStream.java
index 33bd3cde18..5185fb91f8 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/PGStream.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/PGStream.java
@@ -185,7 +185,7 @@ public Writer getEncodingWriter() throws IOException {
    * @param val the character to be sent
    * @throws IOException if an I/O error occurs
    */
-  public void SendChar(int val) throws IOException {
+  public void sendChar(int val) throws IOException {
     pg_output.write(val);
   }
 
@@ -195,7 +195,7 @@ public void SendChar(int val) throws IOException {
    * @param val the integer to be sent
    * @throws IOException if an I/O error occurs
    */
-  public void SendInteger4(int val) throws IOException {
+  public void sendInteger4(int val) throws IOException {
     _int4buf[0] = (byte) (val >>> 24);
     _int4buf[1] = (byte) (val >>> 16);
     _int4buf[2] = (byte) (val >>> 8);
@@ -207,9 +207,9 @@ public void SendInteger4(int val) throws IOException {
    * Sends a 2-byte integer (short) to the back end
    *
    * @param val the integer to be sent
-   * @throws IOException if an I/O error occurs or <code>val</code> cannot be encoded in 2 bytes
+   * @throws IOException if an I/O error occurs or {@code val} cannot be encoded in 2 bytes
    */
-  public void SendInteger2(int val) throws IOException {
+  public void sendInteger2(int val) throws IOException {
     if (val < Short.MIN_VALUE || val > Short.MAX_VALUE) {
       throw new IOException("Tried to send an out-of-range integer as a 2-byte value: " + val);
     }
@@ -225,7 +225,7 @@ public void SendInteger2(int val) throws IOException {
    * @param buf The array of bytes to be sent
    * @throws IOException if an I/O error occurs
    */
-  public void Send(byte buf[]) throws IOException {
+  public void send(byte buf[]) throws IOException {
     pg_output.write(buf);
   }
 
@@ -237,8 +237,8 @@ public void Send(byte buf[]) throws IOException {
    * @param siz the number of bytes to be sent
    * @throws IOException if an I/O error occurs
    */
-  public void Send(byte buf[], int siz) throws IOException {
-    Send(buf, 0, siz);
+  public void send(byte buf[], int siz) throws IOException {
+    send(buf, 0, siz);
   }
 
   /**
@@ -250,7 +250,7 @@ public void Send(byte buf[], int siz) throws IOException {
    * @param siz the number of bytes to be sent
    * @throws IOException if an I/O error occurs
    */
-  public void Send(byte buf[], int off, int siz) throws IOException {
+  public void send(byte buf[], int off, int siz) throws IOException {
     int bufamt = buf.length - off;
     pg_output.write(buf, off, bufamt < siz ? bufamt : siz);
     for (int i = bufamt; i < siz; ++i) {
@@ -265,7 +265,7 @@ public void Send(byte buf[], int off, int siz) throws IOException {
    * @return the character received
    * @throws IOException if an I/O Error occurs
    */
-  public int PeekChar() throws IOException {
+  public int peekChar() throws IOException {
     int c = pg_input.peek();
     if (c < 0) {
       throw new EOFException();
@@ -279,7 +279,7 @@ public int PeekChar() throws IOException {
    * @return the character received
    * @throws IOException if an I/O Error occurs
    */
-  public int ReceiveChar() throws IOException {
+  public int receiveChar() throws IOException {
     int c = pg_input.read();
     if (c < 0) {
       throw new EOFException();
@@ -293,7 +293,7 @@ public int ReceiveChar() throws IOException {
    * @return the integer received from the backend
    * @throws IOException if an I/O error occurs
    */
-  public int ReceiveInteger4() throws IOException {
+  public int receiveInteger4() throws IOException {
     if (pg_input.read(_int4buf) != 4) {
       throw new EOFException();
     }
@@ -308,7 +308,7 @@ public int ReceiveInteger4() throws IOException {
    * @return the integer received from the backend
    * @throws IOException if an I/O error occurs
    */
-  public int ReceiveInteger2() throws IOException {
+  public int receiveInteger2() throws IOException {
     if (pg_input.read(_int2buf) != 2) {
       throw new EOFException();
     }
@@ -323,7 +323,7 @@ public int ReceiveInteger2() throws IOException {
    * @return the decoded string
    * @throws IOException if something wrong happens
    */
-  public String ReceiveString(int len) throws IOException {
+  public String receiveString(int len) throws IOException {
     if (!pg_input.ensureBytes(len)) {
       throw new EOFException();
     }
@@ -333,6 +333,36 @@ public String ReceiveString(int len) throws IOException {
     return res;
   }
 
+  /**
+   * Receives a fixed-size string from the backend, and tries to avoid "UTF-8 decode failed"
+   * errors.
+   *
+   * @param len the length of the string to receive, in bytes.
+   * @return the decoded string
+   * @throws IOException if something wrong happens
+   */
+  public EncodingPredictor.DecodeResult receiveErrorString(int len) throws IOException {
+    if (!pg_input.ensureBytes(len)) {
+      throw new EOFException();
+    }
+
+    EncodingPredictor.DecodeResult res;
+    try {
+      String value = encoding.decode(pg_input.getBuffer(), pg_input.getIndex(), len);
+      // no autodetect warning as the message was converted on its own
+      res = new EncodingPredictor.DecodeResult(value, null);
+    } catch (IOException e) {
+      res = EncodingPredictor.decode(pg_input.getBuffer(), pg_input.getIndex(), len);
+      if (res == null) {
+        Encoding enc = Encoding.defaultEncoding();
+        String value = enc.decode(pg_input.getBuffer(), pg_input.getIndex(), len);
+        res = new EncodingPredictor.DecodeResult(value, enc.name());
+      }
+    }
+    pg_input.skip(len);
+    return res;
+  }
+
   /**
    * Receives a null-terminated string from the backend. If we don't see a null, then we assume
    * something has gone wrong.
@@ -340,7 +370,7 @@ public String ReceiveString(int len) throws IOException {
    * @return string from back end
    * @throws IOException if an I/O error occurs, or end of file
    */
-  public String ReceiveString() throws IOException {
+  public String receiveString() throws IOException {
     int len = pg_input.scanCStringLength();
     String res = encoding.decode(pg_input.getBuffer(), pg_input.getIndex(), len - 1);
     pg_input.skip(len);
@@ -354,23 +384,22 @@ public String ReceiveString() throws IOException {
    * @return tuple from the back end
    * @throws IOException if a data I/O error occurs
    */
-  public byte[][] ReceiveTupleV3() throws IOException, OutOfMemoryError {
+  public byte[][] receiveTupleV3() throws IOException, OutOfMemoryError {
     // TODO: use l_msgSize
-    int l_msgSize = ReceiveInteger4();
-    int i;
-    int l_nf = ReceiveInteger2();
+    int l_msgSize = receiveInteger4();
+    int l_nf = receiveInteger2();
     byte[][] answer = new byte[l_nf][];
 
     OutOfMemoryError oom = null;
-    for (i = 0; i < l_nf; ++i) {
-      int l_size = ReceiveInteger4();
+    for (int i = 0; i < l_nf; ++i) {
+      int l_size = receiveInteger4();
       if (l_size != -1) {
         try {
           answer[i] = new byte[l_size];
-          Receive(answer[i], 0, l_size);
+          receive(answer[i], 0, l_size);
         } catch (OutOfMemoryError oome) {
           oom = oome;
-          Skip(l_size);
+          skip(l_size);
         }
       }
     }
@@ -391,10 +420,10 @@ public byte[][] ReceiveTupleV3() throws IOException, OutOfMemoryError {
    * @return null if the current response has no more tuples, otherwise an array of bytearrays
    * @throws IOException if a data I/O error occurs
    */
-  public byte[][] ReceiveTupleV2(int nf, boolean bin) throws IOException, OutOfMemoryError {
+  public byte[][] receiveTupleV2(int nf, boolean bin) throws IOException, OutOfMemoryError {
     int i;
     int bim = (nf + 7) / 8;
-    byte[] bitmask = Receive(bim);
+    byte[] bitmask = receive(bim);
     byte[][] answer = new byte[nf][];
 
     int whichbit = 0x80;
@@ -409,7 +438,7 @@ public byte[][] ReceiveTupleV2(int nf, boolean bin) throws IOException, OutOfMem
         whichbit = 0x80;
       }
       if (!isNull) {
-        int len = ReceiveInteger4();
+        int len = receiveInteger4();
         if (!bin) {
           len -= 4;
         }
@@ -418,10 +447,10 @@ public byte[][] ReceiveTupleV2(int nf, boolean bin) throws IOException, OutOfMem
         }
         try {
           answer[i] = new byte[len];
-          Receive(answer[i], 0, len);
+          receive(answer[i], 0, len);
         } catch (OutOfMemoryError oome) {
           oom = oome;
-          Skip(len);
+          skip(len);
         }
       }
     }
@@ -440,9 +469,9 @@ public byte[][] ReceiveTupleV2(int nf, boolean bin) throws IOException, OutOfMem
    * @return array of bytes received
    * @throws IOException if a data I/O error occurs
    */
-  public byte[] Receive(int siz) throws IOException {
+  public byte[] receive(int siz) throws IOException {
     byte[] answer = new byte[siz];
-    Receive(answer, 0, siz);
+    receive(answer, 0, siz);
     return answer;
   }
 
@@ -454,7 +483,7 @@ public byte[] Receive(int siz) throws IOException {
    * @param siz number of bytes to read
    * @throws IOException if a data I/O error occurs
    */
-  public void Receive(byte[] buf, int off, int siz) throws IOException {
+  public void receive(byte[] buf, int off, int siz) throws IOException {
     int s = 0;
 
     while (s < siz) {
@@ -466,7 +495,7 @@ public void Receive(byte[] buf, int off, int siz) throws IOException {
     }
   }
 
-  public void Skip(int size) throws IOException {
+  public void skip(int size) throws IOException {
     long s = 0;
     while (s < size) {
       s += pg_input.skip(size - s);
@@ -481,7 +510,7 @@ public void Skip(int size) throws IOException {
    * @param remaining the number of bytes to copy
    * @throws IOException if a data I/O error occurs
    */
-  public void SendStream(InputStream inStream, int remaining) throws IOException {
+  public void sendStream(InputStream inStream, int remaining) throws IOException {
     int expectedLength = remaining;
     if (streamBuffer == null) {
       streamBuffer = new byte[8192];
@@ -496,18 +525,18 @@ public void SendStream(InputStream inStream, int remaining) throws IOException {
         if (readCount < 0) {
           throw new EOFException(
               GT.tr("Premature end of input stream, expected {0} bytes, but only read {1}.",
-                  new Object[]{expectedLength, expectedLength - remaining}));
+                  expectedLength, expectedLength - remaining));
         }
       } catch (IOException ioe) {
         while (remaining > 0) {
-          Send(streamBuffer, count);
+          send(streamBuffer, count);
           remaining -= count;
           count = (remaining > streamBuffer.length ? streamBuffer.length : remaining);
         }
         throw new PGBindException(ioe);
       }
 
-      Send(streamBuffer, readCount);
+      send(streamBuffer, readCount);
       remaining -= readCount;
     }
   }
@@ -531,7 +560,7 @@ public void flush() throws IOException {
    * @throws IOException if an I/O error occurs
    * @throws SQLException if we get something other than an EOF
    */
-  public void ReceiveEOF() throws SQLException, IOException {
+  public void receiveEOF() throws SQLException, IOException {
     int c = pg_input.read();
     if (c < 0) {
       return;
diff --git a/pgjdbc/src/main/java/org/postgresql/core/ParameterList.java b/pgjdbc/src/main/java/org/postgresql/core/ParameterList.java
index 6d3ba7a9db..75110554d9 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/ParameterList.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/ParameterList.java
@@ -167,9 +167,10 @@ public interface ParameterList {
    * parameter is not bound, returns "?".
    *
    * @param index the 1-based parameter index to bind.
+   * @param standardConformingStrings true if \ is not an escape character in strings literals
    * @return a string representation of the parameter.
    */
-  String toString(int index);
+  String toString(int index, boolean standardConformingStrings);
 
   /**
    * Use this operation to append more parameters to the current list.
diff --git a/pgjdbc/src/main/java/org/postgresql/core/Parser.java b/pgjdbc/src/main/java/org/postgresql/core/Parser.java
index 6469d6af68..ec084591a5 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/Parser.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/Parser.java
@@ -8,10 +8,13 @@
 
 package org.postgresql.core;
 
+import org.postgresql.jdbc.EscapedFunctions;
 import org.postgresql.util.GT;
 import org.postgresql.util.PSQLException;
 import org.postgresql.util.PSQLState;
 
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -35,14 +38,17 @@ public class Parser {
    *                                  in single quote literals
    * @param withParameters            whether to replace ?, ? with $1, $2, etc
    * @param splitStatements           whether to split statements by semicolon
-   * @param isAutoCommit              whether autocommit is enabled
    * @param isBatchedReWriteConfigured whether re-write optimization is enabled
+   * @param returningColumnNames      for simple insert, update, delete add returning with given column names
    * @return list of native queries
+   * @throws SQLException if unable to add returning clause (invalid column names)
    */
   public static List<NativeQuery> parseJdbcSql(String query, boolean standardConformingStrings,
-      boolean withParameters, boolean splitStatements, boolean isAutoCommit,
-      boolean isBatchedReWriteConfigured) {
-    if (!withParameters && !splitStatements) {
+      boolean withParameters, boolean splitStatements,
+      boolean isBatchedReWriteConfigured,
+      String... returningColumnNames) throws SQLException {
+    if (!withParameters && !splitStatements
+        && returningColumnNames != null && returningColumnNames.length == 0) {
       return Collections.singletonList(new NativeQuery(query,
         SqlCommand.createStatementTypeInfo(SqlCommandType.BLANK)));
     }
@@ -61,7 +67,10 @@ public static List<NativeQuery> parseJdbcSql(String query, boolean standardConfo
     int valuesBraceClosePosition = -1;
     boolean isInsertPresent = false;
     boolean isReturningPresent = false;
+    boolean isReturningPresentPrev = false;
     SqlCommandType currentCommandType = SqlCommandType.BLANK;
+    SqlCommandType prevCommandType = SqlCommandType.BLANK;
+    int numberOfStatements = 0;
 
     boolean whitespaceOnly = true;
     int keyWordCount = 0;
@@ -124,32 +133,44 @@ public static List<NativeQuery> parseJdbcSql(String query, boolean standardConfo
           break;
 
         case ';':
-          if (inParen == 0 && splitStatements) {
+          if (inParen == 0) {
             if (!whitespaceOnly) {
+              numberOfStatements++;
               nativeSql.append(aChars, fragmentStart, i - fragmentStart);
               whitespaceOnly = true;
             }
             fragmentStart = i + 1;
             if (nativeSql.length() > 0) {
-              if (nativeQueries == null) {
-                nativeQueries = new ArrayList<NativeQuery>();
+              if (addReturning(nativeSql, currentCommandType, returningColumnNames, isReturningPresent)) {
+                isReturningPresent = true;
               }
 
-              nativeQueries.add(new NativeQuery(nativeSql.toString(),
-                  toIntArray(bindPositions), SqlCommand.createStatementTypeInfo(
-                      currentCommandType, isBatchedReWriteConfigured, valuesBraceOpenPosition,
-                      valuesBraceClosePosition,
-                  isReturningPresent, nativeQueries.size())));
-            }
-            // Prepare for next query
-            if (bindPositions != null) {
-              bindPositions.clear();
+              if (splitStatements) {
+                if (nativeQueries == null) {
+                  nativeQueries = new ArrayList<NativeQuery>();
+                }
+
+                nativeQueries.add(new NativeQuery(nativeSql.toString(),
+                    toIntArray(bindPositions), false,
+                    SqlCommand.createStatementTypeInfo(
+                        currentCommandType, isBatchedReWriteConfigured, valuesBraceOpenPosition,
+                        valuesBraceClosePosition,
+                        isReturningPresent, nativeQueries.size())));
+              }
             }
-            nativeSql.setLength(0);
+            prevCommandType = currentCommandType;
+            isReturningPresentPrev = isReturningPresent;
             currentCommandType = SqlCommandType.BLANK;
             isReturningPresent = false;
-            valuesBraceOpenPosition = -1;
-            valuesBraceClosePosition = -1;
+            if (splitStatements) {
+              // Prepare for next query
+              if (bindPositions != null) {
+                bindPositions.clear();
+              }
+              nativeSql.setLength(0);
+              valuesBraceOpenPosition = -1;
+              valuesBraceClosePosition = -1;
+            }
           }
           break;
 
@@ -163,23 +184,30 @@ public static List<NativeQuery> parseJdbcSql(String query, boolean standardConfo
       }
       if (keywordStart >= 0 && (i == aChars.length - 1 || !isKeyWordChar)) {
         int wordLength = (isKeyWordChar ? i + 1 : i) - keywordStart;
-        if (wordLength == 6 && parseUpdateKeyword(aChars, keywordStart)) {
-          currentCommandType = SqlCommandType.UPDATE;
-        } else if (wordLength == 6 && parseDeleteKeyword(aChars, keywordStart)) {
-          currentCommandType = SqlCommandType.DELETE;
-        } else if (wordLength == 4 && parseMoveKeyword(aChars, keywordStart)) {
-          currentCommandType = SqlCommandType.MOVE;
-        } else if (wordLength == 6 && parseInsertKeyword(aChars, keywordStart)) {
-          if (!isInsertPresent && (nativeQueries == null || nativeQueries.isEmpty())) {
-            // Only allow rewrite for insert command starting with the insert keyword.
-            // Else, too many risks of wrong interpretation.
-            isCurrentReWriteCompatible = keyWordCount == 0;
-            isInsertPresent = true;
-            currentCommandType = SqlCommandType.INSERT;
-          } else {
-            isCurrentReWriteCompatible = false;
+        if (currentCommandType == SqlCommandType.BLANK) {
+          if (wordLength == 6 && parseUpdateKeyword(aChars, keywordStart)) {
+            currentCommandType = SqlCommandType.UPDATE;
+          } else if (wordLength == 6 && parseDeleteKeyword(aChars, keywordStart)) {
+            currentCommandType = SqlCommandType.DELETE;
+          } else if (wordLength == 4 && parseMoveKeyword(aChars, keywordStart)) {
+            currentCommandType = SqlCommandType.MOVE;
+          } else if (wordLength == 6 && parseSelectKeyword(aChars, keywordStart)) {
+            currentCommandType = SqlCommandType.SELECT;
+          } else if (wordLength == 4 && parseWithKeyword(aChars, keywordStart)) {
+            currentCommandType = SqlCommandType.WITH;
+          } else if (wordLength == 6 && parseInsertKeyword(aChars, keywordStart)) {
+            if (!isInsertPresent && (nativeQueries == null || nativeQueries.isEmpty())) {
+              // Only allow rewrite for insert command starting with the insert keyword.
+              // Else, too many risks of wrong interpretation.
+              isCurrentReWriteCompatible = keyWordCount == 0;
+              isInsertPresent = true;
+              currentCommandType = SqlCommandType.INSERT;
+            } else {
+              isCurrentReWriteCompatible = false;
+            }
           }
-        } else if (wordLength == 9 && parseReturningKeyword(aChars, keywordStart)) {
+        }
+        if (wordLength == 9 && parseReturningKeyword(aChars, keywordStart)) {
           isReturningPresent = true;
         } else if (wordLength == 6 && parseValuesKeyword(aChars, keywordStart)) {
           isValuesFound = true;
@@ -194,7 +222,7 @@ public static List<NativeQuery> parseJdbcSql(String query, boolean standardConfo
         }
       }
     }
-    if (!isValuesFound || bindPositions == null) {
+    if (!isValuesFound) {
       isCurrentReWriteCompatible = false;
     }
     if (!isCurrentReWriteCompatible) {
@@ -204,14 +232,27 @@ public static List<NativeQuery> parseJdbcSql(String query, boolean standardConfo
 
     if (fragmentStart < aChars.length && !whitespaceOnly) {
       nativeSql.append(aChars, fragmentStart, aChars.length - fragmentStart);
+    } else {
+      if (numberOfStatements > 1) {
+        isReturningPresent = false;
+        currentCommandType = SqlCommandType.BLANK;
+      } else if (numberOfStatements == 1) {
+        isReturningPresent = isReturningPresentPrev;
+        currentCommandType = prevCommandType;
+      }
     }
 
     if (nativeSql.length() == 0) {
       return nativeQueries != null ? nativeQueries : Collections.<NativeQuery>emptyList();
     }
 
+    if (addReturning(nativeSql, currentCommandType, returningColumnNames, isReturningPresent)) {
+      isReturningPresent = true;
+    }
+
     NativeQuery lastQuery = new NativeQuery(nativeSql.toString(),
-        toIntArray(bindPositions), SqlCommand.createStatementTypeInfo(currentCommandType,
+        toIntArray(bindPositions), !splitStatements,
+        SqlCommand.createStatementTypeInfo(currentCommandType,
             isBatchedReWriteConfigured, valuesBraceOpenPosition, valuesBraceClosePosition,
             isReturningPresent, (nativeQueries == null ? 0 : nativeQueries.size())));
 
@@ -225,6 +266,32 @@ public static List<NativeQuery> parseJdbcSql(String query, boolean standardConfo
     return nativeQueries;
   }
 
+  private static boolean addReturning(StringBuilder nativeSql, SqlCommandType currentCommandType,
+      String[] returningColumnNames, boolean isReturningPresent) throws SQLException {
+    if (isReturningPresent || returningColumnNames.length == 0) {
+      return false;
+    }
+    if (currentCommandType != SqlCommandType.INSERT
+        && currentCommandType != SqlCommandType.UPDATE
+        && currentCommandType != SqlCommandType.DELETE) {
+      return false;
+    }
+
+    nativeSql.append("\nRETURNING ");
+    if (returningColumnNames.length == 1 && returningColumnNames[0].charAt(0) == '*') {
+      nativeSql.append('*');
+      return true;
+    }
+    for (int col = 0; col < returningColumnNames.length; col++) {
+      String columnName = returningColumnNames[col];
+      if (col > 0) {
+        nativeSql.append(", ");
+      }
+      Utils.escapeIdentifier(nativeSql, columnName);
+    }
+    return true;
+  }
+
   /**
    * Converts {@code List<Integer>} to {@code int[]}. Empty and {@code null} lists are converted to
    * empty array.
@@ -493,6 +560,26 @@ public static boolean parseReturningKeyword(final char[] query, int offset) {
         && (query[offset + 8] | 32) == 'g';
   }
 
+  /**
+   * Parse string to check presence of SELECT keyword regardless of case.
+   *
+   * @param query char[] of the query statement
+   * @param offset position of query to start checking
+   * @return boolean indicates presence of word
+   */
+  public static boolean parseSelectKeyword(final char[] query, int offset) {
+    if (query.length < (offset + 6)) {
+      return false;
+    }
+
+    return (query[offset] | 32) == 's'
+        && (query[offset + 1] | 32) == 'e'
+        && (query[offset + 2] | 32) == 'l'
+        && (query[offset + 3] | 32) == 'e'
+        && (query[offset + 4] | 32) == 'c'
+        && (query[offset + 5] | 32) == 't';
+  }
+
   /**
    * Parse string to check presence of UPDATE keyword regardless of case.
    *
@@ -533,6 +620,24 @@ public static boolean parseValuesKeyword(final char[] query, int offset) {
         && (query[offset + 5] | 32) == 's';
   }
 
+  /**
+   * Parse string to check presence of WITH keyword regardless of case.
+   *
+   * @param query char[] of the query statement
+   * @param offset position of query to start checking
+   * @return boolean indicates presence of word
+   */
+  public static boolean parseWithKeyword(final char[] query, int offset) {
+    if (query.length < (offset + 4)) {
+      return false;
+    }
+
+    return (query[offset] | 32) == 'w'
+        && (query[offset + 1] | 32) == 'i'
+        && (query[offset + 2] | 32) == 't'
+        && (query[offset + 3] | 32) == 'h';
+  }
+
   /**
    * @param c character
    * @return true if the character is a whitespace character as defined in the backend's parser
@@ -842,4 +947,243 @@ public static JdbcCallParseInfo modifyJdbcCall(String jdbcSql, boolean stdString
     return new JdbcCallParseInfo(sql, isFunction, outParmBeforeFunc);
   }
 
+  /**
+   * Filter the SQL string of Java SQL Escape clauses.
+   *
+   * Currently implemented Escape clauses are those mentioned in 11.3 in the specification.
+   * Basically we look through the sql string for {d xxx}, {t xxx}, {ts xxx}, {oj xxx} or {fn xxx}
+   * in non-string sql code. When we find them, we just strip the escape part leaving only the xxx
+   * part. So, something like "select * from x where d={d '2001-10-09'}" would return "select * from
+   * x where d= '2001-10-09'".
+   *
+   * @param p_sql the original query text
+   * @param replaceProcessingEnabled whether replace_processing_enabled is on
+   * @param standardConformingStrings whether standard_conforming_strings is on
+   * @return PostgreSQL-compatible SQL
+   */
+  static String replaceProcessing(String p_sql, boolean replaceProcessingEnabled,
+      boolean standardConformingStrings) throws SQLException {
+    if (replaceProcessingEnabled) {
+      // Since escape codes can only appear in SQL CODE, we keep track
+      // of if we enter a string or not.
+      int len = p_sql.length();
+      char[] chars = p_sql.toCharArray();
+      StringBuilder newsql = new StringBuilder(len);
+      int i = 0;
+      while (i < len) {
+        i = parseSql(chars, i, newsql, false, standardConformingStrings);
+        // We need to loop here in case we encounter invalid
+        // SQL, consider: SELECT a FROM t WHERE (1 > 0)) ORDER BY a
+        // We can't ending replacing after the extra closing paren
+        // because that changes a syntax error to a valid query
+        // that isn't what the user specified.
+        if (i < len) {
+          newsql.append(chars[i]);
+          i++;
+        }
+      }
+      return newsql.toString();
+    } else {
+      return p_sql;
+    }
+  }
+
+  /**
+   * parse the given sql from index i, appending it to the given buffer until we hit an unmatched
+   * right parentheses or end of string. When the stopOnComma flag is set we also stop processing
+   * when a comma is found in sql text that isn't inside nested parenthesis.
+   *
+   * @param p_sql the original query text
+   * @param i starting position for replacing
+   * @param newsql where to write the replaced output
+   * @param stopOnComma should we stop after hitting the first comma in sql text?
+   * @param stdStrings whether standard_conforming_strings is on
+   * @return the position we stopped processing at
+   * @throws SQLException if given SQL is wrong
+   */
+  private static int parseSql(char[] p_sql, int i, StringBuilder newsql, boolean stopOnComma,
+      boolean stdStrings) throws SQLException {
+    SqlParseState state = SqlParseState.IN_SQLCODE;
+    int len = p_sql.length;
+    int nestedParenthesis = 0;
+    boolean endOfNested = false;
+
+    // because of the ++i loop
+    i--;
+    while (!endOfNested && ++i < len) {
+      char c = p_sql[i];
+      switch (state) {
+        case IN_SQLCODE:
+          if (c == '$') {
+            int i0 = i;
+            i = parseDollarQuotes(p_sql, i);
+            newsql.append(p_sql, i0, i - i0 + 1);
+            break;
+          } else if (c == '\'') {
+            // start of a string?
+            int i0 = i;
+            i = parseSingleQuotes(p_sql, i, stdStrings);
+            newsql.append(p_sql, i0, i - i0 + 1);
+            break;
+          } else if (c == '"') {
+            // start of a identifier?
+            int i0 = i;
+            i = parseDoubleQuotes(p_sql, i);
+            newsql.append(p_sql, i0, i - i0 + 1);
+            break;
+          } else if (c == '/') {
+            int i0 = i;
+            i = parseBlockComment(p_sql, i);
+            newsql.append(p_sql, i0, i - i0 + 1);
+            break;
+          } else if (c == '-') {
+            int i0 = i;
+            i = parseLineComment(p_sql, i);
+            newsql.append(p_sql, i0, i - i0 + 1);
+            break;
+          } else if (c == '(') { // begin nested sql
+            nestedParenthesis++;
+          } else if (c == ')') { // end of nested sql
+            nestedParenthesis--;
+            if (nestedParenthesis < 0) {
+              endOfNested = true;
+              break;
+            }
+          } else if (stopOnComma && c == ',' && nestedParenthesis == 0) {
+            endOfNested = true;
+            break;
+          } else if (c == '{') { // start of an escape code?
+            if (i + 1 < len) {
+              char next = p_sql[i + 1];
+              char nextnext = (i + 2 < len) ? p_sql[i + 2] : '\0';
+              if (next == 'd' || next == 'D') {
+                state = SqlParseState.ESC_TIMEDATE;
+                i++;
+                newsql.append("DATE ");
+                break;
+              } else if (next == 't' || next == 'T') {
+                state = SqlParseState.ESC_TIMEDATE;
+                if (nextnext == 's' || nextnext == 'S') {
+                  // timestamp constant
+                  i += 2;
+                  newsql.append("TIMESTAMP ");
+                } else {
+                  // time constant
+                  i++;
+                  newsql.append("TIME ");
+                }
+                break;
+              } else if (next == 'f' || next == 'F') {
+                state = SqlParseState.ESC_FUNCTION;
+                i += (nextnext == 'n' || nextnext == 'N') ? 2 : 1;
+                break;
+              } else if (next == 'o' || next == 'O') {
+                state = SqlParseState.ESC_OUTERJOIN;
+                i += (nextnext == 'j' || nextnext == 'J') ? 2 : 1;
+                break;
+              } else if (next == 'e' || next == 'E') {
+                // we assume that escape is the only escape sequence beginning with e
+                state = SqlParseState.ESC_ESCAPECHAR;
+                break;
+              }
+            }
+          }
+          newsql.append(c);
+          break;
+
+        case ESC_FUNCTION:
+          // extract function name
+          String functionName;
+          int posArgs;
+          for (posArgs = i; posArgs < len && p_sql[posArgs] != '('; posArgs++) {
+            ;
+          }
+          if (posArgs < len) {
+            functionName = new String(p_sql, i, posArgs - i).trim();
+            // extract arguments
+            i = posArgs + 1;// we start the scan after the first (
+            StringBuilder args = new StringBuilder();
+            i = parseSql(p_sql, i, args, false, stdStrings);
+            // translate the function and parse arguments
+            newsql.append(escapeFunction(functionName, args.toString(), stdStrings));
+          }
+          // go to the end of the function copying anything found
+          i++;
+          while (i < len && p_sql[i] != '}') {
+            newsql.append(p_sql[i++]);
+          }
+          state = SqlParseState.IN_SQLCODE; // end of escaped function (or query)
+          break;
+        case ESC_TIMEDATE:
+        case ESC_OUTERJOIN:
+        case ESC_ESCAPECHAR:
+          if (c == '}') {
+            state = SqlParseState.IN_SQLCODE; // end of escape code.
+          } else {
+            newsql.append(c);
+          }
+          break;
+      } // end switch
+    }
+    return i;
+  }
+
+  /**
+   * generate sql for escaped functions
+   *
+   * @param functionName the escaped function name
+   * @param args the arguments for this function
+   * @param stdStrings whether standard_conforming_strings is on
+   * @return the right postgreSql sql
+   * @throws SQLException if something goes wrong
+   */
+  private static String escapeFunction(String functionName, String args, boolean stdStrings)
+      throws SQLException {
+    // parse function arguments
+    int len = args.length();
+    char[] argChars = args.toCharArray();
+    int i = 0;
+    ArrayList<StringBuilder> parsedArgs = new ArrayList<StringBuilder>();
+    while (i < len) {
+      StringBuilder arg = new StringBuilder();
+      int lastPos = i;
+      i = parseSql(argChars, i, arg, true, stdStrings);
+      if (lastPos != i) {
+        parsedArgs.add(arg);
+      }
+      i++;
+    }
+    // we can now translate escape functions
+    try {
+      Method escapeMethod = EscapedFunctions.getFunction(functionName);
+      return (String) escapeMethod.invoke(null, parsedArgs);
+    } catch (InvocationTargetException e) {
+      if (e.getTargetException() instanceof SQLException) {
+        throw (SQLException) e.getTargetException();
+      } else {
+        throw new PSQLException(e.getTargetException().getMessage(), PSQLState.SYSTEM_ERROR);
+      }
+    } catch (Exception e) {
+      // by default the function name is kept unchanged
+      StringBuilder buf = new StringBuilder();
+      buf.append(functionName).append('(');
+      for (int iArg = 0; iArg < parsedArgs.size(); iArg++) {
+        buf.append(parsedArgs.get(iArg));
+        if (iArg != (parsedArgs.size() - 1)) {
+          buf.append(',');
+        }
+      }
+      buf.append(')');
+      return buf.toString();
+    }
+  }
+
+  // Static variables for parsing SQL when replaceProcessing is true.
+  private enum SqlParseState {
+    IN_SQLCODE,
+    ESC_TIMEDATE,
+    ESC_FUNCTION,
+    ESC_OUTERJOIN,
+    ESC_ESCAPECHAR;
+  }
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/ProtocolConnection.java b/pgjdbc/src/main/java/org/postgresql/core/ProtocolConnection.java
deleted file mode 100644
index 2f9663e4c8..0000000000
--- a/pgjdbc/src/main/java/org/postgresql/core/ProtocolConnection.java
+++ /dev/null
@@ -1,195 +0,0 @@
-/*-------------------------------------------------------------------------
-*
-* Copyright (c) 2004-2014, PostgreSQL Global Development Group
-* Copyright (c) 2004, Open Cloud Limited.
-*
-*
-*-------------------------------------------------------------------------
-*/
-
-package org.postgresql.core;
-
-import org.postgresql.PGNotification;
-import org.postgresql.util.HostSpec;
-
-import java.sql.SQLException;
-import java.sql.SQLWarning;
-import java.util.Set;
-import java.util.TimeZone;
-
-/**
- * Provides access to protocol-level connection operations.
- *
- * @author Oliver Jowett (oliver@opencloud.com)
- */
-public interface ProtocolConnection {
-  /**
-   * Constant returned by {@link #getTransactionState} indicating that no transaction is currently
-   * open.
-   */
-  int TRANSACTION_IDLE = 0;
-
-  /**
-   * Constant returned by {@link #getTransactionState} indicating that a transaction is currently
-   * open.
-   */
-  int TRANSACTION_OPEN = 1;
-
-  /**
-   * Constant returned by {@link #getTransactionState} indicating that a transaction is currently
-   * open, but it has seen errors and will refuse subsequent queries until a ROLLBACK.
-   */
-  int TRANSACTION_FAILED = 2;
-
-  /**
-   * @return the host and port this connection is connected to.
-   */
-  HostSpec getHostSpec();
-
-  /**
-   * @return the user this connection authenticated as.
-   */
-  String getUser();
-
-  /**
-   * @return the database this connection is connected to.
-   */
-  String getDatabase();
-
-  /**
-   * Return the server version from the server_version GUC.
-   *
-   * Note that there's no requirement for this to be numeric or of the form x.y.z. PostgreSQL
-   * development releases usually have the format x.ydevel e.g. 9.4devel; betas usually x.ybetan
-   * e.g. 9.4beta1. The --with-extra-version configure option may add an arbitrary string to this.
-   *
-   * Don't use this string for logic, only use it when displaying the server version to the user.
-   * Prefer getServerVersionNum() for all logic purposes.
-   *
-   * @return the server version string from the server_version guc
-   */
-  String getServerVersion();
-
-  /**
-   * Get a machine-readable server version.
-   *
-   * This returns the value of the server_version_num GUC. If no such GUC exists, it falls back on
-   * attempting to parse the text server version for the major version. If there's no minor version
-   * (e.g. a devel or beta release) then the minor version is set to zero. If the version could not
-   * be parsed, zero is returned.
-   *
-   * @return the server version in numeric XXYYZZ form, eg 090401, from server_version_num
-   */
-  int getServerVersionNum();
-
-  /**
-   * @return the current encoding in use by this connection
-   */
-  Encoding getEncoding();
-
-  /**
-   * Returns whether the server treats string-literals according to the SQL standard or if it uses
-   * traditional PostgreSQL escaping rules. Versions up to 8.1 always treated backslashes as escape
-   * characters in string-literals. Since 8.2, this depends on the value of the
-   * <tt>standard_conforming_strings</tt> server variable.
-   *
-   * @return true if the server treats string literals according to the SQL standard
-   */
-  boolean getStandardConformingStrings();
-
-  /**
-   * Get the current transaction state of this connection.
-   *
-   * @return a ProtocolConnection.TRANSACTION_* constant.
-   */
-  int getTransactionState();
-
-  /**
-   * Retrieve and clear the set of asynchronous notifications pending on this connection.
-   *
-   * @return an array of notifications; if there are no notifications, an empty array is returned.
-   * @throws SQLException if and error occurs while fetching notifications
-   */
-  PGNotification[] getNotifications() throws SQLException;
-
-  /**
-   * Retrieve and clear the chain of warnings accumulated on this connection.
-   *
-   * @return the first SQLWarning in the chain; subsequent warnings can be found via
-   *         SQLWarning.getNextWarning().
-   */
-  SQLWarning getWarnings();
-
-  /**
-   * @return the QueryExecutor instance for this connection.
-   */
-  QueryExecutor getQueryExecutor();
-
-  /**
-   * Sends a query cancellation for this connection.
-   *
-   * @throws SQLException if something goes wrong.
-   */
-  void sendQueryCancel() throws SQLException;
-
-  /**
-   * Close this connection cleanly.
-   */
-  void close();
-
-  /**
-   * Check if this connection is closed.
-   *
-   * @return true iff the connection is closed.
-   */
-  boolean isClosed();
-
-  /**
-   * @return the version of the implementation
-   */
-  int getProtocolVersion();
-
-  /**
-   * Sets the oids that should be received using binary encoding.
-   *
-   * @param useBinaryForOids The oids to request with binary encoding.
-   */
-  void setBinaryReceiveOids(Set<Integer> useBinaryForOids);
-
-  /**
-   * Returns true if server uses integer instead of double for binary date and time encodings.
-   *
-   * @return the server integer_datetime setting.
-   */
-  boolean getIntegerDateTimes();
-
-  /**
-   * Return the process ID (PID) of the backend server process handling this connection.
-   *
-   * @return process ID (PID) of the backend server process handling this connection
-   */
-  int getBackendPID();
-
-  /**
-   * Abort at network level without sending the Terminate message to the backend.
-   */
-  void abort();
-
-  /**
-   * Return TimestampUtils that is aware of connection-specific {@code TimeZone} value.
-   *
-   * @return timestampUtils instance
-   */
-
-  /**
-   * Returns backend timezone in java format.
-   * @return backend timezone in java format.
-   */
-  TimeZone getTimeZone();
-
-  /**
-   * Returns application_name connection property.
-   * @return application_name connection property
-   */
-  String getApplicationName();
-}
diff --git a/pgjdbc/src/main/java/org/postgresql/core/Query.java b/pgjdbc/src/main/java/org/postgresql/core/Query.java
index e1df5c1f92..372cf62375 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/Query.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/Query.java
@@ -9,6 +9,8 @@
 
 package org.postgresql.core;
 
+import java.util.Map;
+
 /**
  * Abstraction of a generic Query, hiding the details of any protocol-version-specific data needed
  * to execute the query efficiently.
@@ -40,6 +42,18 @@ public interface Query {
    */
   String toString(ParameterList parameters);
 
+  /**
+   * Returns SQL in native for database format
+   * @return SQL in native for database format
+   */
+  String getNativeSql();
+
+  /**
+   * Returns properties of the query (sql keyword, and some other parsing info).
+   * @return returns properties of the query (sql keyword, and some other parsing info) or null if not applicable
+   */
+  SqlCommand getSqlCommand();
+
   /**
    * Close this query and free any server-side resources associated with it. The resources may not
    * be immediately deallocated, but closing a Query may make the deallocation more prompt.
@@ -57,4 +71,20 @@ public interface Query {
    * @return number of times <code>addBatch()</code> has been called.
    */
   int getBatchSize();
+
+  /**
+   * Get a map that a result set can use to find the index associated to a name.
+   *
+   * @return null if the query implementation does not support this method.
+   */
+  Map<String, Integer> getResultSetColumnNameIndexMap();
+
+  /**
+   * Return a list of the Query objects that make up this query. If this object is already a
+   * SimpleQuery, returns null (avoids an extra array construction in the common case).
+   *
+   * @return an array of single-statement queries, or <code>null</code> if this object is already a
+   *         single-statement query.
+   */
+  Query[] getSubqueries();
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/QueryExecutor.java b/pgjdbc/src/main/java/org/postgresql/core/QueryExecutor.java
index ab36c4f163..9fbc14b888 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/QueryExecutor.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/QueryExecutor.java
@@ -9,10 +9,19 @@
 
 package org.postgresql.core;
 
+import org.postgresql.PGNotification;
 import org.postgresql.copy.CopyOperation;
+import org.postgresql.core.v3.TypeTransferModeRegistry;
+import org.postgresql.jdbc.AutoSave;
 import org.postgresql.jdbc.BatchResultHandler;
+import org.postgresql.jdbc.PreferQueryMode;
+import org.postgresql.util.HostSpec;
 
 import java.sql.SQLException;
+import java.sql.SQLWarning;
+import java.util.List;
+import java.util.Set;
+import java.util.TimeZone;
 
 /**
  * Abstracts the protocol-specific details of executing a query.
@@ -21,8 +30,8 @@
  * provides:
  *
  * <ul>
- * <li>factory methods for Query objects ({@link #createSimpleQuery} and
- * {@link #createParameterizedQuery})
+ * <li>factory methods for Query objects ({@link #createSimpleQuery(String)} and
+ * {@link #createQuery(String, boolean, boolean, String...)})
  * <li>execution methods for created Query objects (
  * {@link #execute(Query, ParameterList, ResultHandler, int, int, int)} for single queries and
  * {@link #execute(Query[], ParameterList[], BatchResultHandler, int, int, int)} for batches of queries)
@@ -44,7 +53,7 @@
  *
  * @author Oliver Jowett (oliver@opencloud.com)
  */
-public interface QueryExecutor {
+public interface QueryExecutor extends TypeTransferModeRegistry {
   /**
    * Flag for query execution that indicates the given Query object is unlikely to be reused.
    */
@@ -106,12 +115,18 @@ public interface QueryExecutor {
    */
   int QUERY_NO_BINARY_TRANSFER = 256;
 
+  /**
+   * Execute the query via simple 'Q' command (not parse, bind, exec, but simple execute).
+   * This sends query text on each execution, however it supports sending multiple queries
+   * separated with ';' as a single command.
+   */
+  int QUERY_EXECUTE_AS_SIMPLE = 1024;
+
   /**
    * Execute a Query, passing results to a provided ResultHandler.
    *
    * @param query the query to execute; must be a query returned from calling
-   *        {@link #createSimpleQuery(String, boolean)} or {@link #createParameterizedQuery(String, boolean)} on this
-   *        QueryExecutor object.
+   *        {@link #wrap(List)} on this QueryExecutor object.
    * @param parameters the parameters for the query. Must be non-<code>null</code> if the query
    *        takes parameters. Must be a parameter object returned by
    *        {@link org.postgresql.core.Query#createParameterList()}.
@@ -129,8 +144,7 @@ void execute(Query query, ParameterList parameters, ResultHandler handler, int m
    * Execute several Query, passing results to a provided ResultHandler.
    *
    * @param queries the queries to execute; each must be a query returned from calling
-   *        {@link #createSimpleQuery(String, boolean)} or {@link #createParameterizedQuery(String, boolean)}
-   *         on this QueryExecutor object.
+   *        {@link #wrap(List)} on this QueryExecutor object.
    * @param parameterLists the parameter lists for the queries. The parameter lists correspond 1:1
    *        to the queries passed in the <code>queries</code> array. Each must be non-
    *        <code>null</code> if the corresponding query takes parameters, and must be a parameter
@@ -163,22 +177,38 @@ void execute(Query[] queries, ParameterList[] parameterLists, BatchResultHandler
    * ParameterList.
    *
    * @param sql the SQL for the query to create
-   * @param autocommit indicating when connection has autocommit enabled.
    * @return a new Query object
+   * @throws SQLException if something goes wrong
    */
-  Query createSimpleQuery(String sql, boolean autocommit);
+  Query createSimpleQuery(String sql) throws SQLException;
+
+  boolean isReWriteBatchedInsertsEnabled();
+
+  CachedQuery createQuery(String sql, boolean escapeProcessing, boolean isParameterized,
+      String... columnNames)
+      throws SQLException;
+
+  Object createQueryKey(String sql, boolean escapeProcessing, boolean isParameterized,
+      String... columnNames);
+
+  CachedQuery createQueryByKey(Object key) throws SQLException;
+
+  CachedQuery borrowQueryByKey(Object key) throws SQLException;
+
+  CachedQuery borrowQuery(String sql) throws SQLException;
+
+  CachedQuery borrowCallableQuery(String sql) throws SQLException;
+
+  CachedQuery borrowReturningQuery(String sql, String[] columnNames) throws SQLException;
+
+  void releaseQuery(CachedQuery cachedQuery);
 
   /**
-   * Create a parameterized Query object suitable for execution by this QueryExecutor. The provided
-   * query string is parsed for parameter placeholders ('?' characters), and the
-   * {@link Query#createParameterList} of the returned object will create an appropriately-sized
-   * ParameterList.
-   *
-   * @param sql the SQL for the query to create, with '?' placeholders for parameters.
-   * @param autocommit indicating when connection has autocommit enabled.
-   * @return a new Query object
+   * Wrap given native query into a ready for execution format
+   * @param queries list of queries in native to database syntax
+   * @return query object ready for execution by this query executor
    */
-  Query createParameterizedQuery(String sql, boolean autocommit); // Parsed for parameter placeholders ('?')
+  Query wrap(List<NativeQuery> queries);
 
   /**
    * Prior to attempting to retrieve notifications, we need to pull any recently received
@@ -227,4 +257,171 @@ void execute(Query[] queries, ParameterList[] parameterLists, BatchResultHandler
    * @throws SQLException when initializing the given query fails
    */
   CopyOperation startCopy(String sql, boolean suppressBegin) throws SQLException;
+
+  /**
+   * @return the version of the implementation
+   */
+  int getProtocolVersion();
+
+  /**
+   * Sets the oids that should be received using binary encoding.
+   *
+   * @param useBinaryForOids The oids to request with binary encoding.
+   */
+  void setBinaryReceiveOids(Set<Integer> useBinaryForOids);
+
+  /**
+   * Sets the oids that should be sent using binary encoding.
+   *
+   * @param useBinaryForOids The oids to send with binary encoding.
+   */
+  void setBinarySendOids(Set<Integer> useBinaryForOids);
+
+  /**
+   * Returns true if server uses integer instead of double for binary date and time encodings.
+   *
+   * @return the server integer_datetime setting.
+   */
+  boolean getIntegerDateTimes();
+
+  /**
+   * @return the host and port this connection is connected to.
+   */
+  HostSpec getHostSpec();
+
+  /**
+   * @return the user this connection authenticated as.
+   */
+  String getUser();
+
+  /**
+   * @return the database this connection is connected to.
+   */
+  String getDatabase();
+
+  /**
+   * Sends a query cancellation for this connection.
+   *
+   * @throws SQLException if something goes wrong.
+   */
+  void sendQueryCancel() throws SQLException;
+
+  /**
+   * Return the process ID (PID) of the backend server process handling this connection.
+   *
+   * @return process ID (PID) of the backend server process handling this connection
+   */
+  int getBackendPID();
+
+  /**
+   * Abort at network level without sending the Terminate message to the backend.
+   */
+  void abort();
+
+  /**
+   * Close this connection cleanly.
+   */
+  void close();
+
+  /**
+   * Check if this connection is closed.
+   *
+   * @return true iff the connection is closed.
+   */
+  boolean isClosed();
+
+  /**
+   * Return the server version from the server_version GUC.
+   *
+   * Note that there's no requirement for this to be numeric or of the form x.y.z. PostgreSQL
+   * development releases usually have the format x.ydevel e.g. 9.4devel; betas usually x.ybetan
+   * e.g. 9.4beta1. The --with-extra-version configure option may add an arbitrary string to this.
+   *
+   * Don't use this string for logic, only use it when displaying the server version to the user.
+   * Prefer getServerVersionNum() for all logic purposes.
+   *
+   * @return the server version string from the server_version guc
+   */
+  String getServerVersion();
+
+  /**
+   * Retrieve and clear the set of asynchronous notifications pending on this connection.
+   *
+   * @return an array of notifications; if there are no notifications, an empty array is returned.
+   * @throws SQLException if and error occurs while fetching notifications
+   */
+  PGNotification[] getNotifications() throws SQLException;
+
+  /**
+   * Retrieve and clear the chain of warnings accumulated on this connection.
+   *
+   * @return the first SQLWarning in the chain; subsequent warnings can be found via
+   *         SQLWarning.getNextWarning().
+   */
+  SQLWarning getWarnings();
+
+  /**
+   * Get a machine-readable server version.
+   *
+   * This returns the value of the server_version_num GUC. If no such GUC exists, it falls back on
+   * attempting to parse the text server version for the major version. If there's no minor version
+   * (e.g. a devel or beta release) then the minor version is set to zero. If the version could not
+   * be parsed, zero is returned.
+   *
+   * @return the server version in numeric XXYYZZ form, eg 090401, from server_version_num
+   */
+  int getServerVersionNum();
+
+  /**
+   * Get the current transaction state of this connection.
+   *
+   * @return a ProtocolConnection.TRANSACTION_* constant.
+   */
+  TransactionState getTransactionState();
+
+  /**
+   * Returns whether the server treats string-literals according to the SQL standard or if it uses
+   * traditional PostgreSQL escaping rules. Versions up to 8.1 always treated backslashes as escape
+   * characters in string-literals. Since 8.2, this depends on the value of the
+   * <tt>standard_conforming_strings</tt> server variable.
+   *
+   * @return true if the server treats string literals according to the SQL standard
+   */
+  boolean getStandardConformingStrings();
+
+  /**
+   * Returns backend timezone in java format.
+   * @return backend timezone in java format.
+   */
+  TimeZone getTimeZone();
+
+  /**
+   * @return the current encoding in use by this connection
+   */
+  Encoding getEncoding();
+
+  /**
+   * Returns application_name connection property.
+   * @return application_name connection property
+   */
+  String getApplicationName();
+
+  boolean isColumnSanitiserDisabled();
+
+  PreferQueryMode getPreferQueryMode();
+
+  AutoSave getAutoSave();
+
+  void setAutoSave(AutoSave autoSave);
+
+  boolean willHealOnRetry(SQLException e);
+
+  /**
+   * By default, the connection resets statement cache in case deallocate all/discard all
+   * message is observed.
+   * This API allows to disable that feature for testing purposes.
+   *
+   * @param flushCacheOnDeallocate true if statement cache should be reset when "deallocate/discard" message observed
+   */
+  void setFlushCacheOnDeallocate(boolean flushCacheOnDeallocate);
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/QueryExecutorBase.java b/pgjdbc/src/main/java/org/postgresql/core/QueryExecutorBase.java
new file mode 100644
index 0000000000..686a970b7b
--- /dev/null
+++ b/pgjdbc/src/main/java/org/postgresql/core/QueryExecutorBase.java
@@ -0,0 +1,378 @@
+package org.postgresql.core;
+
+import org.postgresql.PGNotification;
+import org.postgresql.PGProperty;
+import org.postgresql.jdbc.AutoSave;
+import org.postgresql.jdbc.PreferQueryMode;
+import org.postgresql.util.HostSpec;
+import org.postgresql.util.LruCache;
+import org.postgresql.util.PSQLException;
+import org.postgresql.util.PSQLState;
+import org.postgresql.util.ServerErrorMessage;
+
+import java.io.IOException;
+import java.sql.SQLException;
+import java.sql.SQLWarning;
+import java.util.ArrayList;
+import java.util.Properties;
+
+public abstract class QueryExecutorBase implements QueryExecutor {
+  protected final Logger logger;
+  protected final PGStream pgStream;
+  private final String user;
+  private final String database;
+  private final int cancelSignalTimeout;
+
+  private int cancelPid;
+  private int cancelKey;
+  private boolean closed = false;
+  private String serverVersion;
+  private int serverVersionNum = 0;
+  private TransactionState transactionState;
+  private final boolean reWriteBatchedInserts;
+  private final boolean columnSanitiserDisabled;
+  private final PreferQueryMode preferQueryMode;
+  private AutoSave autoSave;
+  private boolean flushCacheOnDeallocate = true;
+
+  // default value for server versions that don't report standard_conforming_strings
+  private boolean standardConformingStrings = false;
+
+  private SQLWarning warnings;
+  private final ArrayList<PGNotification> notifications = new ArrayList<PGNotification>();
+
+  private final LruCache<Object, CachedQuery> statementCache;
+  private final CachedQueryCreateAction cachedQueryCreateAction;
+
+  protected QueryExecutorBase(Logger logger, PGStream pgStream, String user, String database,
+      int cancelSignalTimeout, Properties info) throws SQLException {
+    this.logger = logger;
+    this.pgStream = pgStream;
+    this.user = user;
+    this.database = database;
+    this.cancelSignalTimeout = cancelSignalTimeout;
+    this.reWriteBatchedInserts = PGProperty.REWRITE_BATCHED_INSERTS.getBoolean(info);
+    this.columnSanitiserDisabled = PGProperty.DISABLE_COLUMN_SANITISER.getBoolean(info);
+    String preferMode = PGProperty.PREFER_QUERY_MODE.get(info);
+    this.preferQueryMode = PreferQueryMode.of(preferMode);
+    this.autoSave = AutoSave.of(PGProperty.AUTOSAVE.get(info));
+    this.cachedQueryCreateAction = new CachedQueryCreateAction(this);
+    statementCache = new LruCache<Object, CachedQuery>(
+        Math.max(0, PGProperty.PREPARED_STATEMENT_CACHE_QUERIES.getInt(info)),
+        Math.max(0, PGProperty.PREPARED_STATEMENT_CACHE_SIZE_MIB.getInt(info) * 1024 * 1024),
+        false,
+        cachedQueryCreateAction,
+        new LruCache.EvictAction<CachedQuery>() {
+          @Override
+          public void evict(CachedQuery cachedQuery) throws SQLException {
+            cachedQuery.query.close();
+          }
+        });
+  }
+
+  protected abstract void sendCloseMessage() throws IOException;
+
+  @Override
+  public HostSpec getHostSpec() {
+    return pgStream.getHostSpec();
+  }
+
+  @Override
+  public String getUser() {
+    return user;
+  }
+
+  @Override
+  public String getDatabase() {
+    return database;
+  }
+
+  public void setBackendKeyData(int cancelPid, int cancelKey) {
+    this.cancelPid = cancelPid;
+    this.cancelKey = cancelKey;
+  }
+
+  @Override
+  public int getBackendPID() {
+    return cancelPid;
+  }
+
+  @Override
+  public void abort() {
+    try {
+      pgStream.getSocket().close();
+    } catch (IOException e) {
+      // ignore
+    }
+    closed = true;
+  }
+
+  @Override
+  public void close() {
+    if (closed) {
+      return;
+    }
+
+    try {
+      if (logger.logDebug()) {
+        logger.debug(" FE=> Terminate");
+      }
+      sendCloseMessage();
+      pgStream.flush();
+      pgStream.close();
+    } catch (IOException ioe) {
+      // Forget it.
+      if (logger.logDebug()) {
+        logger.debug("Discarding IOException on close:", ioe);
+      }
+    }
+
+    closed = true;
+  }
+
+  @Override
+  public boolean isClosed() {
+    return closed;
+  }
+
+  @Override
+  public void sendQueryCancel() throws SQLException {
+    if (cancelPid <= 0) {
+      return;
+    }
+
+    PGStream cancelStream = null;
+
+    // Now we need to construct and send a cancel packet
+    try {
+      if (logger.logDebug()) {
+        logger.debug(" FE=> CancelRequest(pid=" + cancelPid + ",ckey=" + cancelKey + ")");
+      }
+
+      cancelStream =
+          new PGStream(pgStream.getSocketFactory(), pgStream.getHostSpec(), cancelSignalTimeout);
+      if (cancelSignalTimeout > 0) {
+        cancelStream.getSocket().setSoTimeout(cancelSignalTimeout);
+      }
+      cancelStream.sendInteger4(16);
+      cancelStream.sendInteger2(1234);
+      cancelStream.sendInteger2(5678);
+      cancelStream.sendInteger4(cancelPid);
+      cancelStream.sendInteger4(cancelKey);
+      cancelStream.flush();
+      cancelStream.receiveEOF();
+    } catch (IOException e) {
+      // Safe to ignore.
+      if (logger.logDebug()) {
+        logger.debug("Ignoring exception on cancel request:", e);
+      }
+    } finally {
+      if (cancelStream != null) {
+        try {
+          cancelStream.close();
+        } catch (IOException e) {
+          // Ignored.
+        }
+      }
+    }
+  }
+
+  public synchronized void addWarning(SQLWarning newWarning) {
+    if (warnings == null) {
+      warnings = newWarning;
+    } else {
+      warnings.setNextWarning(newWarning);
+    }
+  }
+
+  public synchronized void addNotification(PGNotification notification) {
+    notifications.add(notification);
+  }
+
+  @Override
+  public synchronized PGNotification[] getNotifications() throws SQLException {
+    PGNotification[] array = notifications.toArray(new PGNotification[notifications.size()]);
+    notifications.clear();
+    return array;
+  }
+
+  @Override
+  public synchronized SQLWarning getWarnings() {
+    SQLWarning chain = warnings;
+    warnings = null;
+    return chain;
+  }
+
+  @Override
+  public String getServerVersion() {
+    return serverVersion;
+  }
+
+  @Override
+  public int getServerVersionNum() {
+    if (serverVersionNum != 0) {
+      return serverVersionNum;
+    }
+    return serverVersionNum = Utils.parseServerVersionStr(serverVersion);
+  }
+
+  public void setServerVersion(String serverVersion) {
+    this.serverVersion = serverVersion;
+  }
+
+  public void setServerVersionNum(int serverVersionNum) {
+    this.serverVersionNum = serverVersionNum;
+  }
+
+  public synchronized void setTransactionState(TransactionState state) {
+    transactionState = state;
+  }
+
+  public synchronized void setStandardConformingStrings(boolean value) {
+    standardConformingStrings = value;
+  }
+
+  @Override
+  public synchronized boolean getStandardConformingStrings() {
+    return standardConformingStrings;
+  }
+
+  @Override
+  public synchronized TransactionState getTransactionState() {
+    return transactionState;
+  }
+
+  public void setEncoding(Encoding encoding) throws IOException {
+    pgStream.setEncoding(encoding);
+  }
+
+  @Override
+  public Encoding getEncoding() {
+    return pgStream.getEncoding();
+  }
+
+  @Override
+  public boolean isReWriteBatchedInsertsEnabled() {
+    return this.reWriteBatchedInserts;
+  }
+
+  @Override
+  public final CachedQuery borrowQuery(String sql) throws SQLException {
+    return statementCache.borrow(sql);
+  }
+
+  @Override
+  public final CachedQuery borrowCallableQuery(String sql) throws SQLException {
+    return statementCache.borrow(new CallableQueryKey(sql));
+  }
+
+  @Override
+  public final CachedQuery borrowReturningQuery(String sql, String[] columnNames) throws SQLException {
+    return statementCache.borrow(new QueryWithReturningColumnsKey(sql, true, true,
+        columnNames
+    ));
+  }
+
+  @Override
+  public CachedQuery borrowQueryByKey(Object key) throws SQLException {
+    return statementCache.borrow(key);
+  }
+
+  @Override
+  public void releaseQuery(CachedQuery cachedQuery) {
+    statementCache.put(cachedQuery.key, cachedQuery);
+  }
+
+  @Override
+  public final Object createQueryKey(String sql, boolean escapeProcessing,
+      boolean isParameterized, String... columnNames) {
+    Object key;
+    if (columnNames == null || columnNames.length != 0) {
+      // Null means "return whatever sensible columns are" (e.g. primary key, or serial, or something like that)
+      key = new QueryWithReturningColumnsKey(sql, isParameterized, escapeProcessing, columnNames);
+    } else if (isParameterized) {
+      // If no generated columns requested, just use the SQL as a cache key
+      key = sql;
+    } else {
+      key = new BaseQueryKey(sql, false, escapeProcessing);
+    }
+    return key;
+  }
+
+  @Override
+  public CachedQuery createQueryByKey(Object key) throws SQLException {
+    return cachedQueryCreateAction.create(key);
+  }
+
+  @Override
+  public final CachedQuery createQuery(String sql, boolean escapeProcessing,
+      boolean isParameterized, String... columnNames)
+      throws SQLException {
+    Object key = createQueryKey(sql, escapeProcessing, isParameterized, columnNames);
+    // Note: cache is not reused here for two reasons:
+    //   1) Simplify initial implementation for simple statements
+    //   2) Non-prepared statements are likely to have literals, thus query reuse would not be often
+    return createQueryByKey(key);
+  }
+
+  @Override
+  public boolean isColumnSanitiserDisabled() {
+    return columnSanitiserDisabled;
+  }
+
+  @Override
+  public PreferQueryMode getPreferQueryMode() {
+    return preferQueryMode;
+  }
+
+  public AutoSave getAutoSave() {
+    return autoSave;
+  }
+
+  public void setAutoSave(AutoSave autoSave) {
+    this.autoSave = autoSave;
+  }
+
+  protected boolean willHealViaReparse(SQLException e) {
+    // "prepared statement \"S_2\" does not exist"
+    if (PSQLState.INVALID_SQL_STATEMENT_NAME.getState().equals(e.getSQLState())) {
+      return true;
+    }
+    if (!PSQLState.NOT_IMPLEMENTED.getState().equals(e.getSQLState())) {
+      return false;
+    }
+
+    if (!(e instanceof PSQLException)) {
+      return false;
+    }
+
+    PSQLException pe = (PSQLException) e;
+
+    ServerErrorMessage serverErrorMessage = pe.getServerErrorMessage();
+    if (serverErrorMessage == null) {
+      return false;
+    }
+    // "cached plan must not change result type"
+    String routine = pe.getServerErrorMessage().getRoutine();
+    return "RevalidateCachedQuery".equals(routine) // 9.2+
+        || "RevalidateCachedPlan".equals(routine); // <= 9.1
+  }
+
+  @Override
+  public boolean willHealOnRetry(SQLException e) {
+    if (autoSave == AutoSave.NEVER && getTransactionState() == TransactionState.FAILED) {
+      // If autorollback is not activated, then every statement will fail with
+      // 'transaction is aborted', etc, etc
+      return false;
+    }
+    return willHealViaReparse(e);
+  }
+
+  public boolean isFlushCacheOnDeallocate() {
+    return flushCacheOnDeallocate;
+  }
+
+  public void setFlushCacheOnDeallocate(boolean flushCacheOnDeallocate) {
+    this.flushCacheOnDeallocate = flushCacheOnDeallocate;
+  }
+}
diff --git a/pgjdbc/src/main/java/org/postgresql/core/QueryWithReturningColumnsKey.java b/pgjdbc/src/main/java/org/postgresql/core/QueryWithReturningColumnsKey.java
new file mode 100644
index 0000000000..2a42753b58
--- /dev/null
+++ b/pgjdbc/src/main/java/org/postgresql/core/QueryWithReturningColumnsKey.java
@@ -0,0 +1,59 @@
+package org.postgresql.core;
+
+import java.util.Arrays;
+
+/**
+ * Cache key for a query that have some returning columns.
+ * {@code columnNames} should contain non-quoted column names.
+ * The parser will quote them automatically.
+ * <p>There's a special case of {@code columnNames == new String[]{"*"}} that means all columns
+ * should be returned. {@link Parser} is aware of that and does not quote {@code *}</p>
+ */
+class QueryWithReturningColumnsKey extends BaseQueryKey {
+  public final String[] columnNames;
+
+  public QueryWithReturningColumnsKey(String sql, boolean isParameterized, boolean escapeProcessing,
+      String[] columnNames) {
+    super(sql, isParameterized, escapeProcessing);
+    if (columnNames == null) {
+      // TODO: teach parser to fetch key columns somehow when no column names were given
+      columnNames = new String[]{"*"};
+    }
+    this.columnNames = columnNames;
+  }
+
+  @Override
+  public String toString() {
+    return "QueryWithReturningColumnsKey{"
+        + "sql='" + sql + '\''
+        + ", isParameterized=" + isParameterized
+        + ", escapeProcessing=" + escapeProcessing
+        + ", columnNames=" + Arrays.toString(columnNames)
+        + '}';
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) {
+      return true;
+    }
+    if (o == null || getClass() != o.getClass()) {
+      return false;
+    }
+    if (!super.equals(o)) {
+      return false;
+    }
+
+    QueryWithReturningColumnsKey that = (QueryWithReturningColumnsKey) o;
+
+    // Probably incorrect - comparing Object[] arrays with Arrays.equals
+    return Arrays.equals(columnNames, that.columnNames);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = super.hashCode();
+    result = 31 * result + Arrays.hashCode(columnNames);
+    return result;
+  }
+}
diff --git a/pgjdbc/src/main/java/org/postgresql/core/ResultHandler.java b/pgjdbc/src/main/java/org/postgresql/core/ResultHandler.java
index 5d28915a34..b6f29c822f 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/ResultHandler.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/ResultHandler.java
@@ -76,4 +76,23 @@ void handleResultRows(Query fromQuery, Field[] fields, List<byte[][]> tuples,
    * @throws SQLException if the handler wishes the original method to throw an exception.
    */
   void handleCompletion() throws SQLException;
+
+  /**
+   * Callback for batch statements. In case batch statement is executed in autocommit==true mode,
+   * the executor might commit "as it this it is best", so the result handler should track which
+   * statements are executed successfully and which are not.
+   */
+  void secureProgress();
+
+  /**
+   * Returns the first encountered exception. The rest are chained via {@link SQLException#setNextException(SQLException)}
+   * @return the first encountered exception
+   */
+  SQLException getException();
+
+  /**
+   * Returns the first encountered warning. The rest are chained via {@link SQLException#setNextException(SQLException)}
+   * @return the first encountered warning
+   */
+  SQLWarning getWarning();
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/ResultHandlerBase.java b/pgjdbc/src/main/java/org/postgresql/core/ResultHandlerBase.java
new file mode 100644
index 0000000000..2b87d0d48d
--- /dev/null
+++ b/pgjdbc/src/main/java/org/postgresql/core/ResultHandlerBase.java
@@ -0,0 +1,78 @@
+/*-------------------------------------------------------------------------
+*
+* Copyright (c) 2016-2016, PostgreSQL Global Development Group
+*
+*
+*-------------------------------------------------------------------------
+*/
+
+package org.postgresql.core;
+
+import java.sql.SQLException;
+import java.sql.SQLWarning;
+import java.util.List;
+
+/**
+ * Empty implementation of {@link ResultHandler} interface.
+ * {@link SQLException#setNextException(SQLException)} has {@code O(N)} complexity,
+ * so this class tracks the last exception object to speedup {@code setNextException}.
+ */
+public class ResultHandlerBase implements ResultHandler {
+  // Last exception is tracked to avoid O(N) SQLException#setNextException just in case there
+  // will be lots of exceptions (e.g. all batch rows fail with constraint violation or so)
+  private SQLException firstException;
+  private SQLException lastException;
+
+  private SQLWarning firstWarning;
+  private SQLWarning lastWarning;
+
+  @Override
+  public void handleResultRows(Query fromQuery, Field[] fields, List<byte[][]> tuples,
+      ResultCursor cursor) {
+  }
+
+  @Override
+  public void handleCommandStatus(String status, int updateCount, long insertOID) {
+  }
+
+  @Override
+  public void secureProgress() {
+  }
+
+  @Override
+  public void handleWarning(SQLWarning warning) {
+    if (firstWarning == null) {
+      firstWarning = lastWarning = warning;
+      return;
+    }
+    lastWarning.setNextException(warning);
+    lastWarning = warning;
+  }
+
+  @Override
+  public void handleError(SQLException error) {
+    if (firstException == null) {
+      firstException = lastException = error;
+      return;
+    }
+    lastException.setNextException(error);
+    lastException = error;
+  }
+
+  @Override
+  public void handleCompletion() throws SQLException {
+    if (firstException != null) {
+      throw firstException;
+    }
+  }
+
+  @Override
+  public SQLException getException() {
+    return firstException;
+  }
+
+  @Override
+  public SQLWarning getWarning() {
+    return firstWarning;
+  }
+}
diff --git a/pgjdbc/src/main/java/org/postgresql/core/ResultHandlerDelegate.java b/pgjdbc/src/main/java/org/postgresql/core/ResultHandlerDelegate.java
new file mode 100644
index 0000000000..8c4ff03a11
--- /dev/null
+++ b/pgjdbc/src/main/java/org/postgresql/core/ResultHandlerDelegate.java
@@ -0,0 +1,78 @@
+package org.postgresql.core;
+
+import java.sql.SQLException;
+import java.sql.SQLWarning;
+import java.util.List;
+
+/**
+ * Internal to the driver class, please do not use in the application.
+ *
+ * <p>The class simplifies creation of ResultHandler delegates: it provides default implementation
+ * for the interface methods</p>
+ */
+public class ResultHandlerDelegate implements ResultHandler {
+  private final ResultHandler delegate;
+
+  public ResultHandlerDelegate(ResultHandler delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override
+  public void handleResultRows(Query fromQuery, Field[] fields, List<byte[][]> tuples,
+      ResultCursor cursor) {
+    if (delegate != null) {
+      delegate.handleResultRows(fromQuery, fields, tuples, cursor);
+    }
+  }
+
+  @Override
+  public void handleCommandStatus(String status, int updateCount, long insertOID) {
+    if (delegate != null) {
+      delegate.handleCommandStatus(status, updateCount, insertOID);
+    }
+  }
+
+  @Override
+  public void handleWarning(SQLWarning warning) {
+    if (delegate != null) {
+      delegate.handleWarning(warning);
+    }
+  }
+
+  @Override
+  public void handleError(SQLException error) {
+    if (delegate != null) {
+      delegate.handleError(error);
+    }
+  }
+
+  @Override
+  public void handleCompletion() throws SQLException {
+    if (delegate != null) {
+      delegate.handleCompletion();
+    }
+  }
+
+  @Override
+  public void secureProgress() {
+    if (delegate != null) {
+      delegate.secureProgress();
+    }
+  }
+
+  @Override
+  public SQLException getException() {
+    if (delegate != null) {
+      return delegate.getException();
+    }
+    return null;
+  }
+
+  @Override
+  public SQLWarning getWarning() {
+    if (delegate != null) {
+      return delegate.getWarning();
+    }
+    return null;
+  }
+}
diff --git a/pgjdbc/src/main/java/org/postgresql/core/ServerVersion.java b/pgjdbc/src/main/java/org/postgresql/core/ServerVersion.java
index 56a84e39f2..b983cf5019 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/ServerVersion.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/ServerVersion.java
@@ -28,6 +28,7 @@ public enum ServerVersion implements Version {
   v9_4("9.4.0"),
   v9_5("9.5.0"),
   v9_6("9.6.0"),
+  v10("10")
   ;
 
   private final int version;
@@ -101,29 +102,39 @@ public String toString() {
    * @return server version in number form
    */
   static int parseServerVersionStr(String serverVersion) throws NumberFormatException {
-    int vers;
     NumberFormat numformat = NumberFormat.getIntegerInstance();
     numformat.setGroupingUsed(false);
     ParsePosition parsepos = new ParsePosition(0);
-    Long parsed;
 
     if (serverVersion == null) {
       return 0;
     }
 
-    /* Get first major version part */
-    parsed = (Long) numformat.parseObject(serverVersion, parsepos);
-    if (parsed == null) {
-      return 0;
+    int[] parts = new int[3];
+    int versionParts;
+    for (versionParts = 0; versionParts < 3; versionParts++) {
+      Number part = (Number) numformat.parseObject(serverVersion, parsepos);
+      if (part == null) {
+        break;
+      }
+      parts[versionParts] = part.intValue();
+      if (parsepos.getIndex() == serverVersion.length()
+          || serverVersion.charAt(parsepos.getIndex()) != '.') {
+        break;
+      }
+      // Skip .
+      parsepos.setIndex(parsepos.getIndex() + 1);
     }
-    if (parsed.intValue() >= 10000) {
+    versionParts++;
+
+    if (parts[0] >= 10000) {
       /*
        * PostgreSQL version 1000? I don't think so. We're seeing a version like 90401; return it
        * verbatim, but only if there's nothing else in the version. If there is, treat it as a parse
        * error.
        */
-      if (parsepos.getIndex() == serverVersion.length()) {
-        return parsed.intValue();
+      if (parsepos.getIndex() == serverVersion.length() && versionParts == 1) {
+        return parts[0];
       } else {
         throw new NumberFormatException(
             "First major-version part equal to or greater than 10000 in invalid version string: "
@@ -131,64 +142,36 @@ static int parseServerVersionStr(String serverVersion) throws NumberFormatExcept
       }
     }
 
-    vers = parsed.intValue() * 10000;
-
-    /* Did we run out of string? */
-    if (parsepos.getIndex() == serverVersion.length()) {
-      return 0;
-    }
-
-    /* Skip the . */
-    if (serverVersion.charAt(parsepos.getIndex()) == '.') {
-      parsepos.setIndex(parsepos.getIndex() + 1);
-    } else {
-      /* Unexpected version format */
-      return 0;
-    }
-
-    /*
-     * Get second major version part. If this isn't purely an integer, accept the integer part and
-     * return with a minor version of zero, so we cope with 8.1devel, etc.
-     */
-    parsed = (Long) numformat.parseObject(serverVersion, parsepos);
-    if (parsed == null) {
-      /*
-       * Failed to parse second part of minor version at all. Half a major version is useless,
-       * return 0.
-       */
-      return 0;
-    }
-    if (parsed.intValue() > 99) {
-      throw new NumberFormatException(
-          "Unsupported second part of major version > 99 in invalid version string: "
-              + serverVersion);
-    }
-    vers = vers + parsed.intValue() * 100;
-
-    /* Did we run out of string? Return just the major. */
-    if (parsepos.getIndex() == serverVersion.length()) {
-      return vers;
-    }
-
-    /* Skip the . */
-    if (serverVersion.charAt(parsepos.getIndex()) == '.') {
-      parsepos.setIndex(parsepos.getIndex() + 1);
-    } else {
-      /* Doesn't look like an x.y.z version, return what we have */
-      return vers;
+    if (versionParts == 3) {
+      if (parts[1] > 99) {
+        throw new NumberFormatException(
+            "Unsupported second part of major version > 99 in invalid version string: "
+                + serverVersion);
+      }
+      if (parts[2] > 99) {
+        throw new NumberFormatException(
+            "Unsupported second part of minor version > 99 in invalid version string: "
+                + serverVersion);
+      }
+      return (parts[0] * 100 + parts[1]) * 100 + parts[2];
     }
-
-    /* Try to parse any remainder as a minor version */
-    parsed = (Long) numformat.parseObject(serverVersion, parsepos);
-    if (parsed != null) {
-      if (parsed.intValue() > 99) {
+    if (versionParts == 2) {
+      if (parts[0] >= 10) {
+        return parts[0] * 100 * 100 + parts[1];
+      }
+      if (parts[1] > 99) {
         throw new NumberFormatException(
-            "Unsupported minor version value > 99 in invalid version string: " + serverVersion);
+            "Unsupported second part of major version > 99 in invalid version string: "
+                + serverVersion);
       }
-      vers = vers + parsed.intValue();
+      return (parts[0] * 100 + parts[1]) * 100;
     }
-
-    return vers;
+    if (versionParts == 1) {
+      if (parts[0] >= 10) {
+        return parts[0] * 100 * 100;
+      }
+    }
+    return 0; /* unknown */
   }
 
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/SetupQueryRunner.java b/pgjdbc/src/main/java/org/postgresql/core/SetupQueryRunner.java
index 63488323c4..584b04fc7a 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/SetupQueryRunner.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/SetupQueryRunner.java
@@ -23,13 +23,9 @@
  */
 public class SetupQueryRunner {
 
-  private static class SimpleResultHandler implements ResultHandler {
-    private SQLException error;
+  private static class SimpleResultHandler extends ResultHandlerBase {
     private List<byte[][]> tuples;
 
-    SimpleResultHandler() {
-    }
-
     List<byte[][]> getResults() {
       return tuples;
     }
@@ -39,36 +35,19 @@ public void handleResultRows(Query fromQuery, Field[] fields, List<byte[][]> tup
       this.tuples = tuples;
     }
 
-    public void handleCommandStatus(String status, int updateCount, long insertOID) {
-    }
-
     public void handleWarning(SQLWarning warning) {
       // We ignore warnings. We assume we know what we're
       // doing in the setup queries.
     }
-
-    public void handleError(SQLException newError) {
-      if (error == null) {
-        error = newError;
-      } else {
-        error.setNextException(newError);
-      }
-    }
-
-    public void handleCompletion() throws SQLException {
-      if (error != null) {
-        throw error;
-      }
-    }
   }
 
-  public static byte[][] run(ProtocolConnection protoConnection, String queryString,
+  public static byte[][] run(QueryExecutor executor, String queryString,
       boolean wantResults) throws SQLException {
-    QueryExecutor executor = protoConnection.getQueryExecutor();
-    Query query = executor.createSimpleQuery(queryString, false);
+    Query query = executor.createSimpleQuery(queryString);
     SimpleResultHandler handler = new SimpleResultHandler();
 
-    int flags = QueryExecutor.QUERY_ONESHOT | QueryExecutor.QUERY_SUPPRESS_BEGIN;
+    int flags = QueryExecutor.QUERY_ONESHOT | QueryExecutor.QUERY_SUPPRESS_BEGIN
+        | QueryExecutor.QUERY_EXECUTE_AS_SIMPLE;
     if (!wantResults) {
       flags |= QueryExecutor.QUERY_NO_RESULTS | QueryExecutor.QUERY_NO_METADATA;
     }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v2/SocketFactoryFactory.java b/pgjdbc/src/main/java/org/postgresql/core/SocketFactoryFactory.java
similarity index 97%
rename from pgjdbc/src/main/java/org/postgresql/core/v2/SocketFactoryFactory.java
rename to pgjdbc/src/main/java/org/postgresql/core/SocketFactoryFactory.java
index 01a3ecfd78..c867c78519 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v2/SocketFactoryFactory.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/SocketFactoryFactory.java
@@ -1,4 +1,4 @@
-package org.postgresql.core.v2;
+package org.postgresql.core;
 
 import org.postgresql.PGProperty;
 import org.postgresql.util.GT;
diff --git a/pgjdbc/src/main/java/org/postgresql/core/SqlCommand.java b/pgjdbc/src/main/java/org/postgresql/core/SqlCommand.java
index bf1d3b7f8a..59ac4b08a7 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/SqlCommand.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/SqlCommand.java
@@ -18,6 +18,7 @@
  *
  */
 public class SqlCommand {
+  public static final SqlCommand BLANK = SqlCommand.createStatementTypeInfo(SqlCommandType.BLANK);
 
   public boolean isBatchedReWriteCompatible() {
     return valuesBraceOpenPosition >= 0;
diff --git a/pgjdbc/src/main/java/org/postgresql/core/SqlCommandType.java b/pgjdbc/src/main/java/org/postgresql/core/SqlCommandType.java
index e45b6aa506..0cbb6a6ca7 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/SqlCommandType.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/SqlCommandType.java
@@ -16,27 +16,15 @@
 
 public enum SqlCommandType {
 
-  INSERT(true),
   /**
    * Use BLANK for empty sql queries or when parsing the sql string is not
    * necessary.
    */
-  BLANK(false),
-  MOVE(false),
-  UPDATE(false),
-  DELETE(false);
-
-  /* to be added when needed SELECT(false), DELETE(false), UPDATE(false),
-  * COMMIT(false), ROLLBACK(false); */
-
-  public boolean canSupportBatchedReWrite() {
-    return canSupportBatchedReWrite;
-  }
-
-  private final boolean canSupportBatchedReWrite;
-
-  private SqlCommandType(boolean reWriteSupport) {
-    canSupportBatchedReWrite = reWriteSupport;
-  }
-
+  BLANK,
+  INSERT,
+  UPDATE,
+  DELETE,
+  MOVE,
+  SELECT,
+  WITH;
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/TransactionState.java b/pgjdbc/src/main/java/org/postgresql/core/TransactionState.java
new file mode 100644
index 0000000000..41095b42db
--- /dev/null
+++ b/pgjdbc/src/main/java/org/postgresql/core/TransactionState.java
@@ -0,0 +1,7 @@
+package org.postgresql.core;
+
+public enum TransactionState {
+  IDLE,
+  OPEN,
+  FAILED
+}
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v2/ConnectionFactoryImpl.java b/pgjdbc/src/main/java/org/postgresql/core/v2/ConnectionFactoryImpl.java
deleted file mode 100644
index edf4a52993..0000000000
--- a/pgjdbc/src/main/java/org/postgresql/core/v2/ConnectionFactoryImpl.java
+++ /dev/null
@@ -1,558 +0,0 @@
-/*-------------------------------------------------------------------------
-*
-* Copyright (c) 2003-2014, PostgreSQL Global Development Group
-* Copyright (c) 2004, Open Cloud Limited.
-*
-*
-*-------------------------------------------------------------------------
-*/
-
-package org.postgresql.core.v2;
-
-import org.postgresql.PGProperty;
-import org.postgresql.core.ConnectionFactory;
-import org.postgresql.core.Encoding;
-import org.postgresql.core.Logger;
-import org.postgresql.core.PGStream;
-import org.postgresql.core.ProtocolConnection;
-import org.postgresql.core.SetupQueryRunner;
-import org.postgresql.core.Utils;
-import org.postgresql.hostchooser.GlobalHostStatusTracker;
-import org.postgresql.hostchooser.HostChooser;
-import org.postgresql.hostchooser.HostChooserFactory;
-import org.postgresql.hostchooser.HostRequirement;
-import org.postgresql.hostchooser.HostStatus;
-import org.postgresql.util.GT;
-import org.postgresql.util.HostSpec;
-import org.postgresql.util.MD5Digest;
-import org.postgresql.util.PSQLException;
-import org.postgresql.util.PSQLState;
-import org.postgresql.util.UnixCrypt;
-
-import java.io.IOException;
-import java.net.ConnectException;
-import java.sql.SQLException;
-import java.sql.SQLWarning;
-import java.util.Iterator;
-import java.util.Properties;
-import java.util.StringTokenizer;
-
-import javax.net.SocketFactory;
-
-/**
- * ConnectionFactory implementation for version 2 (pre-7.4) connections.
- *
- * @author Oliver Jowett (oliver@opencloud.com), based on the previous implementation
- */
-public class ConnectionFactoryImpl extends ConnectionFactory {
-  private static final int AUTH_REQ_OK = 0;
-  private static final int AUTH_REQ_KRB4 = 1;
-  private static final int AUTH_REQ_KRB5 = 2;
-  private static final int AUTH_REQ_PASSWORD = 3;
-  private static final int AUTH_REQ_CRYPT = 4;
-  private static final int AUTH_REQ_MD5 = 5;
-  private static final int AUTH_REQ_SCM = 6;
-
-  public ProtocolConnection openConnectionImpl(HostSpec[] hostSpecs, String user, String database,
-      Properties info, Logger logger) throws SQLException {
-    // Extract interesting values from the info properties:
-    // - the SSL setting
-    boolean requireSSL;
-    boolean trySSL;
-    String sslmode = PGProperty.SSL_MODE.get(info);
-    if (sslmode == null) { // Fall back to the ssl property
-      // assume "true" if the property is set but empty
-      requireSSL = trySSL = PGProperty.SSL.getBoolean(info) || "".equals(PGProperty.SSL.get(info));
-    } else {
-      if ("disable".equals(sslmode)) {
-        requireSSL = trySSL = false;
-      } else if ("require".equals(sslmode) || "verify-ca".equals(sslmode)
-          || "verify-full".equals(sslmode)) {
-        requireSSL = trySSL = true;
-      } else {
-        throw new PSQLException(GT.tr("Invalid sslmode value: {0}", sslmode),
-            PSQLState.CONNECTION_UNABLE_TO_CONNECT);
-      }
-    }
-
-    // - the TCP keep alive setting
-    boolean requireTCPKeepAlive = PGProperty.TCP_KEEP_ALIVE.getBoolean(info);
-
-    // - the targetServerType setting
-    HostRequirement targetServerType;
-    try {
-      targetServerType =
-          HostRequirement.valueOf(info.getProperty("targetServerType", HostRequirement.any.name()));
-    } catch (IllegalArgumentException ex) {
-      throw new PSQLException(
-          GT.tr("Invalid targetServerType value: {0}", info.getProperty("targetServerType")),
-          PSQLState.CONNECTION_UNABLE_TO_CONNECT);
-    }
-
-    // Socket factory
-    SocketFactory socketFactory = SocketFactoryFactory.getSocketFactory(info);
-
-    HostChooser hostChooser =
-        HostChooserFactory.createHostChooser(hostSpecs, targetServerType, info);
-    Iterator<HostSpec> hostIter = hostChooser.iterator();
-    while (hostIter.hasNext()) {
-      HostSpec hostSpec = hostIter.next();
-
-      if (logger.logDebug()) {
-        logger.debug("Trying to establish a protocol version 2 connection to " + hostSpec);
-      }
-
-      //
-      // Establish a connection.
-      //
-      int connectTimeout = PGProperty.CONNECT_TIMEOUT.getInt(info) * 1000;
-
-      PGStream newStream = null;
-      try {
-        newStream = new PGStream(socketFactory, hostSpec, connectTimeout);
-
-        // Construct and send an ssl startup packet if requested.
-        if (trySSL) {
-          newStream = enableSSL(newStream, requireSSL, info, logger, connectTimeout);
-        }
-
-
-        // Set the socket timeout if the "socketTimeout" property has been set.
-        int socketTimeout = PGProperty.SOCKET_TIMEOUT.getInt(info);
-        if (socketTimeout > 0) {
-          newStream.getSocket().setSoTimeout(socketTimeout * 1000);
-        }
-
-        // Enable TCP keep-alive probe if required.
-        newStream.getSocket().setKeepAlive(requireTCPKeepAlive);
-
-        // Construct and send a startup packet.
-        sendStartupPacket(newStream, user, database, logger);
-
-        // Do authentication (until AuthenticationOk).
-        doAuthentication(newStream, user, PGProperty.PASSWORD.get(info), logger);
-
-        int cancelSignalTimeout = PGProperty.CANCEL_SIGNAL_TIMEOUT.getInt(info) * 1000;
-
-        // Do final startup.
-        ProtocolConnectionImpl protoConnection =
-            new ProtocolConnectionImpl(newStream, user, database, logger,
-                cancelSignalTimeout);
-        readStartupMessages(newStream, protoConnection, logger);
-
-        // Check Master or Slave
-        HostStatus hostStatus = HostStatus.ConnectOK;
-        if (targetServerType != HostRequirement.any) {
-          hostStatus = isMaster(protoConnection, logger) ? HostStatus.Master : HostStatus.Slave;
-        }
-        GlobalHostStatusTracker.reportHostStatus(hostSpec, hostStatus);
-        if (!targetServerType.allowConnectingTo(hostStatus)) {
-          protoConnection.close();
-          if (hostIter.hasNext()) {
-            // still more addresses to try
-            continue;
-          }
-          throw new PSQLException(GT
-              .tr("Could not find a server with specified targetServerType: {0}", targetServerType),
-              PSQLState.CONNECTION_UNABLE_TO_CONNECT);
-        }
-
-        // Run some initial queries
-        runInitialQueries(protoConnection, info, logger);
-
-        // And we're done.
-        return protoConnection;
-      } catch (ConnectException cex) {
-        // Added by Peter Mount <peter@retep.org.uk>
-        // ConnectException is thrown when the connection cannot be made.
-        // we trap this an return a more meaningful message for the end user
-        GlobalHostStatusTracker.reportHostStatus(hostSpec, HostStatus.ConnectFail);
-        if (hostIter.hasNext()) {
-          // still more addresses to try
-          continue;
-        }
-        throw new PSQLException(
-            GT.tr(
-                "Connection refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections."),
-            PSQLState.CONNECTION_UNABLE_TO_CONNECT, cex);
-      } catch (IOException ioe) {
-        closeStream(newStream);
-        GlobalHostStatusTracker.reportHostStatus(hostSpec, HostStatus.ConnectFail);
-        if (hostIter.hasNext()) {
-          // still more addresses to try
-          continue;
-        }
-        throw new PSQLException(GT.tr("The connection attempt failed."),
-            PSQLState.CONNECTION_UNABLE_TO_CONNECT, ioe);
-      } catch (SQLException se) {
-        closeStream(newStream);
-        if (hostIter.hasNext()) {
-          // still more addresses to try
-          continue;
-        }
-        throw se;
-      }
-    }
-    throw new PSQLException(GT.tr("The connection url is invalid."),
-        PSQLState.CONNECTION_UNABLE_TO_CONNECT);
-  }
-
-  private PGStream enableSSL(PGStream pgStream, boolean requireSSL, Properties info, Logger logger,
-      int connectTimeout) throws IOException, SQLException {
-    if (logger.logDebug()) {
-      logger.debug(" FE=> SSLRequest");
-    }
-
-    // Send SSL request packet
-    pgStream.SendInteger4(8);
-    pgStream.SendInteger2(1234);
-    pgStream.SendInteger2(5679);
-    pgStream.flush();
-
-    // Now get the response from the backend, one of N, E, S.
-    int beresp = pgStream.ReceiveChar();
-    switch (beresp) {
-      case 'E':
-        if (logger.logDebug()) {
-          logger.debug(" <=BE SSLError");
-        }
-
-        // Server doesn't even know about the SSL handshake protocol
-        if (requireSSL) {
-          throw new PSQLException(GT.tr("The server does not support SSL."),
-              PSQLState.CONNECTION_REJECTED);
-        }
-
-        // We have to reconnect to continue.
-        pgStream.close();
-        return new PGStream(pgStream.getSocketFactory(), pgStream.getHostSpec(), connectTimeout);
-
-      case 'N':
-        if (logger.logDebug()) {
-          logger.debug(" <=BE SSLRefused");
-        }
-
-        // Server does not support ssl
-        if (requireSSL) {
-          throw new PSQLException(GT.tr("The server does not support SSL."),
-              PSQLState.CONNECTION_REJECTED);
-        }
-
-        return pgStream;
-
-      case 'S':
-        if (logger.logDebug()) {
-          logger.debug(" <=BE SSLOk");
-        }
-
-        // Server supports ssl
-        org.postgresql.ssl.MakeSSL.convert(pgStream, info, logger);
-        return pgStream;
-
-      default:
-        throw new PSQLException(GT.tr("An error occurred while setting up the SSL connection."),
-            PSQLState.PROTOCOL_VIOLATION);
-    }
-  }
-
-  private void sendStartupPacket(PGStream pgStream, String user, String database, Logger logger)
-      throws IOException {
-    // 4: total size including self
-    // 2: protocol major
-    // 2: protocol minor
-    // 64: database name
-    // 32: user name
-    // 64: options
-    // 64: unused
-    // 64: tty
-
-    if (logger.logDebug()) {
-      logger.debug(" FE=> StartupPacket(user=" + user + ",database=" + database + ")");
-    }
-
-    pgStream.SendInteger4(4 + 4 + 64 + 32 + 64 + 64 + 64);
-    pgStream.SendInteger2(2); // protocol major
-    pgStream.SendInteger2(0); // protocol minor
-    pgStream.Send(database.getBytes("UTF-8"), 64);
-    pgStream.Send(user.getBytes("UTF-8"), 32);
-    pgStream.Send(new byte[64]); // options
-    pgStream.Send(new byte[64]); // unused
-    pgStream.Send(new byte[64]); // tty
-    pgStream.flush();
-  }
-
-  private void doAuthentication(PGStream pgStream, String user, String password, Logger logger)
-      throws IOException, SQLException {
-    // Now get the response from the backend, either an error message
-    // or an authentication request
-
-    while (true) {
-      int beresp = pgStream.ReceiveChar();
-
-      switch (beresp) {
-        case 'E':
-          // An error occurred, so pass the error message to the
-          // user.
-          //
-          // The most common one to be thrown here is:
-          // "User authentication failed"
-          //
-          String errorMsg = pgStream.ReceiveString();
-          if (logger.logDebug()) {
-            logger.debug(" <=BE ErrorMessage(" + errorMsg + ")");
-          }
-          throw new PSQLException(GT.tr("Connection rejected: {0}.", errorMsg),
-              PSQLState.CONNECTION_REJECTED);
-
-        case 'R':
-          // Authentication request.
-          // Get the type of request
-          int areq = pgStream.ReceiveInteger4();
-
-          // Process the request.
-          switch (areq) {
-            case AUTH_REQ_CRYPT: {
-              byte salt[] = pgStream.Receive(2);
-
-              if (logger.logDebug()) {
-                logger.debug(
-                    " <=BE AuthenticationReqCrypt(salt='" + new String(salt, "US-ASCII") + "')");
-              }
-
-              if (password == null) {
-                throw new PSQLException(
-                    GT.tr(
-                        "The server requested password-based authentication, but no password was provided."),
-                    PSQLState.CONNECTION_REJECTED);
-              }
-
-              byte[] encodedResult = UnixCrypt.crypt(salt, password.getBytes("UTF-8"));
-
-              if (logger.logDebug()) {
-                logger
-                    .debug(" FE=> Password(crypt='" + new String(encodedResult, "US-ASCII") + "')");
-              }
-
-              pgStream.SendInteger4(4 + encodedResult.length + 1);
-              pgStream.Send(encodedResult);
-              pgStream.SendChar(0);
-              pgStream.flush();
-
-              break;
-            }
-
-            case AUTH_REQ_MD5: {
-              byte[] md5Salt = pgStream.Receive(4);
-              if (logger.logDebug()) {
-                logger.debug(" <=BE AuthenticationReqMD5(salt=" + Utils.toHexString(md5Salt) + ")");
-              }
-
-              if (password == null) {
-                throw new PSQLException(
-                    GT.tr(
-                        "The server requested password-based authentication, but no password was provided."),
-                    PSQLState.CONNECTION_REJECTED);
-              }
-
-              byte[] digest =
-                  MD5Digest.encode(user.getBytes("UTF-8"), password.getBytes("UTF-8"), md5Salt);
-              if (logger.logDebug()) {
-                logger.debug(" FE=> Password(md5digest=" + new String(digest, "US-ASCII") + ")");
-              }
-
-              pgStream.SendInteger4(4 + digest.length + 1);
-              pgStream.Send(digest);
-              pgStream.SendChar(0);
-              pgStream.flush();
-
-              break;
-            }
-
-            case AUTH_REQ_PASSWORD: {
-              if (logger.logDebug()) {
-                logger.debug(" <=BE AuthenticationReqPassword");
-              }
-
-              if (password == null) {
-                throw new PSQLException(
-                    GT.tr(
-                        "The server requested password-based authentication, but no password was provided."),
-                    PSQLState.CONNECTION_REJECTED);
-              }
-
-              if (logger.logDebug()) {
-                logger.debug(" FE=> Password(password=<not shown>)");
-              }
-
-              byte[] encodedPassword = password.getBytes("UTF-8");
-              pgStream.SendInteger4(4 + encodedPassword.length + 1);
-              pgStream.Send(encodedPassword);
-              pgStream.SendChar(0);
-              pgStream.flush();
-
-              break;
-            }
-
-            case AUTH_REQ_OK:
-              if (logger.logDebug()) {
-                logger.debug(" <=BE AuthenticationOk");
-              }
-
-              return; // We're done.
-
-            default:
-              if (logger.logDebug()) {
-                logger.debug(" <=BE AuthenticationReq (unsupported type " + (areq) + ")");
-              }
-
-              throw new PSQLException(GT.tr(
-                  "The authentication type {0} is not supported. Check that you have configured the pg_hba.conf file to include the client''s IP address or subnet, and that it is using an authentication scheme supported by the driver.",
-                  areq), PSQLState.CONNECTION_REJECTED);
-          }
-
-          break;
-
-        default:
-          throw new PSQLException(GT.tr("Protocol error.  Session setup failed."),
-              PSQLState.PROTOCOL_VIOLATION);
-      }
-    }
-  }
-
-  private void readStartupMessages(PGStream pgStream, ProtocolConnectionImpl protoConnection,
-      Logger logger) throws IOException, SQLException {
-    while (true) {
-      int beresp = pgStream.ReceiveChar();
-      switch (beresp) {
-        case 'Z': // ReadyForQuery
-          if (logger.logDebug()) {
-            logger.debug(" <=BE ReadyForQuery");
-          }
-          return;
-
-        case 'K': // BackendKeyData
-          int pid = pgStream.ReceiveInteger4();
-          int ckey = pgStream.ReceiveInteger4();
-          if (logger.logDebug()) {
-            logger.debug(" <=BE BackendKeyData(pid=" + pid + ",ckey=" + ckey + ")");
-          }
-          protoConnection.setBackendKeyData(pid, ckey);
-          break;
-
-        case 'E': // ErrorResponse
-          String errorMsg = pgStream.ReceiveString();
-          if (logger.logDebug()) {
-            logger.debug(" <=BE ErrorResponse(" + errorMsg + ")");
-          }
-          throw new PSQLException(GT.tr("Backend start-up failed: {0}.", errorMsg),
-              PSQLState.CONNECTION_UNABLE_TO_CONNECT);
-
-        case 'N': // NoticeResponse
-          String warnMsg = pgStream.ReceiveString();
-          if (logger.logDebug()) {
-            logger.debug(" <=BE NoticeResponse(" + warnMsg + ")");
-          }
-          protoConnection.addWarning(new SQLWarning(warnMsg));
-          break;
-
-        default:
-          throw new PSQLException(GT.tr("Protocol error.  Session setup failed."),
-              PSQLState.PROTOCOL_VIOLATION);
-      }
-    }
-  }
-
-  private void runInitialQueries(ProtocolConnectionImpl protoConnection, Properties info,
-      Logger logger) throws SQLException, IOException {
-    byte[][] results = SetupQueryRunner.run(protoConnection,
-        "set datestyle = 'ISO'; select version(), case when pg_encoding_to_char(1) = 'SQL_ASCII' then 'UNKNOWN' else getdatabaseencoding() end",
-        true);
-
-    String rawDbVersion = protoConnection.getEncoding().decode(results[0]);
-    StringTokenizer versionParts = new StringTokenizer(rawDbVersion);
-    versionParts.nextToken(); /* "PostgreSQL" */
-    String dbVersion = versionParts.nextToken(); /* "X.Y.Z" */
-
-    protoConnection.setServerVersion(dbVersion);
-
-    if (dbVersion.compareTo("7.3") >= 0) {
-      // set encoding to be unicode; set datestyle; ensure autocommit is on
-      // (no-op on 7.4, but might be needed under 7.3)
-      // The begin/commit is to avoid leaving a transaction open if we're talking to a
-      // 7.3 server that defaults to autocommit = off.
-
-      if (logger.logDebug()) {
-        logger.debug("Switching to UTF8 client_encoding");
-      }
-
-      String sql = "begin; set autocommit = on; set client_encoding = 'UTF8'; ";
-      if (dbVersion.compareTo("9.0") >= 0) {
-        sql += "SET extra_float_digits=3; ";
-      } else if (dbVersion.compareTo("7.4") >= 0) {
-        sql += "SET extra_float_digits=2; ";
-      }
-      sql += "commit";
-
-      SetupQueryRunner.run(protoConnection, sql, false);
-      protoConnection.setEncoding(Encoding.getDatabaseEncoding("UTF8"));
-    } else {
-      String charSet = PGProperty.CHARSET.get(info);
-      String dbEncoding =
-          (results[1] == null ? null : protoConnection.getEncoding().decode(results[1]));
-      if (logger.logDebug()) {
-        logger.debug("Specified charset:  " + charSet);
-        logger.debug("Database encoding: " + dbEncoding);
-      }
-
-      if (charSet != null) {
-        // Explicitly specified encoding.
-        protoConnection.setEncoding(Encoding.getJVMEncoding(charSet));
-      } else if (dbEncoding != null) {
-        // Use database-supplied encoding.
-        protoConnection.setEncoding(Encoding.getDatabaseEncoding(dbEncoding));
-      } else {
-        // Fall back to defaults.
-        // XXX is this ever reached?
-        protoConnection.setEncoding(Encoding.defaultEncoding());
-      }
-    }
-
-    if (logger.logDebug()) {
-      logger.debug(
-          "Connection encoding (using JVM's nomenclature): " + protoConnection.getEncoding());
-    }
-
-    if (dbVersion.compareTo("8.1") >= 0) {
-      // Server versions since 8.1 report standard_conforming_strings
-      results = SetupQueryRunner.run(protoConnection,
-          "select current_setting('standard_conforming_strings')", true);
-      String value = protoConnection.getEncoding().decode(results[0]);
-      protoConnection.setStandardConformingStrings(value.equalsIgnoreCase("on"));
-    } else {
-      protoConnection.setStandardConformingStrings(false);
-    }
-
-    String appName = PGProperty.APPLICATION_NAME.get(info);
-    if (appName != null && dbVersion.compareTo("9.0") >= 0) {
-      StringBuilder sb = new StringBuilder("SET application_name = '");
-      Utils.escapeLiteral(sb, appName, protoConnection.getStandardConformingStrings());
-      sb.append("'");
-      SetupQueryRunner.run(protoConnection, sb.toString(), false);
-    }
-
-    String currentSchema = PGProperty.CURRENT_SCHEMA.get(info);
-    if (currentSchema != null) {
-      StringBuilder sb = new StringBuilder("SET search_path = '");
-      Utils.escapeLiteral(sb, appName, protoConnection.getStandardConformingStrings());
-      sb.append("'");
-      SetupQueryRunner.run(protoConnection, sb.toString(), false);
-    }
-  }
-
-  private boolean isMaster(ProtocolConnectionImpl protoConnection, Logger logger)
-      throws SQLException, IOException {
-    byte[][] results = SetupQueryRunner.run(protoConnection, "show transaction_read_only", true);
-    String value = protoConnection.getEncoding().decode(results[0]);
-    return value.equalsIgnoreCase("off");
-  }
-}
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v2/FastpathParameterList.java b/pgjdbc/src/main/java/org/postgresql/core/v2/FastpathParameterList.java
deleted file mode 100644
index cc1a9e6987..0000000000
--- a/pgjdbc/src/main/java/org/postgresql/core/v2/FastpathParameterList.java
+++ /dev/null
@@ -1,203 +0,0 @@
-/*-------------------------------------------------------------------------
-*
-* Copyright (c) 2004-2014, PostgreSQL Global Development Group
-* Copyright (c) 2004, Open Cloud Limited.
-*
-*
-*-------------------------------------------------------------------------
-*/
-
-package org.postgresql.core.v2;
-
-import org.postgresql.core.PGStream;
-import org.postgresql.core.ParameterList;
-import org.postgresql.util.GT;
-import org.postgresql.util.PSQLException;
-import org.postgresql.util.PSQLState;
-import org.postgresql.util.StreamWrapper;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.sql.SQLException;
-import java.util.Arrays;
-
-/**
- * Implementation of fastpath parameter lists for the V2 protocol. The V2 protocol expects different
- * representations of parameters in queries to that used in fastpath calls, so we do a separate
- * implementation which supports only what fastpath needs here.
- *
- * @author Oliver Jowett (oliver@opencloud.com)
- */
-class FastpathParameterList implements ParameterList {
-  FastpathParameterList(int paramCount) {
-    this.paramValues = new Object[paramCount];
-  }
-
-  public void registerOutParameter(int index, int sqlType) {
-  }
-
-  public void registerOutParameter(int index, int sqlType, int precision) {
-  }
-
-  ;
-
-  public int getInParameterCount() {
-    return paramValues.length;
-  }
-
-  public int getOutParameterCount() {
-    return 0;
-  }
-
-  public int getParameterCount() {
-    return paramValues.length;
-  }
-
-  public int[] getTypeOIDs() {
-    return null;
-  }
-
-  public void setIntParameter(int index, int value) throws SQLException {
-    if (index < 1 || index > paramValues.length) {
-      throw new PSQLException(
-          GT.tr("The column index is out of range: {0}, number of columns: {1}.",
-              new Object[]{index, paramValues.length}),
-          PSQLState.INVALID_PARAMETER_VALUE);
-    }
-
-    byte[] data = new byte[4];
-    data[3] = (byte) value;
-    data[2] = (byte) (value >> 8);
-    data[1] = (byte) (value >> 16);
-    data[0] = (byte) (value >> 24);
-
-    paramValues[index - 1] = data;
-  }
-
-  public void setLiteralParameter(int index, String value, int oid) throws SQLException {
-    // Not enough type info here for the V2 path (which requires binary reprs)
-    throw new IllegalArgumentException("can't setLiteralParameter() on a fastpath parameter");
-  }
-
-  public void setStringParameter(int index, String value, int oid) throws SQLException {
-    paramValues[index - 1] = value;
-  }
-
-  public void setBytea(int index, byte[] data, int offset, int length) throws SQLException {
-    if (index < 1 || index > paramValues.length) {
-      throw new PSQLException(
-          GT.tr("The column index is out of range: {0}, number of columns: {1}.",
-              new Object[]{index, paramValues.length}),
-          PSQLState.INVALID_PARAMETER_VALUE);
-    }
-
-    paramValues[index - 1] = new StreamWrapper(data, offset, length);
-  }
-
-  public void setBytea(int index, final InputStream stream, final int length) throws SQLException {
-    if (index < 1 || index > paramValues.length) {
-      throw new PSQLException(
-          GT.tr("The column index is out of range: {0}, number of columns: {1}.",
-              new Object[]{index, paramValues.length}),
-          PSQLState.INVALID_PARAMETER_VALUE);
-    }
-
-    paramValues[index - 1] = new StreamWrapper(stream, length);
-  }
-
-  public void setBytea(int index, InputStream stream) throws SQLException {
-    if (index < 1 || index > paramValues.length) {
-      throw new PSQLException(
-          GT.tr("The column index is out of range: {0}, number of columns: {1}.",
-              new Object[]{index, paramValues.length}),
-          PSQLState.INVALID_PARAMETER_VALUE);
-    }
-
-    paramValues[index - 1] = new StreamWrapper(stream);
-  }
-
-  public void setNull(int index, int oid) throws SQLException {
-    throw new IllegalArgumentException("can't setNull() on a v2 fastpath parameter");
-  }
-
-  public String toString(int index) {
-    if (index < 1 || index > paramValues.length) {
-      throw new IllegalArgumentException("parameter " + index + " out of range");
-    }
-
-    return "<fastpath parameter>";
-  }
-
-  private void copyStream(PGStream pgStream, StreamWrapper wrapper) throws IOException {
-    byte[] rawData = wrapper.getBytes();
-    if (rawData != null) {
-      pgStream.Send(rawData, wrapper.getOffset(), wrapper.getLength());
-      return;
-    }
-
-    pgStream.SendStream(wrapper.getStream(), wrapper.getLength());
-  }
-
-  void writeV2FastpathValue(int index, PGStream pgStream) throws IOException {
-    --index;
-
-    if (paramValues[index] instanceof StreamWrapper) {
-      StreamWrapper wrapper = (StreamWrapper) paramValues[index];
-      pgStream.SendInteger4(wrapper.getLength());
-      copyStream(pgStream, wrapper);
-    } else if (paramValues[index] instanceof byte[]) {
-      byte[] data = (byte[]) paramValues[index];
-      pgStream.SendInteger4(data.length);
-      pgStream.Send(data);
-    } else if (paramValues[index] instanceof String) {
-      byte[] data = pgStream.getEncoding().encode((String) paramValues[index]);
-      pgStream.SendInteger4(data.length);
-      pgStream.Send(data);
-    } else {
-      throw new IllegalArgumentException("don't know how to stream parameter " + index);
-    }
-  }
-
-  void checkAllParametersSet() throws SQLException {
-    for (int i = 0; i < paramValues.length; i++) {
-      if (paramValues[i] == null) {
-        throw new PSQLException(GT.tr("No value specified for parameter {0}.", i + 1),
-            PSQLState.INVALID_PARAMETER_VALUE);
-      }
-    }
-  }
-
-  public ParameterList copy() {
-    FastpathParameterList newCopy = new FastpathParameterList(paramValues.length);
-    System.arraycopy(paramValues, 0, newCopy.paramValues, 0, paramValues.length);
-    return newCopy;
-  }
-
-  public void clear() {
-    Arrays.fill(paramValues, null);
-  }
-
-  public void setBinaryParameter(int index, byte[] value, int oid) {
-    throw new UnsupportedOperationException();
-  }
-
-  private final Object[] paramValues;
-
-  public Object[] getValues() {
-    return this.paramValues;
-  }
-
-  /**
-   * Append parameters to the list.
-   */
-  public void appendAll(ParameterList list) throws SQLException {
-    if (list instanceof SimpleParameterList ) {
-      // only v2.SimpleParameterList is compatible with this type
-      SimpleParameterList spl = (SimpleParameterList) list;
-      int count = spl.getInParameterCount();
-      System.arraycopy(spl.getValues(), 0, paramValues,
-          getInParameterCount() - count, count);
-    }
-  }
-}
-
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v2/ProtocolConnectionImpl.java b/pgjdbc/src/main/java/org/postgresql/core/v2/ProtocolConnectionImpl.java
deleted file mode 100644
index de15e7f68d..0000000000
--- a/pgjdbc/src/main/java/org/postgresql/core/v2/ProtocolConnectionImpl.java
+++ /dev/null
@@ -1,262 +0,0 @@
-/*-------------------------------------------------------------------------
-*
-* Copyright (c) 2004-2014, PostgreSQL Global Development Group
-* Copyright (c) 2004, Open Cloud Limited.
-*
-*
-*-------------------------------------------------------------------------
-*/
-
-package org.postgresql.core.v2;
-
-import org.postgresql.PGNotification;
-import org.postgresql.core.Encoding;
-import org.postgresql.core.Logger;
-import org.postgresql.core.PGStream;
-import org.postgresql.core.ProtocolConnection;
-import org.postgresql.core.QueryExecutor;
-import org.postgresql.core.Utils;
-import org.postgresql.util.HostSpec;
-
-import java.io.IOException;
-import java.sql.SQLException;
-import java.sql.SQLWarning;
-import java.util.ArrayList;
-import java.util.Set;
-import java.util.TimeZone;
-
-/**
- * V2 implementation of ProtocolConnection.
- *
- * @author Oliver Jowett (oliver@opencloud.com)
- */
-class ProtocolConnectionImpl implements ProtocolConnection {
-  ProtocolConnectionImpl(PGStream pgStream, String user, String database, Logger logger,
-      int cancelSignalTimeout) {
-    this.pgStream = pgStream;
-    this.user = user;
-    this.database = database;
-    this.logger = logger;
-    this.executor = new QueryExecutorImpl(this, pgStream, logger);
-    this.cancelSignalTimeout = cancelSignalTimeout;
-  }
-
-  public HostSpec getHostSpec() {
-    return pgStream.getHostSpec();
-  }
-
-  public String getUser() {
-    return user;
-  }
-
-  public String getDatabase() {
-    return database;
-  }
-
-  public String getServerVersion() {
-    return serverVersion;
-  }
-
-  public int getServerVersionNum() {
-    if (serverVersionNum != 0) {
-      return serverVersionNum;
-    }
-    return Utils.parseServerVersionStr(serverVersion);
-  }
-
-  public synchronized boolean getStandardConformingStrings() {
-    return standardConformingStrings;
-  }
-
-  public synchronized int getTransactionState() {
-    return transactionState;
-  }
-
-  public synchronized PGNotification[] getNotifications() throws SQLException {
-    PGNotification[] array = notifications.toArray(new PGNotification[notifications.size()]);
-    notifications.clear();
-    return array;
-  }
-
-  public synchronized SQLWarning getWarnings() {
-    SQLWarning chain = warnings;
-    warnings = null;
-    return chain;
-  }
-
-  public QueryExecutor getQueryExecutor() {
-    return executor;
-  }
-
-  public void sendQueryCancel() throws SQLException {
-    if (cancelPid <= 0) {
-      return;
-    }
-
-    PGStream cancelStream = null;
-
-    // Now we need to construct and send a cancel packet
-    try {
-      if (logger.logDebug()) {
-        logger.debug(" FE=> CancelRequest(pid=" + cancelPid + ",ckey=" + cancelKey + ")");
-      }
-
-      cancelStream =
-          new PGStream(pgStream.getSocketFactory(), pgStream.getHostSpec(), cancelSignalTimeout);
-      if (cancelSignalTimeout > 0) {
-        cancelStream.getSocket().setSoTimeout(cancelSignalTimeout);
-      }
-      cancelStream.SendInteger4(16);
-      cancelStream.SendInteger2(1234);
-      cancelStream.SendInteger2(5678);
-      cancelStream.SendInteger4(cancelPid);
-      cancelStream.SendInteger4(cancelKey);
-      cancelStream.flush();
-      cancelStream.ReceiveEOF();
-    } catch (IOException e) {
-      // Safe to ignore.
-      if (logger.logDebug()) {
-        logger.debug("Ignoring exception on cancel request:", e);
-      }
-    } finally {
-      if (cancelStream != null) {
-        try {
-          cancelStream.close();
-        } catch (IOException e) {
-          // Ignored.
-        }
-      }
-    }
-  }
-
-  public void close() {
-    if (closed) {
-      return;
-    }
-
-    try {
-      if (logger.logDebug()) {
-        logger.debug(" FE=> Terminate");
-      }
-      pgStream.SendChar('X');
-      pgStream.flush();
-      pgStream.close();
-    } catch (IOException ioe) {
-      // Forget it.
-      if (logger.logDebug()) {
-        logger.debug("Discarding IOException on close:", ioe);
-      }
-    }
-
-    closed = true;
-  }
-
-  public Encoding getEncoding() {
-    return pgStream.getEncoding();
-  }
-
-  public boolean isClosed() {
-    return closed;
-  }
-
-  //
-  // Package-private accessors called during connection setup
-  //
-
-  void setEncoding(Encoding encoding) throws IOException {
-    pgStream.setEncoding(encoding);
-  }
-
-  void setServerVersion(String serverVersion) {
-    this.serverVersion = serverVersion;
-  }
-
-  void setServerVersionNum(int serverVersionNum) {
-    this.serverVersionNum = serverVersionNum;
-  }
-
-  void setBackendKeyData(int cancelPid, int cancelKey) {
-    this.cancelPid = cancelPid;
-    this.cancelKey = cancelKey;
-  }
-
-  synchronized void setStandardConformingStrings(boolean value) {
-    standardConformingStrings = value;
-  }
-
-  //
-  // Package-private accessors called by the query executor
-  //
-
-  synchronized void addWarning(SQLWarning newWarning) {
-    if (warnings == null) {
-      warnings = newWarning;
-    } else {
-      warnings.setNextWarning(newWarning);
-    }
-  }
-
-  synchronized void addNotification(PGNotification notification) {
-    notifications.add(notification);
-  }
-
-  synchronized void setTransactionState(int state) {
-    transactionState = state;
-  }
-
-  public int getProtocolVersion() {
-    return 2;
-  }
-
-  public void setBinaryReceiveOids(Set<Integer> ignored) {
-    // ignored for v2 connections
-  }
-
-  public boolean getIntegerDateTimes() {
-    // not supported in v2 protocol
-    return false;
-  }
-
-  public int getBackendPID() {
-    return cancelPid;
-  }
-
-  public void abort() {
-    try {
-      pgStream.getSocket().close();
-    } catch (IOException e) {
-      // ignore
-    }
-    closed = true;
-  }
-
-  @Override
-  public TimeZone getTimeZone() {
-    return TimeZone.getDefault();
-  }
-
-  @Override
-  public String getApplicationName() {
-    return "";
-  }
-
-  private String serverVersion;
-  private int serverVersionNum = 0;
-  private int cancelPid;
-  private int cancelKey;
-
-  private boolean standardConformingStrings;
-  private int transactionState;
-  private SQLWarning warnings;
-
-  private boolean closed = false;
-
-  private final ArrayList<PGNotification> notifications = new ArrayList<PGNotification>();
-
-  private final PGStream pgStream;
-  private final String user;
-  private final String database;
-  private final QueryExecutorImpl executor;
-  private final Logger logger;
-  private final int cancelSignalTimeout;
-}
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v2/QueryExecutorImpl.java b/pgjdbc/src/main/java/org/postgresql/core/v2/QueryExecutorImpl.java
deleted file mode 100644
index 5d7c87d5f6..0000000000
--- a/pgjdbc/src/main/java/org/postgresql/core/v2/QueryExecutorImpl.java
+++ /dev/null
@@ -1,659 +0,0 @@
-/*-------------------------------------------------------------------------
-*
-* Copyright (c) 2003-2014, PostgreSQL Global Development Group
-* Copyright (c) 2004, Open Cloud Limited.
-*
-*
-*-------------------------------------------------------------------------
-*/
-
-package org.postgresql.core.v2;
-
-import org.postgresql.copy.CopyOperation;
-import org.postgresql.core.Field;
-import org.postgresql.core.Logger;
-import org.postgresql.core.NativeQuery;
-import org.postgresql.core.PGStream;
-import org.postgresql.core.ParameterList;
-import org.postgresql.core.ProtocolConnection;
-import org.postgresql.core.Query;
-import org.postgresql.core.QueryExecutor;
-import org.postgresql.core.ResultCursor;
-import org.postgresql.core.ResultHandler;
-import org.postgresql.jdbc.BatchResultHandler;
-import org.postgresql.util.GT;
-import org.postgresql.util.PSQLException;
-import org.postgresql.util.PSQLState;
-
-import java.io.IOException;
-import java.io.Writer;
-import java.sql.SQLException;
-import java.sql.SQLWarning;
-import java.sql.Statement;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * QueryExecutor implementation for the V2 protocol.
- */
-public class QueryExecutorImpl implements QueryExecutor {
-  public QueryExecutorImpl(ProtocolConnectionImpl protoConnection, PGStream pgStream,
-      Logger logger) {
-    this.protoConnection = protoConnection;
-    this.pgStream = pgStream;
-    this.logger = logger;
-  }
-
-  //
-  // Query parsing
-  //
-
-  public Query createSimpleQuery(String sql, boolean autocommit) {
-    return new V2Query(sql, false, protoConnection);
-  }
-
-  public Query createParameterizedQuery(String sql, boolean autocommit) {
-    return new V2Query(sql, true, protoConnection);
-  }
-
-  //
-  // Fastpath
-  //
-
-  public ParameterList createFastpathParameters(int count) {
-    return new FastpathParameterList(count);
-  }
-
-  public synchronized byte[] fastpathCall(int fnid, ParameterList parameters, boolean suppressBegin)
-      throws SQLException {
-    if (protoConnection.getTransactionState() == ProtocolConnection.TRANSACTION_IDLE
-        && !suppressBegin) {
-
-      if (logger.logDebug()) {
-        logger.debug("Issuing BEGIN before fastpath call.");
-      }
-
-      ResultHandler handler = new ResultHandler() {
-        private boolean sawBegin = false;
-        private SQLException sqle = null;
-
-        public void handleResultRows(Query fromQuery, Field[] fields, List<byte[][]> tuples,
-            ResultCursor cursor) {
-        }
-
-        public void handleCommandStatus(String status, int updateCount, long insertOID) {
-          if (!sawBegin) {
-            if (!status.equals("BEGIN")) {
-              handleError(
-                  new PSQLException(GT.tr("Expected command status BEGIN, got {0}.", status),
-                      PSQLState.PROTOCOL_VIOLATION));
-            }
-            sawBegin = true;
-          } else {
-            handleError(new PSQLException(GT.tr("Unexpected command status: {0}.", status),
-                PSQLState.PROTOCOL_VIOLATION));
-          }
-        }
-
-        public void handleWarning(SQLWarning warning) {
-          // we don't want to ignore warnings and it would be tricky
-          // to chain them back to the connection, so since we don't
-          // expect to get them in the first place, we just consider
-          // them errors.
-          handleError(warning);
-        }
-
-        public void handleError(SQLException error) {
-          if (sqle == null) {
-            sqle = error;
-          } else {
-            sqle.setNextException(error);
-          }
-        }
-
-        public void handleCompletion() throws SQLException {
-          if (sqle != null) {
-            throw sqle;
-          }
-        }
-      };
-
-      try {
-        // Create and issue a dummy query to use the existing prefix infrastructure
-        V2Query query = (V2Query) createSimpleQuery("", false);
-        SimpleParameterList params = (SimpleParameterList) query.createParameterList();
-        sendQuery(query, params, "BEGIN");
-        processResults(query, handler, 0, 0);
-      } catch (IOException ioe) {
-        throw new PSQLException(GT.tr("An I/O error occurred while sending to the backend."),
-            PSQLState.CONNECTION_FAILURE, ioe);
-      }
-    }
-
-    try {
-      sendFastpathCall(fnid, (FastpathParameterList) parameters);
-      return receiveFastpathResult();
-    } catch (IOException ioe) {
-      throw new PSQLException(GT.tr("An I/O error occurred while sending to the backend."),
-          PSQLState.CONNECTION_FAILURE, ioe);
-    }
-  }
-
-  private void sendFastpathCall(int fnid, FastpathParameterList params) throws IOException {
-    // Send call.
-    int count = params.getParameterCount();
-
-    if (logger.logDebug()) {
-      logger.debug(" FE=> FastpathCall(fnid=" + fnid + ",paramCount=" + count + ")");
-    }
-
-    pgStream.SendChar('F');
-    pgStream.SendChar(0);
-    pgStream.SendInteger4(fnid);
-    pgStream.SendInteger4(count);
-
-    for (int i = 1; i <= count; ++i) {
-      params.writeV2FastpathValue(i, pgStream);
-    }
-
-    pgStream.flush();
-  }
-
-  public synchronized void processNotifies() throws SQLException {
-    // Asynchronous notifies only arrive when we are not in a transaction
-    if (protoConnection.getTransactionState() != ProtocolConnection.TRANSACTION_IDLE) {
-      return;
-    }
-
-    try {
-      while (pgStream.hasMessagePending()) {
-        int c = pgStream.ReceiveChar();
-        switch (c) {
-          case 'A': // Asynchronous Notify
-            receiveAsyncNotify();
-            break;
-          case 'E': // Error Message
-            throw receiveErrorMessage();
-          case 'N': // Error Notification
-            protoConnection.addWarning(receiveNotification());
-            break;
-          default:
-            throw new PSQLException(GT.tr("Unknown Response Type {0}.", (char) c),
-                PSQLState.CONNECTION_FAILURE);
-        }
-      }
-    } catch (IOException ioe) {
-      throw new PSQLException(GT.tr("An I/O error occurred while sending to the backend."),
-          PSQLState.CONNECTION_FAILURE, ioe);
-    }
-  }
-
-  private byte[] receiveFastpathResult() throws IOException, SQLException {
-    SQLException error = null;
-    boolean endQuery = false;
-    byte[] result = null;
-
-    while (!endQuery) {
-      int c = pgStream.ReceiveChar();
-
-      switch (c) {
-        case 'A': // Asynchronous Notify
-          receiveAsyncNotify();
-          break;
-
-        case 'E': // Error Message
-          SQLException newError = receiveErrorMessage();
-          if (error == null) {
-            error = newError;
-          } else {
-            error.setNextException(newError);
-          }
-          // keep processing
-          break;
-
-        case 'N': // Error Notification
-          protoConnection.addWarning(receiveNotification());
-          break;
-
-        case 'V': // Fastpath result
-          c = pgStream.ReceiveChar();
-          if (c == 'G') {
-            if (logger.logDebug()) {
-              logger.debug(" <=BE FastpathResult");
-            }
-
-            // Result.
-            int len = pgStream.ReceiveInteger4();
-            result = pgStream.Receive(len);
-            c = pgStream.ReceiveChar();
-          } else {
-            if (logger.logDebug()) {
-              logger.debug(" <=BE FastpathVoidResult");
-            }
-          }
-
-          if (c != '0') {
-            throw new PSQLException(GT.tr("Unknown Response Type {0}.", (char) c),
-                PSQLState.CONNECTION_FAILURE);
-          }
-
-          break;
-
-        case 'Z':
-          if (logger.logDebug()) {
-            logger.debug(" <=BE ReadyForQuery");
-          }
-          endQuery = true;
-          break;
-
-        default:
-          throw new PSQLException(GT.tr("Unknown Response Type {0}.", (char) c),
-              PSQLState.CONNECTION_FAILURE);
-      }
-
-    }
-
-    // did we get an error during this query?
-    if (error != null) {
-      throw error;
-    }
-
-    return result;
-  }
-
-  //
-  // Query execution
-  //
-
-  public synchronized void execute(Query query, ParameterList parameters, ResultHandler handler,
-      int maxRows, int fetchSize, int flags) throws SQLException {
-    execute((V2Query) query, (SimpleParameterList) parameters, handler, maxRows, flags);
-  }
-
-  // Nothing special yet, just run the queries one at a time.
-  public synchronized void execute(Query[] queries, ParameterList[] parameters,
-      BatchResultHandler batchHandler, int maxRows, int fetchSize, int flags) throws SQLException {
-    final ResultHandler delegateHandler = batchHandler;
-    ResultHandler handler = new ResultHandler() {
-      public void handleResultRows(Query fromQuery, Field[] fields, List<byte[][]> tuples,
-          ResultCursor cursor) {
-        delegateHandler.handleResultRows(fromQuery, fields, tuples, cursor);
-      }
-
-      public void handleCommandStatus(String status, int updateCount, long insertOID) {
-        delegateHandler.handleCommandStatus(status, updateCount, insertOID);
-      }
-
-      public void handleWarning(SQLWarning warning) {
-        delegateHandler.handleWarning(warning);
-      }
-
-      public void handleError(SQLException error) {
-        delegateHandler.handleError(error);
-      }
-
-      public void handleCompletion() throws SQLException {
-      }
-    };
-
-    for (int i = 0; i < queries.length; ++i) {
-      execute((V2Query) queries[i], (SimpleParameterList) parameters[i], handler, maxRows, flags);
-      batchHandler.secureProgress();
-    }
-
-    delegateHandler.handleCompletion();
-  }
-
-  public void fetch(ResultCursor cursor, ResultHandler handler, int rows) throws SQLException {
-    throw org.postgresql.Driver.notImplemented(this.getClass(),
-        "fetch(ResultCursor,ResultHandler,int)");
-  }
-
-  private void execute(V2Query query, SimpleParameterList parameters, ResultHandler handler,
-      int maxRows, int flags) throws SQLException {
-
-    // The V2 protocol has no support for retrieving metadata
-    // without executing the whole query.
-    if ((flags & QueryExecutor.QUERY_DESCRIBE_ONLY) != 0) {
-      return;
-    }
-
-    if (parameters == null) {
-      parameters = (SimpleParameterList) query.createParameterList();
-    }
-
-    parameters.checkAllParametersSet();
-
-    String queryPrefix = null;
-    if (protoConnection.getTransactionState() == ProtocolConnection.TRANSACTION_IDLE
-        && (flags & QueryExecutor.QUERY_SUPPRESS_BEGIN) == 0) {
-
-      queryPrefix = "BEGIN;";
-
-      // Insert a handler that intercepts the BEGIN.
-      final ResultHandler delegateHandler = handler;
-      handler = new ResultHandler() {
-        private boolean sawBegin = false;
-
-        public void handleResultRows(Query fromQuery, Field[] fields, List<byte[][]> tuples,
-            ResultCursor cursor) {
-          if (sawBegin) {
-            delegateHandler.handleResultRows(fromQuery, fields, tuples, cursor);
-          }
-        }
-
-        public void handleCommandStatus(String status, int updateCount, long insertOID) {
-          if (!sawBegin) {
-            if (!status.equals("BEGIN")) {
-              handleError(
-                  new PSQLException(GT.tr("Expected command status BEGIN, got {0}.", status),
-                      PSQLState.PROTOCOL_VIOLATION));
-            }
-            sawBegin = true;
-          } else {
-            delegateHandler.handleCommandStatus(status, updateCount, insertOID);
-          }
-        }
-
-        public void handleWarning(SQLWarning warning) {
-          delegateHandler.handleWarning(warning);
-        }
-
-        public void handleError(SQLException error) {
-          delegateHandler.handleError(error);
-        }
-
-        public void handleCompletion() throws SQLException {
-          delegateHandler.handleCompletion();
-        }
-      };
-    }
-
-    try {
-      sendQuery(query, parameters, queryPrefix);
-      processResults(query, handler, maxRows, flags);
-    } catch (IOException e) {
-      protoConnection.abort();
-      handler.handleError(
-          new PSQLException(GT.tr("An I/O error occurred while sending to the backend."),
-              PSQLState.CONNECTION_FAILURE, e));
-    }
-
-    handler.handleCompletion();
-  }
-
-  /*
-   * Send a query to the backend.
-   */
-  protected void sendQuery(V2Query query, SimpleParameterList params, String queryPrefix)
-      throws IOException {
-    if (logger.logDebug()) {
-      logger.debug(" FE=> Query(\"" + (queryPrefix == null ? "" : queryPrefix)
-          + query.toString(params) + "\")");
-    }
-
-    pgStream.SendChar('Q');
-
-    Writer encodingWriter = pgStream.getEncodingWriter();
-
-    if (queryPrefix != null) {
-      encodingWriter.write(queryPrefix);
-    }
-
-    NativeQuery nativeQuery = query.getNativeQuery();
-
-    String nativeSql = nativeQuery.nativeSql;
-    if (params.getParameterCount() == 0) {
-      encodingWriter.write(nativeSql);
-    } else {
-      int[] bindPositions = nativeQuery.bindPositions;
-      encodingWriter.write(nativeSql, 0, bindPositions[0]);
-      for (int i = 1; i <= bindPositions.length; i++) {
-        params.writeV2Value(i, encodingWriter);
-
-        int nextBind = i < bindPositions.length ? bindPositions[i] : nativeSql.length();
-        int off = bindPositions[i - 1] + NativeQuery.bindName(i).length();
-        encodingWriter.write(nativeSql, off, nextBind - off);
-      }
-    }
-
-    encodingWriter.write(0);
-    pgStream.flush();
-  }
-
-  protected void processResults(Query originalQuery, ResultHandler handler, int maxRows, int flags)
-      throws IOException {
-    boolean bothRowsAndStatus = (flags & QueryExecutor.QUERY_BOTH_ROWS_AND_STATUS) != 0;
-    Field[] fields = null;
-    List<byte[][]> tuples = null;
-
-    boolean endQuery = false;
-    while (!endQuery) {
-      int c = pgStream.ReceiveChar();
-
-      switch (c) {
-        case 'A': // Asynchronous Notify
-          receiveAsyncNotify();
-          break;
-
-        case 'B': // Binary Data Transfer
-        {
-          if (fields == null) {
-            throw new IOException("Data transfer before field metadata");
-          }
-
-          if (logger.logDebug()) {
-            logger.debug(" <=BE BinaryRow");
-          }
-
-          byte[][] tuple = null;
-          try {
-            tuple = pgStream.ReceiveTupleV2(fields.length, true);
-          } catch (OutOfMemoryError oome) {
-            if (maxRows == 0 || tuples.size() < maxRows) {
-              handler.handleError(
-                  new PSQLException(GT.tr("Ran out of memory retrieving query results."),
-                      PSQLState.OUT_OF_MEMORY, oome));
-            }
-          }
-
-          for (Field field : fields) {
-            field.setFormat(Field.BINARY_FORMAT); // Set the field to binary format
-          }
-          if (maxRows == 0 || tuples.size() < maxRows) {
-            tuples.add(tuple);
-          }
-          break;
-        }
-
-        case 'C': // Command Status
-          String status = pgStream.ReceiveString();
-
-          if (logger.logDebug()) {
-            logger.debug(" <=BE CommandStatus(" + status + ")");
-          }
-
-          if (fields != null) {
-            handler.handleResultRows(originalQuery, fields, tuples, null);
-            fields = null;
-
-            if (bothRowsAndStatus) {
-              interpretCommandStatus(status, handler);
-            }
-          } else {
-            interpretCommandStatus(status, handler);
-          }
-
-          break;
-
-        case 'D': // Text Data Transfer
-        {
-          if (fields == null) {
-            throw new IOException("Data transfer before field metadata");
-          }
-
-          if (logger.logDebug()) {
-            logger.debug(" <=BE DataRow");
-          }
-
-          byte[][] tuple = null;
-          try {
-            tuple = pgStream.ReceiveTupleV2(fields.length, false);
-          } catch (OutOfMemoryError oome) {
-            if (maxRows == 0 || tuples.size() < maxRows) {
-              handler.handleError(
-                  new PSQLException(GT.tr("Ran out of memory retrieving query results."),
-                      PSQLState.OUT_OF_MEMORY, oome));
-            }
-          }
-          if (maxRows == 0 || tuples.size() < maxRows) {
-            tuples.add(tuple);
-          }
-          break;
-        }
-
-        case 'E': // Error Message
-          handler.handleError(receiveErrorMessage());
-          // keep processing
-          break;
-
-        case 'I': // Empty Query
-          if (logger.logDebug()) {
-            logger.debug(" <=BE EmptyQuery");
-          }
-          c = pgStream.ReceiveChar();
-          if (c != 0) {
-            throw new IOException("Expected \\0 after EmptyQuery, got: " + c);
-          }
-          break;
-
-        case 'N': // Error Notification
-          handler.handleWarning(receiveNotification());
-          break;
-
-        case 'P': // Portal Name
-          String portalName = pgStream.ReceiveString();
-          if (logger.logDebug()) {
-            logger.debug(" <=BE PortalName(" + portalName + ")");
-          }
-          break;
-
-        case 'T': // MetaData Field Description
-          fields = receiveFields();
-          tuples = new ArrayList<byte[][]>();
-          break;
-
-        case 'Z':
-          if (logger.logDebug()) {
-            logger.debug(" <=BE ReadyForQuery");
-          }
-          endQuery = true;
-          break;
-
-        default:
-          throw new IOException("Unexpected packet type: " + c);
-      }
-
-    }
-  }
-
-  /*
-   * Receive the field descriptions from the back end.
-   */
-  private Field[] receiveFields() throws IOException {
-    int size = pgStream.ReceiveInteger2();
-    Field[] fields = new Field[size];
-
-    if (logger.logDebug()) {
-      logger.debug(" <=BE RowDescription(" + fields.length + ")");
-    }
-
-    for (int i = 0; i < fields.length; i++) {
-      String columnLabel = pgStream.ReceiveString();
-      int typeOid = pgStream.ReceiveInteger4();
-      int typeLength = pgStream.ReceiveInteger2();
-      int typeModifier = pgStream.ReceiveInteger4();
-      fields[i] = new Field(columnLabel, typeOid, typeLength, typeModifier, 0, 0);
-    }
-
-    return fields;
-  }
-
-  private void receiveAsyncNotify() throws IOException {
-    int pid = pgStream.ReceiveInteger4();
-    String msg = pgStream.ReceiveString();
-
-    if (logger.logDebug()) {
-      logger.debug(" <=BE AsyncNotify(pid=" + pid + ",msg=" + msg + ")");
-    }
-
-    protoConnection.addNotification(new org.postgresql.core.Notification(msg, pid));
-  }
-
-  private SQLException receiveErrorMessage() throws IOException {
-    String errorMsg = pgStream.ReceiveString().trim();
-    if (logger.logDebug()) {
-      logger.debug(" <=BE ErrorResponse(" + errorMsg + ")");
-    }
-    return new PSQLException(errorMsg, PSQLState.UNKNOWN_STATE);
-  }
-
-  private SQLWarning receiveNotification() throws IOException {
-    String warnMsg = pgStream.ReceiveString();
-
-    // Strip out the severity field so we have consistency with
-    // the V3 protocol. SQLWarning.getMessage should return just
-    // the actual message.
-    //
-    int severityMark = warnMsg.indexOf(":");
-    warnMsg = warnMsg.substring(severityMark + 1).trim();
-    if (logger.logDebug()) {
-      logger.debug(" <=BE NoticeResponse(" + warnMsg + ")");
-    }
-    return new SQLWarning(warnMsg);
-  }
-
-  private void interpretCommandStatus(String status, ResultHandler handler) throws IOException {
-    int update_count = 0;
-    long insert_oid = 0;
-
-    if (status.equals("BEGIN")) {
-      protoConnection.setTransactionState(ProtocolConnection.TRANSACTION_OPEN);
-    } else if (status.equals("COMMIT") || status.equals("ROLLBACK")) {
-      protoConnection.setTransactionState(ProtocolConnection.TRANSACTION_IDLE);
-    } else if (status.startsWith("INSERT") || status.startsWith("UPDATE")
-        || status.startsWith("DELETE") || status.startsWith("MOVE")) {
-      try {
-        long updates = Long.parseLong(status.substring(1 + status.lastIndexOf(' ')));
-
-        // deal with situations where the update modifies more than 2^32 rows
-        if (updates > Integer.MAX_VALUE) {
-          update_count = Statement.SUCCESS_NO_INFO;
-        } else {
-          update_count = (int) updates;
-        }
-
-        if (status.startsWith("INSERT")) {
-          insert_oid =
-              Long.parseLong(status.substring(1 + status.indexOf(' '), status.lastIndexOf(' ')));
-        }
-      } catch (NumberFormatException nfe) {
-        handler.handleError(new PSQLException(
-            GT.tr("Unable to interpret the update count in command completion tag: {0}.", status),
-            PSQLState.CONNECTION_FAILURE));
-        return;
-      }
-    }
-
-    handler.handleCommandStatus(status, update_count, insert_oid);
-  }
-
-  private final ProtocolConnectionImpl protoConnection;
-  private final PGStream pgStream;
-  private final Logger logger;
-
-  public CopyOperation startCopy(String sql, boolean suppressBegin) throws SQLException {
-    throw new PSQLException(GT.tr("Copy not implemented for protocol version 2"),
-        PSQLState.NOT_IMPLEMENTED);
-  }
-}
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v2/SimpleParameterList.java b/pgjdbc/src/main/java/org/postgresql/core/v2/SimpleParameterList.java
deleted file mode 100644
index bfa177520c..0000000000
--- a/pgjdbc/src/main/java/org/postgresql/core/v2/SimpleParameterList.java
+++ /dev/null
@@ -1,258 +0,0 @@
-/*-------------------------------------------------------------------------
-*
-* Copyright (c) 2004-2014, PostgreSQL Global Development Group
-* Copyright (c) 2004, Open Cloud Limited.
-*
-*
-*-------------------------------------------------------------------------
-*/
-
-package org.postgresql.core.v2;
-
-import org.postgresql.core.Oid;
-import org.postgresql.core.ParameterList;
-import org.postgresql.core.Utils;
-import org.postgresql.util.GT;
-import org.postgresql.util.PSQLException;
-import org.postgresql.util.PSQLState;
-import org.postgresql.util.StreamWrapper;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.Writer;
-import java.sql.SQLException;
-import java.util.Arrays;
-
-/**
- * Parameter list for query parameters in the V2 protocol.
- *
- * @author Oliver Jowett (oliver@opencloud.com)
- */
-class SimpleParameterList implements ParameterList {
-  SimpleParameterList(int paramCount, boolean useEStringSyntax) {
-    this.paramValues = new Object[paramCount];
-    this.useEStringSyntax = useEStringSyntax;
-  }
-
-  public void registerOutParameter(int index, int sqlType) {
-  }
-
-  ;
-
-  public void registerOutParameter(int index, int sqlType, int precision) {
-  }
-
-  ;
-
-  public int getInParameterCount() {
-    return paramValues.length;
-  }
-
-  public int getParameterCount() {
-    return paramValues.length;
-  }
-
-  public int getOutParameterCount() {
-    return 1;
-  }
-
-  public int[] getTypeOIDs() {
-    return null;
-  }
-
-  public void setIntParameter(int index, int value) throws SQLException {
-    setLiteralParameter(index, "" + value, Oid.INT4);
-  }
-
-  public void setLiteralParameter(int index, String value, int oid) throws SQLException {
-    if (index < 1 || index > paramValues.length) {
-      throw new PSQLException(
-          GT.tr("The column index is out of range: {0}, number of columns: {1}.",
-              new Object[]{index, paramValues.length}),
-          PSQLState.INVALID_PARAMETER_VALUE);
-    }
-
-    paramValues[index - 1] = value;
-  }
-
-  public void setStringParameter(int index, String value, int oid) throws SQLException {
-    StringBuilder sbuf = new StringBuilder(2 + value.length() * 11 / 10); // Add 10% for escaping.
-
-    if (useEStringSyntax) {
-      sbuf.append(' ').append('E');
-    }
-    sbuf.append('\'');
-    Utils.escapeLiteral(sbuf, value, false);
-    sbuf.append('\'');
-
-    setLiteralParameter(index, sbuf.toString(), oid);
-  }
-
-  public void setBytea(int index, byte[] data, int offset, int length) throws SQLException {
-    if (index < 1 || index > paramValues.length) {
-      throw new PSQLException(
-          GT.tr("The column index is out of range: {0}, number of columns: {1}.",
-              new Object[]{index, paramValues.length}),
-          PSQLState.INVALID_PARAMETER_VALUE);
-    }
-
-    paramValues[index - 1] = new StreamWrapper(data, offset, length);
-  }
-
-  public void setBytea(int index, final InputStream stream, final int length) throws SQLException {
-    if (index < 1 || index > paramValues.length) {
-      throw new PSQLException(
-          GT.tr("The column index is out of range: {0}, number of columns: {1}.",
-              new Object[]{index, paramValues.length}),
-          PSQLState.INVALID_PARAMETER_VALUE);
-    }
-
-    paramValues[index - 1] = new StreamWrapper(stream, length);
-  }
-
-  public void setBytea(int index, InputStream stream) throws SQLException {
-    if (index < 1 || index > paramValues.length) {
-      throw new PSQLException(
-          GT.tr("The column index is out of range: {0}, number of columns: {1}.",
-              new Object[]{index, paramValues.length}),
-          PSQLState.INVALID_PARAMETER_VALUE);
-    }
-
-    paramValues[index - 1] = new StreamWrapper(stream);
-  }
-
-  public void setNull(int index, int oid) throws SQLException {
-    if (index < 1 || index > paramValues.length) {
-      throw new PSQLException(
-          GT.tr("The column index is out of range: {0}, number of columns: {1}.",
-              new Object[]{index, paramValues.length}),
-          PSQLState.INVALID_PARAMETER_VALUE);
-    }
-
-    paramValues[index - 1] = NULL_OBJECT;
-  }
-
-  public String toString(int index) {
-    if (index < 1 || index > paramValues.length) {
-      throw new IllegalArgumentException("Parameter index " + index + " out of range");
-    }
-
-    if (paramValues[index - 1] == null) {
-      return "?";
-    } else if (paramValues[index - 1] == NULL_OBJECT) {
-      return "NULL";
-    } else {
-      return paramValues[index - 1].toString();
-    }
-  }
-
-  /**
-   * Send a streamable bytea encoded as a text representation with an arbitary encoding.
-   */
-  private void streamBytea(StreamWrapper param, Writer encodingWriter) throws IOException {
-    // NB: we escape everything in this path, as I don't like assuming
-    // that byte values 32..127 will make it through the encoding
-    // unscathed..
-
-    InputStream stream = param.getStream();
-    char[] buffer = new char[]{'\\', '\\', 0, 0, 0};
-
-    if (useEStringSyntax) {
-      encodingWriter.write(' ');
-      encodingWriter.write('E');
-    }
-
-    encodingWriter.write('\'');
-    for (int remaining = param.getLength(); remaining > 0; --remaining) {
-      int nextByte = stream.read();
-
-      buffer[2] = (char) ('0' + ((nextByte >> 6) & 3));
-      buffer[3] = (char) ('0' + ((nextByte >> 3) & 7));
-      buffer[4] = (char) ('0' + (nextByte & 7));
-
-      encodingWriter.write(buffer, 0, 5);
-    }
-
-    encodingWriter.write('\'');
-  }
-
-
-  void writeV2Value(int index, Writer encodingWriter) throws IOException {
-    if (paramValues[index - 1] instanceof StreamWrapper) {
-      streamBytea((StreamWrapper) paramValues[index - 1], encodingWriter);
-    } else {
-      encodingWriter.write((String) paramValues[index - 1]);
-    }
-  }
-
-  void checkAllParametersSet() throws SQLException {
-    for (int i = 0; i < paramValues.length; i++) {
-      if (paramValues[i] == null) {
-        throw new PSQLException(GT.tr("No value specified for parameter {0}.", i + 1),
-            PSQLState.INVALID_PARAMETER_VALUE);
-      }
-    }
-  }
-
-  public ParameterList copy() {
-    SimpleParameterList newCopy = new SimpleParameterList(paramValues.length, useEStringSyntax);
-    System.arraycopy(paramValues, 0, newCopy.paramValues, 0, paramValues.length);
-    return newCopy;
-  }
-
-  public void clear() {
-    Arrays.fill(paramValues, null);
-  }
-
-  public void setBinaryParameter(int index, byte[] value, int oid) {
-    throw new UnsupportedOperationException();
-  }
-
-  public Object[] getValues() {
-    return paramValues;
-  }
-
-  /**
-   * Append parameters to the list.
-   */
-  public void appendAll(ParameterList list) throws SQLException {
-    if (list instanceof SimpleParameterList ) {
-      /* only v2.SimpleParameterList is compatible with this type. The list
-      of parameters is expected to already be cloned from the values
-      passed by application. */
-      SimpleParameterList spl = (SimpleParameterList) list;
-      int count = spl.getInParameterCount();
-      System.arraycopy(spl.getValues(), 0, paramValues,
-          getInParameterCount() - count,
-          count);
-    }
-  }
-
-  /**
-   * Provide a useful implementation to aid debugging/testing.
-   * @return String representation of the values in the list
-   */
-  public String toString() {
-    StringBuilder ts = new StringBuilder("<[");
-    if (paramValues.length > 0) {
-      ts.append(toString(1));
-      for (int c = 2; c <= paramValues.length; c++) {
-        ts.append(" ,").append(toString(c));
-      }
-    }
-    ts.append("]>");
-    return ts.toString();
-  }
-
-  private final Object[] paramValues;
-
-  private final boolean useEStringSyntax;
-
-  /*
-   * Object representing NULL; conveniently, String streams exactly as we want it to. * nb: we
-   * explicitly say "new String" to avoid interning giving us an object that might be the same (by
-   * identity) as a String elsewhere.
-   */
-  private final static String NULL_OBJECT = new String("NULL");
-}
-
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v2/V2Query.java b/pgjdbc/src/main/java/org/postgresql/core/v2/V2Query.java
deleted file mode 100644
index ee0967714d..0000000000
--- a/pgjdbc/src/main/java/org/postgresql/core/v2/V2Query.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*-------------------------------------------------------------------------
-*
-* Copyright (c) 2003-2014, PostgreSQL Global Development Group
-* Copyright (c) 2004, Open Cloud Limited.
-*
-*
-*-------------------------------------------------------------------------
-*/
-
-package org.postgresql.core.v2;
-
-import org.postgresql.core.NativeQuery;
-import org.postgresql.core.ParameterList;
-import org.postgresql.core.Parser;
-import org.postgresql.core.ProtocolConnection;
-import org.postgresql.core.Query;
-import org.postgresql.core.SqlCommand;
-import org.postgresql.core.SqlCommandType;
-
-import java.util.List;
-
-/**
- * Query implementation for all queries via the V2 protocol.
- */
-class V2Query implements Query {
-  V2Query(String query, boolean withParameters, ProtocolConnection pconn) {
-
-    useEStringSyntax = pconn.getServerVersionNum() >= 80100;
-    boolean stdStrings = pconn.getStandardConformingStrings();
-
-    List<NativeQuery> queries = Parser.parseJdbcSql(query, stdStrings, withParameters, false, true, false);
-    assert queries.size() <= 1 : "Exactly one query expected in V2. " + queries.size()
-        + " queries given.";
-
-    nativeQuery = queries.isEmpty() ? new NativeQuery("", SqlCommand.createStatementTypeInfo(
-        SqlCommandType.BLANK)) : queries.get(0);
-  }
-
-  public ParameterList createParameterList() {
-    if (nativeQuery.bindPositions.length == 0) {
-      return NO_PARAMETERS;
-    }
-
-    return new SimpleParameterList(nativeQuery.bindPositions.length, useEStringSyntax);
-  }
-
-  public String toString(ParameterList parameters) {
-    return nativeQuery.toString(parameters);
-  }
-
-  public void close() {
-  }
-
-  NativeQuery getNativeQuery() {
-    return nativeQuery;
-  }
-
-  public boolean isStatementDescribed() {
-    return false;
-  }
-
-  public boolean isEmpty() {
-    return nativeQuery.nativeSql.isEmpty();
-  }
-
-  public int getBatchSize() {
-    return 1;
-  }
-
-  private static final ParameterList NO_PARAMETERS = new SimpleParameterList(0, false);
-
-  private final NativeQuery nativeQuery;
-
-  private final boolean useEStringSyntax; // whether escaped string syntax should be used
-}
-
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v3/BatchedQuery.java b/pgjdbc/src/main/java/org/postgresql/core/v3/BatchedQuery.java
index a1c6ad2f10..d945549c79 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v3/BatchedQuery.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v3/BatchedQuery.java
@@ -9,6 +9,7 @@
 package org.postgresql.core.v3;
 
 import org.postgresql.core.NativeQuery;
+import org.postgresql.core.ParameterList;
 
 
 /**
@@ -29,10 +30,10 @@ public class BatchedQuery extends SimpleQuery {
   private final int batchSize;
   private BatchedQuery[] blocks;
 
-  public BatchedQuery(NativeQuery query, ProtocolConnectionImpl protoConnection,
+  public BatchedQuery(NativeQuery query, TypeTransferModeRegistry transferModeRegistry,
       int valuesBraceOpenPosition,
-      int valuesBraceClosePosition) {
-    super(query, protoConnection);
+      int valuesBraceClosePosition, boolean sanitiserDisabled) {
+    super(query, transferModeRegistry, sanitiserDisabled);
     this.valuesBraceOpenPosition = valuesBraceOpenPosition;
     this.valuesBraceClosePosition = valuesBraceClosePosition;
     this.batchSize = 1;
@@ -79,10 +80,16 @@ public int getBatchSize() {
    * batch.
    */
   @Override
-  String getNativeSql() {
+  public String getNativeSql() {
     if (sql != null) {
       return sql;
     }
+    sql = buildNativeSql(null);
+    return sql;
+  }
+
+  private String buildNativeSql(ParameterList params) {
+    String sql = null;
     // dynamically build sql with parameters for batches
     String nativeSql = super.getNativeSql();
     int batchSize = getBatchSize();
@@ -100,22 +107,27 @@ String getNativeSql() {
     int[] chunkStart = new int[1 + bindPositions.length];
     int[] chunkEnd = new int[1 + bindPositions.length];
     chunkStart[0] = valuesBraceOpenPosition;
-    chunkEnd[0] = bindPositions[0];
-    // valuesBlockCharCount += chunks[0].length;
-    valuesBlockCharCount += chunkEnd[0] - chunkStart[0];
-    for (int i = 0; i < bindPositions.length; i++) {
-      int startIndex = bindPositions[i] + 2;
-      int endIndex =
-          i < bindPositions.length - 1 ? bindPositions[i + 1] : valuesBraceClosePosition + 1;
-      for (; startIndex < endIndex; startIndex++) {
-        if (!Character.isDigit(nativeSql.charAt(startIndex))) {
-          break;
+    if (bindPositions.length == 0) {
+      valuesBlockCharCount = valuesBraceClosePosition - valuesBraceOpenPosition + 1;
+      chunkEnd[0] = valuesBraceClosePosition + 1;
+    } else {
+      chunkEnd[0] = bindPositions[0];
+      // valuesBlockCharCount += chunks[0].length;
+      valuesBlockCharCount += chunkEnd[0] - chunkStart[0];
+      for (int i = 0; i < bindPositions.length; i++) {
+        int startIndex = bindPositions[i] + 2;
+        int endIndex =
+            i < bindPositions.length - 1 ? bindPositions[i + 1] : valuesBraceClosePosition + 1;
+        for (; startIndex < endIndex; startIndex++) {
+          if (!Character.isDigit(nativeSql.charAt(startIndex))) {
+            break;
+          }
         }
+        chunkStart[i + 1] = startIndex;
+        chunkEnd[i + 1] = endIndex;
+        // valuesBlockCharCount += chunks[i + 1].length;
+        valuesBlockCharCount += chunkEnd[i + 1] - chunkStart[i + 1];
       }
-      chunkStart[i + 1] = startIndex;
-      chunkEnd[i + 1] = endIndex;
-      // valuesBlockCharCount += chunks[i + 1].length;
-      valuesBlockCharCount += chunkEnd[i + 1] - chunkStart[i + 1];
     }
     int length = nativeSql.length();
     //valuesBraceOpenPosition + valuesBlockCharCount;
@@ -125,13 +137,31 @@ String getNativeSql() {
 
     StringBuilder s = new StringBuilder(length);
     // Add query until end of values parameter block.
-    s.append(nativeSql, 0, valuesBraceClosePosition + 1);
-    int pos = bindPositions.length + 1;
+    int pos;
+    if (bindPositions.length > 0 && params == null) {
+      // Add the first values (...) clause, it would be values($1,..., $n), and it matches with
+      // the values clause of a simple non-rewritten SQL
+      s.append(nativeSql, 0, valuesBraceClosePosition + 1);
+      pos = bindPositions.length + 1;
+    } else {
+      pos = 1;
+      batchSize++; // do not use super.toString(params) as it does not work if query ends with --
+      // We need to carefully add (...),(...), and we do not want to get (...) --, (...)
+      // s.append(super.toString(params));
+      s.append(nativeSql, 0, valuesBraceOpenPosition);
+    }
     for (int i = 2; i <= batchSize; i++) {
-      s.append(',');
+      if (i > 2 || pos != 1) {
+        // For "has binds" the first valuds
+        s.append(',');
+      }
       s.append(nativeSql, chunkStart[0], chunkEnd[0]);
       for (int j = 1; j < chunkStart.length; j++) {
-        NativeQuery.appendBindName(s, pos++);
+        if (params == null) {
+          NativeQuery.appendBindName(s, pos++);
+        } else {
+          s.append(params.toString(pos++, true));
+        }
         s.append(nativeSql, chunkStart[j], chunkEnd[j]);
       }
     }
@@ -139,14 +169,18 @@ String getNativeSql() {
     // This could contain "--" comments, so it is important to add them at end.
     s.append(nativeSql, valuesBraceClosePosition + 1, nativeSql.length());
     sql = s.toString();
-    assert s.length() == length
+    // Predict length only when building sql with $1, $2, ... (that is no specific params given)
+    assert params != null || s.length() == length
         : "Predicted length != actual: " + length + " !=" + s.length();
     return sql;
   }
 
   @Override
-  public String toString() {
-    return getNativeSql();
+  public String toString(ParameterList params) {
+    if (getBatchSize() < 2) {
+      return super.toString(params);
+    }
+    return buildNativeSql(params);
   }
 
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v3/CompositeParameterList.java b/pgjdbc/src/main/java/org/postgresql/core/v3/CompositeParameterList.java
index 4fbfade4ef..2edbe3b640 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v3/CompositeParameterList.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v3/CompositeParameterList.java
@@ -30,11 +30,10 @@ class CompositeParameterList implements V3ParameterList {
     this.total = offsets[offsets.length - 1] + subparams[offsets.length - 1].getInParameterCount();
   }
 
-  private final int findSubParam(int index) throws SQLException {
+  private int findSubParam(int index) throws SQLException {
     if (index < 1 || index > total) {
       throw new PSQLException(
-          GT.tr("The column index is out of range: {0}, number of columns: {1}.",
-              new Object[]{index, total}),
+          GT.tr("The column index is out of range: {0}, number of columns: {1}.", index, total),
           PSQLState.INVALID_PARAMETER_VALUE);
     }
 
@@ -116,10 +115,10 @@ public void setNull(int index, int oid) throws SQLException {
     subparams[sub].setNull(index - offsets[sub], oid);
   }
 
-  public String toString(int index) {
+  public String toString(int index, boolean standardConformingStrings) {
     try {
       int sub = findSubParam(index);
-      return subparams[sub].toString(index - offsets[sub]);
+      return subparams[sub].toString(index - offsets[sub], standardConformingStrings);
     } catch (SQLException e) {
       throw new IllegalStateException(e.getMessage());
     }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v3/CompositeQuery.java b/pgjdbc/src/main/java/org/postgresql/core/v3/CompositeQuery.java
index 3a5bc668d7..4e9e0d6e78 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v3/CompositeQuery.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v3/CompositeQuery.java
@@ -10,6 +10,10 @@
 package org.postgresql.core.v3;
 
 import org.postgresql.core.ParameterList;
+import org.postgresql.core.Query;
+import org.postgresql.core.SqlCommand;
+
+import java.util.Map;
 
 /**
  * V3 Query implementation for queries that involve multiple statements. We split it up into one
@@ -18,7 +22,7 @@
  *
  * @author Oliver Jowett (oliver@opencloud.com)
  */
-class CompositeQuery implements V3Query {
+class CompositeQuery implements Query {
   CompositeQuery(SimpleQuery[] subqueries, int[] offsets) {
     this.subqueries = subqueries;
     this.offsets = offsets;
@@ -41,6 +45,21 @@ public String toString(ParameterList parameters) {
     return sbuf.toString();
   }
 
+  @Override
+  public String getNativeSql() {
+    StringBuilder sbuf = new StringBuilder(subqueries[0].toString());
+    for (int i = 1; i < subqueries.length; ++i) {
+      sbuf.append(';');
+      sbuf.append(subqueries[i].getNativeSql());
+    }
+    return sbuf.toString();
+  }
+
+  @Override
+  public SqlCommand getSqlCommand() {
+    return null;
+  }
+
   public String toString() {
     return toString(null);
   }
@@ -51,7 +70,7 @@ public void close() {
     }
   }
 
-  public SimpleQuery[] getSubqueries() {
+  public Query[] getSubqueries() {
     return subqueries;
   }
 
@@ -77,6 +96,11 @@ public int getBatchSize() {
     return 0; // no-op, unsupported
   }
 
+  @Override
+  public Map<String, Integer> getResultSetColumnNameIndexMap() {
+    return null; // unsupported
+  }
+
   private final SimpleQuery[] subqueries;
   private final int[] offsets;
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v3/ConnectionFactoryImpl.java b/pgjdbc/src/main/java/org/postgresql/core/v3/ConnectionFactoryImpl.java
index 5c445836c3..ec43cc85e9 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v3/ConnectionFactoryImpl.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v3/ConnectionFactoryImpl.java
@@ -11,14 +11,13 @@
 
 import org.postgresql.PGProperty;
 import org.postgresql.core.ConnectionFactory;
-import org.postgresql.core.Encoding;
 import org.postgresql.core.Logger;
 import org.postgresql.core.PGStream;
-import org.postgresql.core.ProtocolConnection;
+import org.postgresql.core.QueryExecutor;
 import org.postgresql.core.ServerVersion;
 import org.postgresql.core.SetupQueryRunner;
+import org.postgresql.core.SocketFactoryFactory;
 import org.postgresql.core.Utils;
-import org.postgresql.core.v2.SocketFactoryFactory;
 import org.postgresql.hostchooser.GlobalHostStatusTracker;
 import org.postgresql.hostchooser.HostChooser;
 import org.postgresql.hostchooser.HostChooserFactory;
@@ -30,7 +29,6 @@
 import org.postgresql.util.MD5Digest;
 import org.postgresql.util.PSQLException;
 import org.postgresql.util.PSQLState;
-import org.postgresql.util.PSQLWarning;
 import org.postgresql.util.ServerErrorMessage;
 import org.postgresql.util.UnixCrypt;
 
@@ -42,7 +40,6 @@
 import java.util.List;
 import java.util.Properties;
 import java.util.TimeZone;
-
 import javax.net.SocketFactory;
 
 /**
@@ -84,7 +81,7 @@ private ISSPIClient createSSPI(PGStream pgStream,
     }
   }
 
-  public ProtocolConnection openConnectionImpl(HostSpec[] hostSpecs, String user, String database,
+  public QueryExecutor openConnectionImpl(HostSpec[] hostSpecs, String user, String database,
       Properties info, Logger logger) throws SQLException {
     // Extract interesting values from the info properties:
     // - the SSL setting
@@ -225,19 +222,17 @@ public ProtocolConnection openConnectionImpl(HostSpec[] hostSpecs, String user,
         int cancelSignalTimeout = PGProperty.CANCEL_SIGNAL_TIMEOUT.getInt(info) * 1000;
 
         // Do final startup.
-        ProtocolConnectionImpl protoConnection =
-            new ProtocolConnectionImpl(newStream, user, database, info, logger,
-                cancelSignalTimeout);
-        readStartupMessages(newStream, protoConnection, logger);
+        QueryExecutor queryExecutor = new QueryExecutorImpl(newStream, user, database,
+            cancelSignalTimeout, info, logger);
 
         // Check Master or Slave
         HostStatus hostStatus = HostStatus.ConnectOK;
         if (targetServerType != HostRequirement.any) {
-          hostStatus = isMaster(protoConnection, logger) ? HostStatus.Master : HostStatus.Slave;
+          hostStatus = isMaster(queryExecutor, logger) ? HostStatus.Master : HostStatus.Slave;
         }
         GlobalHostStatusTracker.reportHostStatus(hostSpec, hostStatus);
         if (!targetServerType.allowConnectingTo(hostStatus)) {
-          protoConnection.close();
+          queryExecutor.close();
           if (hostIter.hasNext()) {
             // still more addresses to try
             continue;
@@ -247,10 +242,10 @@ public ProtocolConnection openConnectionImpl(HostSpec[] hostSpecs, String user,
               PSQLState.CONNECTION_UNABLE_TO_CONNECT);
         }
 
-        runInitialQueries(protoConnection, info, logger);
+        runInitialQueries(queryExecutor, info, logger);
 
         // And we're done.
-        return protoConnection;
+        return queryExecutor;
       } catch (UnsupportedProtocolException upe) {
         // Swallow this and return null so ConnectionFactory tries the next protocol.
         if (logger.logDebug()) {
@@ -324,13 +319,13 @@ private PGStream enableSSL(PGStream pgStream, boolean requireSSL, Properties inf
     }
 
     // Send SSL request packet
-    pgStream.SendInteger4(8);
-    pgStream.SendInteger2(1234);
-    pgStream.SendInteger2(5679);
+    pgStream.sendInteger4(8);
+    pgStream.sendInteger2(1234);
+    pgStream.sendInteger2(5679);
     pgStream.flush();
 
     // Now get the response from the backend, one of N, E, S.
-    int beresp = pgStream.ReceiveChar();
+    int beresp = pgStream.receiveChar();
     switch (beresp) {
       case 'E':
         if (logger.logDebug()) {
@@ -402,15 +397,15 @@ private void sendStartupPacket(PGStream pgStream, List<String[]> params, Logger
     length += 1; // Terminating \0
 
     // Send the startup message.
-    pgStream.SendInteger4(length);
-    pgStream.SendInteger2(3); // protocol major
-    pgStream.SendInteger2(0); // protocol minor
+    pgStream.sendInteger4(length);
+    pgStream.sendInteger2(3); // protocol major
+    pgStream.sendInteger2(0); // protocol minor
     for (byte[] encodedParam : encodedParams) {
-      pgStream.Send(encodedParam);
-      pgStream.SendChar(0);
+      pgStream.send(encodedParam);
+      pgStream.sendChar(0);
     }
 
-    pgStream.SendChar(0);
+    pgStream.sendChar(0);
     pgStream.flush();
   }
 
@@ -426,7 +421,7 @@ private void doAuthentication(PGStream pgStream, String host, String user, Prope
 
     try {
       authloop: while (true) {
-        int beresp = pgStream.ReceiveChar();
+        int beresp = pgStream.receiveChar();
 
         switch (beresp) {
           case 'E':
@@ -436,7 +431,7 @@ private void doAuthentication(PGStream pgStream, String host, String user, Prope
             // The most common one to be thrown here is:
             // "User authentication failed"
             //
-            int l_elen = pgStream.ReceiveInteger4();
+            int l_elen = pgStream.receiveInteger4();
             if (l_elen > 30000) {
               // if the error length is > than 30000 we assume this is really a v2 protocol
               // server, so trigger fallback.
@@ -444,7 +439,7 @@ private void doAuthentication(PGStream pgStream, String host, String user, Prope
             }
 
             ServerErrorMessage errorMsg =
-                new ServerErrorMessage(pgStream.ReceiveString(l_elen - 4), logger.getLogLevel());
+                new ServerErrorMessage(pgStream.receiveErrorString(l_elen - 4), logger.getLogLevel());
             if (logger.logDebug()) {
               logger.debug(" <=BE ErrorMessage(" + errorMsg + ")");
             }
@@ -453,15 +448,15 @@ private void doAuthentication(PGStream pgStream, String host, String user, Prope
           case 'R':
             // Authentication request.
             // Get the message length
-            int l_msgLen = pgStream.ReceiveInteger4();
+            int l_msgLen = pgStream.receiveInteger4();
 
             // Get the type of request
-            int areq = pgStream.ReceiveInteger4();
+            int areq = pgStream.receiveInteger4();
 
             // Process the request.
             switch (areq) {
               case AUTH_REQ_CRYPT: {
-                byte[] salt = pgStream.Receive(2);
+                byte[] salt = pgStream.receive(2);
 
                 if (logger.logDebug()) {
                   logger.debug(
@@ -482,17 +477,17 @@ private void doAuthentication(PGStream pgStream, String host, String user, Prope
                       " FE=> Password(crypt='" + new String(encodedResult, "US-ASCII") + "')");
                 }
 
-                pgStream.SendChar('p');
-                pgStream.SendInteger4(4 + encodedResult.length + 1);
-                pgStream.Send(encodedResult);
-                pgStream.SendChar(0);
+                pgStream.sendChar('p');
+                pgStream.sendInteger4(4 + encodedResult.length + 1);
+                pgStream.send(encodedResult);
+                pgStream.sendChar(0);
                 pgStream.flush();
 
                 break;
               }
 
               case AUTH_REQ_MD5: {
-                byte[] md5Salt = pgStream.Receive(4);
+                byte[] md5Salt = pgStream.receive(4);
                 if (logger.logDebug()) {
                   logger
                       .debug(" <=BE AuthenticationReqMD5(salt=" + Utils.toHexString(md5Salt) + ")");
@@ -512,10 +507,10 @@ private void doAuthentication(PGStream pgStream, String host, String user, Prope
                   logger.debug(" FE=> Password(md5digest=" + new String(digest, "US-ASCII") + ")");
                 }
 
-                pgStream.SendChar('p');
-                pgStream.SendInteger4(4 + digest.length + 1);
-                pgStream.Send(digest);
-                pgStream.SendChar(0);
+                pgStream.sendChar('p');
+                pgStream.sendInteger4(4 + digest.length + 1);
+                pgStream.send(digest);
+                pgStream.sendChar(0);
                 pgStream.flush();
 
                 break;
@@ -536,10 +531,10 @@ private void doAuthentication(PGStream pgStream, String host, String user, Prope
 
                 byte[] encodedPassword = password.getBytes("UTF-8");
 
-                pgStream.SendChar('p');
-                pgStream.SendInteger4(4 + encodedPassword.length + 1);
-                pgStream.Send(encodedPassword);
-                pgStream.SendChar(0);
+                pgStream.sendChar('p');
+                pgStream.sendInteger4(4 + encodedPassword.length + 1);
+                pgStream.send(encodedPassword);
+                pgStream.sendChar(0);
                 pgStream.flush();
 
                 break;
@@ -665,137 +660,7 @@ private void doAuthentication(PGStream pgStream, String host, String user, Prope
 
   }
 
-  private void readStartupMessages(PGStream pgStream, ProtocolConnectionImpl protoConnection,
-      Logger logger) throws IOException, SQLException {
-    while (true) {
-      int beresp = pgStream.ReceiveChar();
-      switch (beresp) {
-        case 'Z':
-          // Ready For Query; we're done.
-          if (pgStream.ReceiveInteger4() != 5) {
-            throw new IOException("unexpected length of ReadyForQuery packet");
-          }
-
-          char tStatus = (char) pgStream.ReceiveChar();
-          if (logger.logDebug()) {
-            logger.debug(" <=BE ReadyForQuery(" + tStatus + ")");
-          }
-
-          // Update connection state.
-          switch (tStatus) {
-            case 'I':
-              protoConnection.setTransactionState(ProtocolConnection.TRANSACTION_IDLE);
-              break;
-            case 'T':
-              protoConnection.setTransactionState(ProtocolConnection.TRANSACTION_OPEN);
-              break;
-            case 'E':
-              protoConnection.setTransactionState(ProtocolConnection.TRANSACTION_FAILED);
-              break;
-            default:
-              // Huh?
-              break;
-          }
-
-          return;
-
-        case 'K':
-          // BackendKeyData
-          int l_msgLen = pgStream.ReceiveInteger4();
-          if (l_msgLen != 12) {
-            throw new PSQLException(GT.tr("Protocol error.  Session setup failed."),
-                PSQLState.PROTOCOL_VIOLATION);
-          }
-
-          int pid = pgStream.ReceiveInteger4();
-          int ckey = pgStream.ReceiveInteger4();
-
-          if (logger.logDebug()) {
-            logger.debug(" <=BE BackendKeyData(pid=" + pid + ",ckey=" + ckey + ")");
-          }
-
-          protoConnection.setBackendKeyData(pid, ckey);
-          break;
-
-        case 'E':
-          // Error
-          int l_elen = pgStream.ReceiveInteger4();
-          ServerErrorMessage l_errorMsg =
-              new ServerErrorMessage(pgStream.ReceiveString(l_elen - 4), logger.getLogLevel());
-
-          if (logger.logDebug()) {
-            logger.debug(" <=BE ErrorMessage(" + l_errorMsg + ")");
-          }
-
-          throw new PSQLException(l_errorMsg);
-
-        case 'N':
-          // Warning
-          int l_nlen = pgStream.ReceiveInteger4();
-          ServerErrorMessage l_warnMsg =
-              new ServerErrorMessage(pgStream.ReceiveString(l_nlen - 4), logger.getLogLevel());
-
-          if (logger.logDebug()) {
-            logger.debug(" <=BE NoticeResponse(" + l_warnMsg + ")");
-          }
-
-          protoConnection.addWarning(new PSQLWarning(l_warnMsg));
-          break;
-
-        case 'S':
-          // ParameterStatus
-          int l_len = pgStream.ReceiveInteger4();
-          String name = pgStream.ReceiveString();
-          String value = pgStream.ReceiveString();
-
-          if (logger.logDebug()) {
-            logger.debug(" <=BE ParameterStatus(" + name + " = " + value + ")");
-          }
-
-          if (name.equals("server_version_num")) {
-            protoConnection.setServerVersionNum(Integer.parseInt(value));
-          }
-          if (name.equals("server_version")) {
-            protoConnection.setServerVersion(value);
-          } else if (name.equals("client_encoding")) {
-            if (!value.equals("UTF8")) {
-              throw new PSQLException(GT.tr("Protocol error.  Session setup failed."),
-                  PSQLState.PROTOCOL_VIOLATION);
-            }
-            pgStream.setEncoding(Encoding.getDatabaseEncoding("UTF8"));
-          } else if (name.equals("standard_conforming_strings")) {
-            if (value.equals("on")) {
-              protoConnection.setStandardConformingStrings(true);
-            } else if (value.equals("off")) {
-              protoConnection.setStandardConformingStrings(false);
-            } else {
-              throw new PSQLException(GT.tr("Protocol error.  Session setup failed."),
-                  PSQLState.PROTOCOL_VIOLATION);
-            }
-          } else if (name.equals("integer_datetimes")) {
-            if (value.equals("on")) {
-              protoConnection.setIntegerDateTimes(true);
-            } else if (value.equals("off")) {
-              protoConnection.setIntegerDateTimes(false);
-            } else {
-              throw new PSQLException(GT.tr("Protocol error.  Session setup failed."),
-                  PSQLState.PROTOCOL_VIOLATION);
-            }
-          }
-
-          break;
-
-        default:
-          if (logger.logDebug()) {
-            logger.debug("invalid message type=" + (char) beresp);
-          }
-          throw new PSQLException(GT.tr("Protocol error.  Session setup failed."),
-              PSQLState.PROTOCOL_VIOLATION);
-      }
-    }
-  }
-
-  private void runInitialQueries(ProtocolConnection protoConnection, Properties info, Logger logger)
+  private void runInitialQueries(QueryExecutor queryExecutor, Properties info, Logger logger)
       throws SQLException {
     String assumeMinServerVersion = PGProperty.ASSUME_MIN_SERVER_VERSION.get(info);
     if (Utils.parseServerVersionStr(assumeMinServerVersion) >= ServerVersion.v9_0.getVersionNum()) {
@@ -803,27 +668,27 @@ private void runInitialQueries(ProtocolConnection protoConnection, Properties in
       return;
     }
 
-    final int dbVersion = protoConnection.getServerVersionNum();
+    final int dbVersion = queryExecutor.getServerVersionNum();
 
     if (dbVersion >= ServerVersion.v9_0.getVersionNum()) {
-      SetupQueryRunner.run(protoConnection, "SET extra_float_digits = 3", false);
+      SetupQueryRunner.run(queryExecutor, "SET extra_float_digits = 3", false);
     }
 
     String appName = PGProperty.APPLICATION_NAME.get(info);
     if (appName != null && dbVersion >= ServerVersion.v9_0.getVersionNum()) {
       StringBuilder sql = new StringBuilder();
       sql.append("SET application_name = '");
-      Utils.escapeLiteral(sql, appName, protoConnection.getStandardConformingStrings());
+      Utils.escapeLiteral(sql, appName, queryExecutor.getStandardConformingStrings());
       sql.append("'");
-      SetupQueryRunner.run(protoConnection, sql.toString(), false);
+      SetupQueryRunner.run(queryExecutor, sql.toString(), false);
     }
 
   }
 
-  private boolean isMaster(ProtocolConnectionImpl protoConnection, Logger logger)
+  private boolean isMaster(QueryExecutor queryExecutor, Logger logger)
       throws SQLException, IOException {
-    byte[][] results = SetupQueryRunner.run(protoConnection, "show transaction_read_only", true);
-    String value = protoConnection.getEncoding().decode(results[0]);
+    byte[][] results = SetupQueryRunner.run(queryExecutor, "show transaction_read_only", true);
+    String value = queryExecutor.getEncoding().decode(results[0]);
     return value.equalsIgnoreCase("off");
   }
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v3/ExecuteRequest.java b/pgjdbc/src/main/java/org/postgresql/core/v3/ExecuteRequest.java
index 0b753d6d0d..9531bc92d6 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v3/ExecuteRequest.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v3/ExecuteRequest.java
@@ -16,9 +16,11 @@
 class ExecuteRequest {
   public final SimpleQuery query;
   public final Portal portal;
+  public final boolean asSimple;
 
-  public ExecuteRequest(SimpleQuery query, Portal portal) {
+  public ExecuteRequest(SimpleQuery query, Portal portal, boolean asSimple) {
     this.query = query;
     this.portal = portal;
+    this.asSimple = asSimple;
   }
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v3/ProtocolConnectionImpl.java b/pgjdbc/src/main/java/org/postgresql/core/v3/ProtocolConnectionImpl.java
deleted file mode 100644
index 3ea152e879..0000000000
--- a/pgjdbc/src/main/java/org/postgresql/core/v3/ProtocolConnectionImpl.java
+++ /dev/null
@@ -1,299 +0,0 @@
-/*-------------------------------------------------------------------------
-*
-* Copyright (c) 2004-2014, PostgreSQL Global Development Group
-* Copyright (c) 2004, Open Cloud Limited.
-*
-*
-*-------------------------------------------------------------------------
-*/
-
-package org.postgresql.core.v3;
-
-import org.postgresql.PGNotification;
-import org.postgresql.core.Encoding;
-import org.postgresql.core.Logger;
-import org.postgresql.core.PGStream;
-import org.postgresql.core.ProtocolConnection;
-import org.postgresql.core.QueryExecutor;
-import org.postgresql.core.Utils;
-import org.postgresql.util.HostSpec;
-
-import java.io.IOException;
-import java.sql.SQLException;
-import java.sql.SQLWarning;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.Properties;
-import java.util.Set;
-import java.util.TimeZone;
-
-
-/**
- * ProtocolConnection implementation for the V3 protocol.
- *
- * @author Oliver Jowett (oliver@opencloud.com)
- */
-class ProtocolConnectionImpl implements ProtocolConnection {
-  ProtocolConnectionImpl(PGStream pgStream, String user, String database, Properties info,
-      Logger logger, int cancelSignalTimeout) {
-    this.pgStream = pgStream;
-    this.user = user;
-    this.database = database;
-    this.logger = logger;
-    this.executor = new QueryExecutorImpl(this, pgStream, info, logger);
-    // default value for server versions that don't report standard_conforming_strings
-    this.standardConformingStrings = false;
-    this.cancelSignalTimeout = cancelSignalTimeout;
-  }
-
-  public HostSpec getHostSpec() {
-    return pgStream.getHostSpec();
-  }
-
-  public String getUser() {
-    return user;
-  }
-
-  public String getDatabase() {
-    return database;
-  }
-
-  public String getServerVersion() {
-    return serverVersion;
-  }
-
-  public int getServerVersionNum() {
-    if (serverVersionNum != 0) {
-      return serverVersionNum;
-    }
-    return serverVersionNum = Utils.parseServerVersionStr(serverVersion);
-  }
-
-  public synchronized boolean getStandardConformingStrings() {
-    return standardConformingStrings;
-  }
-
-  public synchronized int getTransactionState() {
-    return transactionState;
-  }
-
-  public synchronized PGNotification[] getNotifications() throws SQLException {
-    PGNotification[] array = notifications.toArray(new PGNotification[notifications.size()]);
-    notifications.clear();
-    return array;
-  }
-
-  public synchronized SQLWarning getWarnings() {
-    SQLWarning chain = warnings;
-    warnings = null;
-    return chain;
-  }
-
-  public QueryExecutor getQueryExecutor() {
-    return executor;
-  }
-
-  public void sendQueryCancel() throws SQLException {
-    PGStream cancelStream = null;
-
-    // Now we need to construct and send a cancel packet
-    try {
-      if (logger.logDebug()) {
-        logger.debug(" FE=> CancelRequest(pid=" + cancelPid + ",ckey=" + cancelKey + ")");
-      }
-
-      cancelStream =
-          new PGStream(pgStream.getSocketFactory(), pgStream.getHostSpec(), cancelSignalTimeout);
-      if (cancelSignalTimeout > 0) {
-        cancelStream.getSocket().setSoTimeout(cancelSignalTimeout);
-      }
-      cancelStream.SendInteger4(16);
-      cancelStream.SendInteger2(1234);
-      cancelStream.SendInteger2(5678);
-      cancelStream.SendInteger4(cancelPid);
-      cancelStream.SendInteger4(cancelKey);
-      cancelStream.flush();
-      cancelStream.ReceiveEOF();
-    } catch (IOException e) {
-      // Safe to ignore.
-      if (logger.logDebug()) {
-        logger.debug("Ignoring exception on cancel request:", e);
-      }
-    } finally {
-      if (cancelStream != null) {
-        try {
-          cancelStream.close();
-        } catch (IOException e) {
-          // Ignored.
-        }
-      }
-    }
-  }
-
-  public void close() {
-    if (closed) {
-      return;
-    }
-
-    try {
-      if (logger.logDebug()) {
-        logger.debug(" FE=> Terminate");
-      }
-
-      pgStream.SendChar('X');
-      pgStream.SendInteger4(4);
-      pgStream.flush();
-      pgStream.close();
-    } catch (IOException ioe) {
-      // Forget it.
-      if (logger.logDebug()) {
-        logger.debug("Discarding IOException on close:", ioe);
-      }
-    }
-
-    closed = true;
-  }
-
-  public Encoding getEncoding() {
-    return pgStream.getEncoding();
-  }
-
-  public boolean isClosed() {
-    return closed;
-  }
-
-  //
-  // Package-private accessors called during connection setup
-  //
-
-  void setServerVersion(String serverVersion) {
-    this.serverVersion = serverVersion;
-  }
-
-  void setServerVersionNum(int serverVersionNum) {
-    this.serverVersionNum = serverVersionNum;
-  }
-
-  void setBackendKeyData(int cancelPid, int cancelKey) {
-    this.cancelPid = cancelPid;
-    this.cancelKey = cancelKey;
-  }
-
-  //
-  // Package-private accessors called by the query executor
-  //
-
-  synchronized void addWarning(SQLWarning newWarning) {
-    if (warnings == null) {
-      warnings = newWarning;
-    } else {
-      warnings.setNextWarning(newWarning);
-    }
-  }
-
-  synchronized void addNotification(PGNotification notification) {
-    notifications.add(notification);
-  }
-
-  synchronized void setTransactionState(int state) {
-    transactionState = state;
-  }
-
-  synchronized void setStandardConformingStrings(boolean value) {
-    standardConformingStrings = value;
-  }
-
-  public int getProtocolVersion() {
-    return 3;
-  }
-
-  public int getBackendPID() {
-    return cancelPid;
-  }
-
-  public boolean useBinaryForReceive(int oid) {
-    return useBinaryForOids.contains(oid);
-  }
-
-  public void setBinaryReceiveOids(Set<Integer> oids) {
-    useBinaryForOids.clear();
-    useBinaryForOids.addAll(oids);
-  }
-
-  public void setIntegerDateTimes(boolean state) {
-    integerDateTimes = state;
-  }
-
-  public boolean getIntegerDateTimes() {
-    return integerDateTimes;
-  }
-
-  public void abort() {
-    try {
-      pgStream.getSocket().close();
-    } catch (IOException e) {
-      // ignore
-    }
-    closed = true;
-  }
-
-  public void setTimeZone(TimeZone timeZone) {
-    this.timeZone = timeZone;
-  }
-
-  @Override
-  public TimeZone getTimeZone() {
-    return timeZone;
-  }
-
-  void setApplicationName(String applicationName) {
-    this.applicationName = applicationName;
-  }
-
-  @Override
-  public String getApplicationName() {
-    if (applicationName == null) {
-      return "";
-    }
-    return applicationName;
-  }
-
-  /**
-   * True if server uses integers for date and time fields. False if server uses double.
-   */
-  private boolean integerDateTimes;
-
-  /**
-   * Bit set that has a bit set for each oid which should be received using binary format.
-   */
-  private final Set<Integer> useBinaryForOids = new HashSet<Integer>();
-  private String serverVersion;
-  private int serverVersionNum = 0;
-  private int cancelPid;
-  private int cancelKey;
-
-  private boolean standardConformingStrings;
-  private int transactionState;
-  private SQLWarning warnings;
-
-  private boolean closed = false;
-
-  private final ArrayList<PGNotification> notifications = new ArrayList<PGNotification>();
-
-  private final PGStream pgStream;
-  private final String user;
-  private final String database;
-  private final QueryExecutorImpl executor;
-  private final Logger logger;
-  private final int cancelSignalTimeout;
-
-  /**
-   * TimeZone of the current connection (TimeZone backend parameter)
-   */
-  private TimeZone timeZone;
-
-  /**
-   * application_name connection property
-   */
-  private String applicationName;
-}
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v3/QueryExecutorImpl.java b/pgjdbc/src/main/java/org/postgresql/core/v3/QueryExecutorImpl.java
index 8e31196d68..45143df076 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v3/QueryExecutorImpl.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v3/QueryExecutorImpl.java
@@ -11,6 +11,8 @@
 
 import org.postgresql.PGProperty;
 import org.postgresql.copy.CopyOperation;
+import org.postgresql.core.Encoding;
+import org.postgresql.core.EncodingPredictor;
 import org.postgresql.core.Field;
 import org.postgresql.core.Logger;
 import org.postgresql.core.NativeQuery;
@@ -19,14 +21,18 @@
 import org.postgresql.core.PGStream;
 import org.postgresql.core.ParameterList;
 import org.postgresql.core.Parser;
-import org.postgresql.core.ProtocolConnection;
 import org.postgresql.core.Query;
 import org.postgresql.core.QueryExecutor;
+import org.postgresql.core.QueryExecutorBase;
 import org.postgresql.core.ResultCursor;
 import org.postgresql.core.ResultHandler;
+import org.postgresql.core.ResultHandlerBase;
+import org.postgresql.core.ResultHandlerDelegate;
 import org.postgresql.core.SqlCommand;
 import org.postgresql.core.SqlCommandType;
+import org.postgresql.core.TransactionState;
 import org.postgresql.core.Utils;
+import org.postgresql.jdbc.AutoSave;
 import org.postgresql.jdbc.BatchResultHandler;
 import org.postgresql.jdbc.TimestampUtils;
 import org.postgresql.util.GT;
@@ -46,21 +52,68 @@
 import java.util.ArrayList;
 import java.util.Deque;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Properties;
+import java.util.Set;
+import java.util.TimeZone;
 
 /**
  * QueryExecutor implementation for the V3 protocol.
  */
-public class QueryExecutorImpl implements QueryExecutor {
-  public QueryExecutorImpl(ProtocolConnectionImpl protoConnection, PGStream pgStream,
-      Properties info, Logger logger) {
-    this.protoConnection = protoConnection;
-    this.pgStream = pgStream;
-    this.logger = logger;
+public class QueryExecutorImpl extends QueryExecutorBase {
+  /**
+   * TimeZone of the current connection (TimeZone backend parameter)
+   */
+  private TimeZone timeZone;
+
+  /**
+   * application_name connection property
+   */
+  private String applicationName;
+
+  /**
+   * True if server uses integers for date and time fields. False if server uses double.
+   */
+  private boolean integerDateTimes;
+
+  /**
+   * Bit set that has a bit set for each oid which should be received using binary format.
+   */
+  private final Set<Integer> useBinaryReceiveForOids = new HashSet<Integer>();
+
+  /**
+   * Bit set that has a bit set for each oid which should be sent using binary format.
+   */
+  private final Set<Integer> useBinarySendForOids = new HashSet<Integer>();
+
+  /**
+   * This is a fake query object so processResults can distinguish "ReadyForQuery" messages
+   * from Sync messages vs from simple execute (aka 'Q')
+   */
+  private final SimpleQuery sync = (SimpleQuery) createQuery("SYNC", false, true).query;
+
+  private short deallocateEpoch;
+
+  /**
+   * This caches the latest observed {@code set search_path} query so the reset of prepared
+   * statement cache can be skipped if using repeated calls for the same {@code set search_path}
+   * value.
+   */
+  private String lastSetSearchPathQuery;
+
+  public QueryExecutorImpl(PGStream pgStream, String user, String database,
+      int cancelSignalTimeout, Properties info, Logger logger) throws SQLException, IOException {
+    super(logger, pgStream, user, database, cancelSignalTimeout, info);
 
     this.allowEncodingChanges = PGProperty.ALLOW_ENCODING_CHANGES.getBoolean(info);
-    this.allowReWriteBatchedInserts = PGProperty.REWRITE_BATCHED_INSERTS.getBoolean(info);
+
+    readStartupMessages();
+  }
+
+  @Override
+  public int getProtocolVersion() {
+    return 3;
   }
 
   /**
@@ -137,34 +190,31 @@ boolean hasLock(Object holder) {
   // Query parsing
   //
 
-  public Query createSimpleQuery(String sql, boolean autocommit) {
-    return parseQuery(sql, false, autocommit);
+  public Query createSimpleQuery(String sql) throws SQLException {
+    List<NativeQuery> queries = Parser.parseJdbcSql(sql,
+        getStandardConformingStrings(), false, true,
+        isReWriteBatchedInsertsEnabled());
+    return wrap(queries);
   }
 
-  public Query createParameterizedQuery(String sql, boolean autocommit) {
-    return parseQuery(sql, true, autocommit);
-  }
-
-  private Query parseQuery(String query, boolean withParameters, boolean autocommit) {
-
-    List<NativeQuery> queries = Parser.parseJdbcSql(query,
-        protoConnection.getStandardConformingStrings(), withParameters, true,
-        autocommit, allowReWriteBatchedInserts);
+  @Override
+  public Query wrap(List<NativeQuery> queries) {
     if (queries.isEmpty()) {
       // Empty query
       return EMPTY_QUERY;
     }
     if (queries.size() == 1) {
       NativeQuery firstQuery = queries.get(0);
-      if (allowReWriteBatchedInserts && firstQuery.getCommand().isBatchedReWriteCompatible()) {
+      if (isReWriteBatchedInsertsEnabled()
+          && firstQuery.getCommand().isBatchedReWriteCompatible()) {
         int valuesBraceOpenPosition =
             firstQuery.getCommand().getBatchRewriteValuesBraceOpenPosition();
         int valuesBraceClosePosition =
             firstQuery.getCommand().getBatchRewriteValuesBraceClosePosition();
-        return new BatchedQuery(firstQuery, protoConnection, valuesBraceOpenPosition,
-            valuesBraceClosePosition);
+        return new BatchedQuery(firstQuery, this, valuesBraceOpenPosition,
+            valuesBraceClosePosition, isColumnSanitiserDisabled());
       } else {
-        return new SimpleQuery(firstQuery, protoConnection);
+        return new SimpleQuery(firstQuery, this, isColumnSanitiserDisabled());
       }
     }
 
@@ -175,7 +225,7 @@ private Query parseQuery(String query, boolean withParameters, boolean autocommi
     for (int i = 0; i < queries.size(); ++i) {
       NativeQuery nativeQuery = queries.get(i);
       offsets[i] = offset;
-      subqueries[i] = new SimpleQuery(nativeQuery, protoConnection);
+      subqueries[i] = new SimpleQuery(nativeQuery, this, isColumnSanitiserDisabled());
       offset += nativeQuery.bindPositions.length;
     }
 
@@ -186,6 +236,17 @@ private Query parseQuery(String query, boolean withParameters, boolean autocommi
   // Query execution
   //
 
+  private int updateQueryMode(int flags) {
+    switch (getPreferQueryMode()) {
+      case SIMPLE:
+        return flags | QUERY_EXECUTE_AS_SIMPLE;
+      case EXTENDED:
+        return flags & ~QUERY_EXECUTE_AS_SIMPLE;
+      default:
+        return flags;
+    }
+  }
+
   public synchronized void execute(Query query, ParameterList parameters, ResultHandler handler,
       int maxRows, int fetchSize, int flags) throws SQLException {
     waitOnLock();
@@ -198,6 +259,8 @@ public synchronized void execute(Query query, ParameterList parameters, ResultHa
       parameters = SimpleQuery.NO_PARAMETERS;
     }
 
+    flags = updateQueryMode(flags);
+
     boolean describeOnly = (QUERY_DESCRIBE_ONLY & flags) != 0;
 
     ((V3ParameterList) parameters).convertFunctionOutParameters();
@@ -207,13 +270,19 @@ public synchronized void execute(Query query, ParameterList parameters, ResultHa
       ((V3ParameterList) parameters).checkAllParametersSet();
     }
 
+    boolean autosave = false;
     try {
       try {
         handler = sendQueryPreamble(handler, flags);
-        ErrorTrackingResultHandler trackingHandler = new ErrorTrackingResultHandler(handler);
-        sendQuery((V3Query) query, (V3ParameterList) parameters, maxRows, fetchSize, flags,
-            trackingHandler, null);
-        sendSync();
+        autosave = sendAutomaticSavepoint(query, flags);
+        sendQuery(query, (V3ParameterList) parameters, maxRows, fetchSize, flags,
+            handler, null);
+        if ((flags & QueryExecutor.QUERY_EXECUTE_AS_SIMPLE) != 0) {
+          // Sync message is not required for 'Q' execution as 'Q' ends with ReadyForQuery message
+          // on its own
+        } else {
+          sendSync();
+        }
         processResults(handler, flags);
         estimatedReceiveBufferBytes = 0;
       } catch (PGBindException se) {
@@ -239,13 +308,53 @@ public synchronized void execute(Query query, ParameterList parameters, ResultHa
                 PSQLState.INVALID_PARAMETER_VALUE, se.getIOException()));
       }
     } catch (IOException e) {
-      protoConnection.abort();
+      abort();
       handler.handleError(
           new PSQLException(GT.tr("An I/O error occurred while sending to the backend."),
               PSQLState.CONNECTION_FAILURE, e));
     }
 
-    handler.handleCompletion();
+    try {
+      handler.handleCompletion();
+    } catch (SQLException e) {
+      rollbackIfRequired(autosave, e);
+    }
+  }
+
+  private boolean sendAutomaticSavepoint(Query query, int flags) throws IOException {
+    if (((flags & QueryExecutor.QUERY_SUPPRESS_BEGIN) == 0
+        || getTransactionState() == TransactionState.OPEN)
+        && query != restoreToAutoSave
+        && getAutoSave() != AutoSave.NEVER
+        // If query has no resulting fields, it cannot fail with 'cached plan must not change result type'
+        // thus no need to set a safepoint before such query
+        && (getAutoSave() == AutoSave.ALWAYS
+        // If CompositeQuery is observed, just assume it might fail and set the savepoint
+        || !(query instanceof SimpleQuery)
+        || ((SimpleQuery) query).getFields() != null)) {
+      sendOneQuery(autoSaveQuery, SimpleQuery.NO_PARAMETERS, 1, 0,
+          updateQueryMode(QUERY_NO_RESULTS | QUERY_NO_METADATA)
+              // PostgreSQL does not support bind, exec, simple, sync message flow,
+              // so we force autosavepoint to use simple if the main query is using simple
+              | (flags & QueryExecutor.QUERY_EXECUTE_AS_SIMPLE));
+      return true;
+    }
+    return false;
+  }
+
+  private void rollbackIfRequired(boolean autosave, SQLException e) throws SQLException {
+    if (autosave
+        && getTransactionState() == TransactionState.FAILED
+        && (getAutoSave() == AutoSave.ALWAYS || willHealOnRetry(e))) {
+      try {
+        execute(restoreToAutoSave, SimpleQuery.NO_PARAMETERS, new ResultHandlerDelegate(null),
+            1, 0, updateQueryMode(QUERY_NO_RESULTS | QUERY_NO_METADATA));
+      } catch (SQLException e2) {
+        // That's O(N), sorry
+        e.setNextException(e2);
+      }
+    }
+    throw e;
   }
 
   // Deadlock avoidance:
@@ -298,42 +407,6 @@ public synchronized void execute(Query query, ParameterList parameters, ResultHa
   private static final int MAX_BUFFERED_RECV_BYTES = 64000;
   private static final int NODATA_QUERY_RESPONSE_SIZE_BYTES = 250;
 
-  // Helper handler that tracks error status.
-  private static class ErrorTrackingResultHandler implements ResultHandler {
-    private final ResultHandler delegateHandler;
-    private boolean sawError = false;
-
-    ErrorTrackingResultHandler(ResultHandler delegateHandler) {
-      this.delegateHandler = delegateHandler;
-    }
-
-    public void handleResultRows(Query fromQuery, Field[] fields, List<byte[][]> tuples,
-        ResultCursor cursor) {
-      delegateHandler.handleResultRows(fromQuery, fields, tuples, cursor);
-    }
-
-    public void handleCommandStatus(String status, int updateCount, long insertOID) {
-      delegateHandler.handleCommandStatus(status, updateCount, insertOID);
-    }
-
-    public void handleWarning(SQLWarning warning) {
-      delegateHandler.handleWarning(warning);
-    }
-
-    public void handleError(SQLException error) {
-      sawError = true;
-      delegateHandler.handleError(error);
-    }
-
-    public void handleCompletion() throws SQLException {
-      delegateHandler.handleCompletion();
-    }
-
-    boolean hasErrors() {
-      return sawError;
-    }
-  }
-
   public synchronized void execute(Query[] queries, ParameterList[] parameterLists,
       BatchResultHandler batchHandler, int maxRows, int fetchSize, int flags) throws SQLException {
     waitOnLock();
@@ -342,6 +415,8 @@ public synchronized void execute(Query[] queries, ParameterList[] parameterLists
           + maxRows + ", fetchSize=" + fetchSize + ", flags=" + flags);
     }
 
+    flags = updateQueryMode(flags);
+
     boolean describeOnly = (QUERY_DESCRIBE_ONLY & flags) != 0;
     // Check parameters and resolve OIDs.
     if (!describeOnly) {
@@ -352,39 +427,49 @@ public synchronized void execute(Query[] queries, ParameterList[] parameterLists
       }
     }
 
+    boolean autosave = false;
     ResultHandler handler = batchHandler;
     try {
       handler = sendQueryPreamble(batchHandler, flags);
-      ErrorTrackingResultHandler trackingHandler = new ErrorTrackingResultHandler(handler);
+      autosave = sendAutomaticSavepoint(queries[0], flags);
       estimatedReceiveBufferBytes = 0;
 
       for (int i = 0; i < queries.length; ++i) {
-        V3Query query = (V3Query) queries[i];
+        Query query = queries[i];
         V3ParameterList parameters = (V3ParameterList) parameterLists[i];
         if (parameters == null) {
           parameters = SimpleQuery.NO_PARAMETERS;
         }
 
-        sendQuery(query, parameters, maxRows, fetchSize, flags, trackingHandler, batchHandler);
+        sendQuery(query, parameters, maxRows, fetchSize, flags, handler, batchHandler);
 
-        if (trackingHandler.hasErrors()) {
+        if (handler.getException() != null) {
           break;
         }
       }
 
-      if (!trackingHandler.hasErrors()) {
-        sendSync();
+      if (handler.getException() == null) {
+        if ((flags & QueryExecutor.QUERY_EXECUTE_AS_SIMPLE) != 0) {
+          // Sync message is not required for 'Q' execution as 'Q' ends with ReadyForQuery message
+          // on its own
+        } else {
+          sendSync();
+        }
         processResults(handler, flags);
         estimatedReceiveBufferBytes = 0;
       }
     } catch (IOException e) {
-      protoConnection.abort();
+      abort();
       handler.handleError(
           new PSQLException(GT.tr("An I/O error occurred while sending to the backend."),
               PSQLState.CONNECTION_FAILURE, e));
     }
 
-    handler.handleCompletion();
+    try {
+      handler.handleCompletion();
+    } catch (SQLException e) {
+      rollbackIfRequired(autosave, e);
+    }
   }
 
   private ResultHandler sendQueryPreamble(final ResultHandler delegateHandler, int flags)
@@ -395,7 +480,7 @@ private ResultHandler sendQueryPreamble(final ResultHandler delegateHandler, int
 
     // Send BEGIN on first statement in transaction.
     if ((flags & QueryExecutor.QUERY_SUPPRESS_BEGIN) != 0
-        || protoConnection.getTransactionState() != ProtocolConnection.TRANSACTION_IDLE) {
+        || getTransactionState() != TransactionState.IDLE) {
       return delegateHandler;
     }
 
@@ -403,16 +488,21 @@ private ResultHandler sendQueryPreamble(final ResultHandler delegateHandler, int
     if ((flags & QueryExecutor.QUERY_ONESHOT) != 0) {
       beginFlags |= QueryExecutor.QUERY_ONESHOT;
     }
+
+    beginFlags |= QueryExecutor.QUERY_EXECUTE_AS_SIMPLE;
+
+    beginFlags = updateQueryMode(beginFlags);
+
     sendOneQuery(beginTransactionQuery, SimpleQuery.NO_PARAMETERS, 0, 0, beginFlags);
 
     // Insert a handler that intercepts the BEGIN.
-    return new ResultHandler() {
+    return new ResultHandlerDelegate(delegateHandler) {
       private boolean sawBegin = false;
 
       public void handleResultRows(Query fromQuery, Field[] fields, List<byte[][]> tuples,
           ResultCursor cursor) {
         if (sawBegin) {
-          delegateHandler.handleResultRows(fromQuery, fields, tuples, cursor);
+          super.handleResultRows(fromQuery, fields, tuples, cursor);
         }
       }
 
@@ -424,21 +514,9 @@ public void handleCommandStatus(String status, int updateCount, long insertOID)
                 PSQLState.PROTOCOL_VIOLATION));
           }
         } else {
-          delegateHandler.handleCommandStatus(status, updateCount, insertOID);
+          super.handleCommandStatus(status, updateCount, insertOID);
         }
       }
-
-      public void handleWarning(SQLWarning warning) {
-        delegateHandler.handleWarning(warning);
-      }
-
-      public void handleError(SQLException error) {
-        delegateHandler.handleError(error);
-      }
-
-      public void handleCompletion() throws SQLException {
-        delegateHandler.handleCompletion();
-      }
     };
   }
 
@@ -456,26 +534,21 @@ public synchronized byte[] fastpathCall(int fnid, ParameterList parameters, bool
       sendFastpathCall(fnid, (SimpleParameterList) parameters);
       return receiveFastpathResult();
     } catch (IOException ioe) {
-      protoConnection.abort();
+      abort();
       throw new PSQLException(GT.tr("An I/O error occurred while sending to the backend."),
           PSQLState.CONNECTION_FAILURE, ioe);
     }
   }
 
   public void doSubprotocolBegin() throws SQLException {
-    if (protoConnection.getTransactionState() == ProtocolConnection.TRANSACTION_IDLE) {
+    if (getTransactionState() == TransactionState.IDLE) {
 
       if (logger.logDebug()) {
         logger.debug("Issuing BEGIN before fastpath or copy call.");
       }
 
-      ResultHandler handler = new ResultHandler() {
+      ResultHandler handler = new ResultHandlerBase() {
         private boolean sawBegin = false;
-        private SQLException sqle = null;
-
-        public void handleResultRows(Query fromQuery, Field[] fields, List<byte[][]> tuples,
-            ResultCursor cursor) {
-        }
 
         public void handleCommandStatus(String status, int updateCount, long insertOID) {
           if (!sawBegin) {
@@ -498,20 +571,6 @@ public void handleWarning(SQLWarning warning) {
           // them errors.
           handleError(warning);
         }
-
-        public void handleError(SQLException error) {
-          if (sqle == null) {
-            sqle = error;
-          } else {
-            sqle.setNextException(error);
-          }
-        }
-
-        public void handleCompletion() throws SQLException {
-          if (sqle != null) {
-            throw sqle;
-          }
-        }
       };
 
       try {
@@ -529,7 +588,7 @@ public void handleCompletion() throws SQLException {
   }
 
   public ParameterList createFastpathParameters(int count) {
-    return new SimpleParameterList(count, protoConnection);
+    return new SimpleParameterList(count, this);
   }
 
   private void sendFastpathCall(int fnid, SimpleParameterList params)
@@ -556,36 +615,36 @@ private void sendFastpathCall(int fnid, SimpleParameterList params)
     }
 
 
-    pgStream.SendChar('F');
-    pgStream.SendInteger4(4 + 4 + 2 + 2 * paramCount + 2 + encodedSize + 2);
-    pgStream.SendInteger4(fnid);
-    pgStream.SendInteger2(paramCount);
+    pgStream.sendChar('F');
+    pgStream.sendInteger4(4 + 4 + 2 + 2 * paramCount + 2 + encodedSize + 2);
+    pgStream.sendInteger4(fnid);
+    pgStream.sendInteger2(paramCount);
     for (int i = 1; i <= paramCount; ++i) {
-      pgStream.SendInteger2(params.isBinary(i) ? 1 : 0);
+      pgStream.sendInteger2(params.isBinary(i) ? 1 : 0);
     }
-    pgStream.SendInteger2(paramCount);
+    pgStream.sendInteger2(paramCount);
     for (int i = 1; i <= paramCount; i++) {
       if (params.isNull(i)) {
-        pgStream.SendInteger4(-1);
+        pgStream.sendInteger4(-1);
       } else {
-        pgStream.SendInteger4(params.getV3Length(i)); // Parameter size
+        pgStream.sendInteger4(params.getV3Length(i)); // Parameter size
         params.writeV3Value(i, pgStream);
       }
     }
-    pgStream.SendInteger2(1); // Binary result format
+    pgStream.sendInteger2(1); // Binary result format
     pgStream.flush();
   }
 
   public synchronized void processNotifies() throws SQLException {
     waitOnLock();
     // Asynchronous notifies only arrive when we are not in a transaction
-    if (protoConnection.getTransactionState() != ProtocolConnection.TRANSACTION_IDLE) {
+    if (getTransactionState() != TransactionState.IDLE) {
       return;
     }
 
     try {
       while (pgStream.hasMessagePending()) {
-        int c = pgStream.ReceiveChar();
+        int c = pgStream.receiveChar();
         switch (c) {
           case 'A': // Asynchronous Notify
             receiveAsyncNotify();
@@ -595,7 +654,7 @@ public synchronized void processNotifies() throws SQLException {
             throw receiveErrorResponse();
           case 'N': // Notice Response (warnings / info)
             SQLWarning warning = receiveNoticeResponse();
-            protoConnection.addWarning(warning);
+            addWarning(warning);
             break;
           default:
             throw new PSQLException(GT.tr("Unknown Response Type {0}.", (char) c),
@@ -614,7 +673,7 @@ private byte[] receiveFastpathResult() throws IOException, SQLException {
     byte[] returnValue = null;
 
     while (!endQuery) {
-      int c = pgStream.ReceiveChar();
+      int c = pgStream.receiveChar();
       switch (c) {
         case 'A': // Asynchronous Notify
           receiveAsyncNotify();
@@ -633,7 +692,7 @@ private byte[] receiveFastpathResult() throws IOException, SQLException {
 
         case 'N': // Notice Response (warnings / info)
           SQLWarning warning = receiveNoticeResponse();
-          protoConnection.addWarning(warning);
+          addWarning(warning);
           break;
 
         case 'Z': // Ready For Query (eventual response to Sync)
@@ -642,8 +701,8 @@ private byte[] receiveFastpathResult() throws IOException, SQLException {
           break;
 
         case 'V': // FunctionCallResponse
-          int msgLen = pgStream.ReceiveInteger4();
-          int valueLen = pgStream.ReceiveInteger4();
+          int msgLen = pgStream.receiveInteger4();
+          int valueLen = pgStream.receiveInteger4();
 
           if (logger.logDebug()) {
             logger.debug(" <=BE FunctionCallResponse(" + valueLen + " bytes)");
@@ -651,7 +710,7 @@ private byte[] receiveFastpathResult() throws IOException, SQLException {
 
           if (valueLen != -1) {
             byte buf[] = new byte[valueLen];
-            pgStream.Receive(buf, 0, valueLen);
+            pgStream.receive(buf, 0, valueLen);
             returnValue = buf;
           }
 
@@ -696,10 +755,10 @@ public synchronized CopyOperation startCopy(String sql, boolean suppressBegin)
         logger.debug(" FE=> Query(CopyStart)");
       }
 
-      pgStream.SendChar('Q');
-      pgStream.SendInteger4(buf.length + 4 + 1);
-      pgStream.Send(buf);
-      pgStream.SendChar(0);
+      pgStream.sendChar('Q');
+      pgStream.sendInteger4(buf.length + 4 + 1);
+      pgStream.send(buf);
+      pgStream.sendChar(0);
       pgStream.flush();
 
       return processCopyResults(null, true);
@@ -719,13 +778,13 @@ public synchronized CopyOperation startCopy(String sql, boolean suppressBegin)
    * @throws IOException on database connection failure
    */
   private synchronized void initCopy(CopyOperationImpl op) throws SQLException, IOException {
-    pgStream.ReceiveInteger4(); // length not used
-    int rowFormat = pgStream.ReceiveChar();
-    int numFields = pgStream.ReceiveInteger2();
+    pgStream.receiveInteger4(); // length not used
+    int rowFormat = pgStream.receiveChar();
+    int numFields = pgStream.receiveInteger2();
     int[] fieldFormats = new int[numFields];
 
     for (int i = 0; i < numFields; i++) {
-      fieldFormats[i] = pgStream.ReceiveInteger2();
+      fieldFormats[i] = pgStream.receiveInteger2();
     }
 
     lock(op);
@@ -754,10 +813,10 @@ public void cancelCopy(CopyOperationImpl op) throws SQLException {
             logger.debug("FE => CopyFail");
           }
           final byte[] msg = Utils.encodeUTF8("Copy cancel requested");
-          pgStream.SendChar('f'); // CopyFail
-          pgStream.SendInteger4(5 + msg.length);
-          pgStream.Send(msg);
-          pgStream.SendChar(0);
+          pgStream.sendChar('f'); // CopyFail
+          pgStream.sendInteger4(5 + msg.length);
+          pgStream.send(msg);
+          pgStream.sendChar(0);
           pgStream.flush();
           do {
             try {
@@ -777,7 +836,7 @@ public void cancelCopy(CopyOperationImpl op) throws SQLException {
           } while (hasLock(op));
         }
       } else if (op instanceof CopyOutImpl) {
-        protoConnection.sendQueryCancel();
+        sendQueryCancel();
       }
 
     } catch (IOException ioe) {
@@ -824,8 +883,8 @@ public synchronized long endCopy(CopyInImpl op) throws SQLException {
         logger.debug(" FE=> CopyDone");
       }
 
-      pgStream.SendChar('c'); // CopyDone
-      pgStream.SendInteger4(4);
+      pgStream.sendChar('c'); // CopyDone
+      pgStream.sendInteger4(4);
       pgStream.flush();
 
       processCopyResults(op, true);
@@ -858,9 +917,9 @@ public synchronized void writeToCopy(CopyInImpl op, byte[] data, int off, int si
     }
 
     try {
-      pgStream.SendChar('d');
-      pgStream.SendInteger4(siz + 4);
-      pgStream.Send(data, off, siz);
+      pgStream.sendChar('d');
+      pgStream.sendInteger4(siz + 4);
+      pgStream.send(data, off, siz);
 
       processCopyResults(op, false); // collect any pending notifications without blocking
     } catch (IOException ioe) {
@@ -934,7 +993,7 @@ CopyOperationImpl processCopyResults(CopyOperationImpl op, boolean block)
       // until we actually are done with the copy.
       //
       if (!block) {
-        int c = pgStream.PeekChar();
+        int c = pgStream.peekChar();
         if (c == 'C') {
           // CommandComplete
           if (logger.logDebug()) {
@@ -944,7 +1003,7 @@ CopyOperationImpl processCopyResults(CopyOperationImpl op, boolean block)
         }
       }
 
-      int c = pgStream.ReceiveChar();
+      int c = pgStream.receiveChar();
       switch (c) {
 
         case 'A': // Asynchronous Notify
@@ -962,7 +1021,7 @@ CopyOperationImpl processCopyResults(CopyOperationImpl op, boolean block)
             logger.debug(" <=BE Notification while copying");
           }
 
-          protoConnection.addWarning(receiveNoticeResponse());
+          addWarning(receiveNoticeResponse());
           break;
 
         case 'C': // Command Complete
@@ -1030,8 +1089,8 @@ CopyOperationImpl processCopyResults(CopyOperationImpl op, boolean block)
             logger.debug(" <=BE CopyData");
           }
 
-          len = pgStream.ReceiveInteger4() - 4;
-          byte[] buf = pgStream.Receive(len);
+          len = pgStream.receiveInteger4() - 4;
+          byte[] buf = pgStream.receive(len);
           if (op == null) {
             error = new PSQLException(GT.tr("Got CopyData without an active copy operation"),
                 PSQLState.OBJECT_NOT_IN_STATE);
@@ -1051,9 +1110,9 @@ CopyOperationImpl processCopyResults(CopyOperationImpl op, boolean block)
             logger.debug(" <=BE CopyDone");
           }
 
-          len = pgStream.ReceiveInteger4() - 4;
+          len = pgStream.receiveInteger4() - 4;
           if (len > 0) {
-            pgStream.Receive(len); // not in specification; should never appear
+            pgStream.receive(len); // not in specification; should never appear
           }
 
           if (!(op instanceof CopyOutImpl)) {
@@ -1066,16 +1125,16 @@ CopyOperationImpl processCopyResults(CopyOperationImpl op, boolean block)
           break;
         case 'S': // Parameter Status
         {
-          int l_len = pgStream.ReceiveInteger4();
-          String name = pgStream.ReceiveString();
-          String value = pgStream.ReceiveString();
+          int l_len = pgStream.receiveInteger4();
+          String name = pgStream.receiveString();
+          String value = pgStream.receiveString();
           if (logger.logDebug()) {
             logger.debug(" <=BE ParameterStatus(" + name + " = " + value + ")");
           }
 
           if (name.equals("client_encoding") && !value.equalsIgnoreCase("UTF8")
               && !allowEncodingChanges) {
-            protoConnection.close(); // we're screwed now; we can't trust any subsequent string.
+            close(); // we're screwed now; we can't trust any subsequent string.
             error = new PSQLException(GT.tr(
                 "The server''s client_encoding parameter was changed to {0}. The JDBC driver requires client_encoding to be UTF8 for correct operation.",
                 value), PSQLState.CONNECTION_FAILURE);
@@ -1083,7 +1142,7 @@ CopyOperationImpl processCopyResults(CopyOperationImpl op, boolean block)
           }
 
           if (name.equals("DateStyle") && !value.startsWith("ISO,")) {
-            protoConnection.close(); // we're screwed now; we can't trust any subsequent date.
+            close(); // we're screwed now; we can't trust any subsequent date.
             error = new PSQLException(GT.tr(
                 "The server''s DateStyle parameter was changed to {0}. The JDBC driver requires DateStyle to begin with ISO for correct operation.",
                 value), PSQLState.CONNECTION_FAILURE);
@@ -1092,11 +1151,11 @@ CopyOperationImpl processCopyResults(CopyOperationImpl op, boolean block)
 
           if (name.equals("standard_conforming_strings")) {
             if (value.equals("on")) {
-              protoConnection.setStandardConformingStrings(true);
+              setStandardConformingStrings(true);
             } else if (value.equals("off")) {
-              protoConnection.setStandardConformingStrings(false);
+              setStandardConformingStrings(false);
             } else {
-              protoConnection.close();
+              close();
               // we're screwed now; we don't know how to escape string literals
               error = new PSQLException(GT.tr(
                   "The server''s standard_conforming_strings parameter was reported as {0}. The JDBC driver expected on or off.",
@@ -1165,7 +1224,7 @@ CopyOperationImpl processCopyResults(CopyOperationImpl op, boolean block)
    * See the comments above MAX_BUFFERED_RECV_BYTES's declaration for details.
    */
   private void flushIfDeadlockRisk(Query query, boolean disallowBatching,
-      ErrorTrackingResultHandler trackingHandler,
+      ResultHandler resultHandler,
       BatchResultHandler batchHandler,
       final int flags) throws IOException {
     // Assume all statements need at least this much reply buffer space,
@@ -1201,7 +1260,7 @@ private void flushIfDeadlockRisk(Query query, boolean disallowBatching,
     if (disallowBatching || estimatedReceiveBufferBytes >= MAX_BUFFERED_RECV_BYTES) {
       logger.debug("Forcing Sync, receive buffer full or batching disallowed");
       sendSync();
-      processResults(trackingHandler, flags);
+      processResults(resultHandler, flags);
       estimatedReceiveBufferBytes = 0;
       if (batchHandler != null) {
         batchHandler.secureProgress();
@@ -1213,11 +1272,11 @@ private void flushIfDeadlockRisk(Query query, boolean disallowBatching,
   /*
    * Send a query to the backend.
    */
-  private void sendQuery(V3Query query, V3ParameterList parameters, int maxRows, int fetchSize,
-      int flags, ErrorTrackingResultHandler trackingHandler,
+  private void sendQuery(Query query, V3ParameterList parameters, int maxRows, int fetchSize,
+      int flags, ResultHandler resultHandler,
       BatchResultHandler batchHandler) throws IOException, SQLException {
     // Now the query itself.
-    SimpleQuery[] subqueries = query.getSubqueries();
+    Query[] subqueries = query.getSubqueries();
     SimpleParameterList[] subparams = parameters.getSubparams();
 
     // We know this is deprecated, but still respect it in case anyone's using it.
@@ -1226,20 +1285,20 @@ private void sendQuery(V3Query query, V3ParameterList parameters, int maxRows, i
     boolean disallowBatching = (flags & QueryExecutor.QUERY_DISALLOW_BATCHING) != 0;
 
     if (subqueries == null) {
-      flushIfDeadlockRisk(query, disallowBatching, trackingHandler, batchHandler, flags);
+      flushIfDeadlockRisk(query, disallowBatching, resultHandler, batchHandler, flags);
 
       // If we saw errors, don't send anything more.
-      if (!trackingHandler.hasErrors()) {
+      if (resultHandler.getException() == null) {
         sendOneQuery((SimpleQuery) query, (SimpleParameterList) parameters, maxRows, fetchSize,
             flags);
       }
     } else {
       for (int i = 0; i < subqueries.length; ++i) {
-        final SimpleQuery subquery = subqueries[i];
-        flushIfDeadlockRisk(subquery, disallowBatching, trackingHandler, batchHandler, flags);
+        final Query subquery = subqueries[i];
+        flushIfDeadlockRisk(subquery, disallowBatching, resultHandler, batchHandler, flags);
 
         // If we saw errors, don't send anything more.
-        if (trackingHandler.hasErrors()) {
+        if (resultHandler.getException() != null) {
           break;
         }
 
@@ -1253,7 +1312,7 @@ private void sendQuery(V3Query query, V3ParameterList parameters, int maxRows, i
         if (subparams != null) {
           subparam = subparams[i];
         }
-        sendOneQuery(subquery, subparam, maxRows, fetchSize, flags);
+        sendOneQuery((SimpleQuery) subquery, subparam, maxRows, fetchSize, flags);
       }
     }
   }
@@ -1267,16 +1326,18 @@ private void sendSync() throws IOException {
       logger.debug(" FE=> Sync");
     }
 
-    pgStream.SendChar('S'); // Sync
-    pgStream.SendInteger4(4); // Length
+    pgStream.sendChar('S'); // Sync
+    pgStream.sendInteger4(4); // Length
     pgStream.flush();
+    pendingExecuteQueue.add(new ExecuteRequest(sync, null, true));
+    pendingDescribePortalQueue.add(sync);
   }
 
   private void sendParse(SimpleQuery query, SimpleParameterList params, boolean oneShot)
       throws IOException {
     // Already parsed, or we have a Parse pending and the types are right?
     int[] typeOIDs = params.getTypeOIDs();
-    if (query.isPreparedFor(typeOIDs)) {
+    if (query.isPreparedFor(typeOIDs, deallocateEpoch)) {
       return;
     }
 
@@ -1298,7 +1359,7 @@ private void sendParse(SimpleQuery query, SimpleParameterList params, boolean on
       // NB: Must clone the OID array, as it's a direct reference to
       // the SimpleParameterList's internal array that might be modified
       // under us.
-      query.setStatementName(statementName);
+      query.setStatementName(statementName, deallocateEpoch);
       query.setStatementTypes(typeOIDs.clone());
       registerParsedQuery(query, statementName);
     }
@@ -1335,17 +1396,17 @@ private void sendParse(SimpleQuery query, SimpleParameterList params, boolean on
         + queryUtf8.length + 1
         + 2 + 4 * params.getParameterCount();
 
-    pgStream.SendChar('P'); // Parse
-    pgStream.SendInteger4(encodedSize);
+    pgStream.sendChar('P'); // Parse
+    pgStream.sendInteger4(encodedSize);
     if (encodedStatementName != null) {
-      pgStream.Send(encodedStatementName);
+      pgStream.send(encodedStatementName);
     }
-    pgStream.SendChar(0); // End of statement name
-    pgStream.Send(queryUtf8); // Query string
-    pgStream.SendChar(0); // End of query string.
-    pgStream.SendInteger2(params.getParameterCount()); // # of parameter types specified
+    pgStream.sendChar(0); // End of statement name
+    pgStream.send(queryUtf8); // Query string
+    pgStream.sendChar(0); // End of query string.
+    pgStream.sendInteger2(params.getParameterCount()); // # of parameter types specified
     for (int i = 1; i <= params.getParameterCount(); ++i) {
-      pgStream.SendInteger4(params.getTypeOID(i));
+      pgStream.sendInteger4(params.getTypeOID(i));
     }
 
     pendingParseQueue.add(query);
@@ -1365,7 +1426,9 @@ private void sendBind(SimpleQuery query, SimpleParameterList params, Portal port
       StringBuilder sbuf =
           new StringBuilder(" FE=> Bind(stmt=" + statementName + ",portal=" + portal);
       for (int i = 1; i <= params.getParameterCount(); ++i) {
-        sbuf.append(",$").append(i).append("=<").append(params.toString(i)).append(">");
+        sbuf.append(",$").append(i).append("=<")
+            .append(params.toString(i,true))
+            .append(">");
       }
       sbuf.append(")");
       logger.debug(sbuf.toString());
@@ -1419,23 +1482,23 @@ private void sendBind(SimpleQuery query, SimpleParameterList params, Portal port
           encodedSize)));
     }
 
-    pgStream.SendChar('B'); // Bind
-    pgStream.SendInteger4((int) encodedSize); // Message size
+    pgStream.sendChar('B'); // Bind
+    pgStream.sendInteger4((int) encodedSize); // Message size
     if (encodedPortalName != null) {
-      pgStream.Send(encodedPortalName); // Destination portal name.
+      pgStream.send(encodedPortalName); // Destination portal name.
     }
-    pgStream.SendChar(0); // End of portal name.
+    pgStream.sendChar(0); // End of portal name.
     if (encodedStatementName != null) {
-      pgStream.Send(encodedStatementName); // Source statement name.
+      pgStream.send(encodedStatementName); // Source statement name.
     }
-    pgStream.SendChar(0); // End of statement name.
+    pgStream.sendChar(0); // End of statement name.
 
-    pgStream.SendInteger2(params.getParameterCount()); // # of parameter format codes
+    pgStream.sendInteger2(params.getParameterCount()); // # of parameter format codes
     for (int i = 1; i <= params.getParameterCount(); ++i) {
-      pgStream.SendInteger2(params.isBinary(i) ? 1 : 0); // Parameter format code
+      pgStream.sendInteger2(params.isBinary(i) ? 1 : 0); // Parameter format code
     }
 
-    pgStream.SendInteger2(params.getParameterCount()); // # of parameter values
+    pgStream.sendInteger2(params.getParameterCount()); // # of parameter values
 
     // If an error occurs when reading a stream we have to
     // continue pumping out data to match the length we
@@ -1448,9 +1511,9 @@ private void sendBind(SimpleQuery query, SimpleParameterList params, Portal port
 
     for (int i = 1; i <= params.getParameterCount(); ++i) {
       if (params.isNull(i)) {
-        pgStream.SendInteger4(-1); // Magic size of -1 means NULL
+        pgStream.sendInteger4(-1); // Magic size of -1 means NULL
       } else {
-        pgStream.SendInteger4(params.getV3Length(i)); // Parameter size
+        pgStream.sendInteger4(params.getV3Length(i)); // Parameter size
         try {
           params.writeV3Value(i, pgStream); // Parameter value
         } catch (PGBindException be) {
@@ -1459,9 +1522,9 @@ private void sendBind(SimpleQuery query, SimpleParameterList params, Portal port
       }
     }
 
-    pgStream.SendInteger2(numBinaryFields); // # of result format codes
+    pgStream.sendInteger2(numBinaryFields); // # of result format codes
     for (int i = 0; i < numBinaryFields; ++i) {
-      pgStream.SendInteger2(fields[i].getFormat());
+      pgStream.sendInteger2(fields[i].getFormat());
     }
 
     pendingBindQueue.add(portal == null ? UNNAMED_PORTAL : portal);
@@ -1480,7 +1543,7 @@ private void sendBind(SimpleQuery query, SimpleParameterList params, Portal port
    */
   private boolean useBinary(Field field) {
     int oid = field.getOID();
-    return protoConnection.useBinaryForReceive(oid);
+    return useBinaryForReceive(oid);
   }
 
   private void sendDescribePortal(SimpleQuery query, Portal portal) throws IOException {
@@ -1497,13 +1560,13 @@ private void sendDescribePortal(SimpleQuery query, Portal portal) throws IOExcep
     // Total size = 4 (size field) + 1 (describe type, 'P') + N + 1 (portal name)
     int encodedSize = 4 + 1 + (encodedPortalName == null ? 0 : encodedPortalName.length) + 1;
 
-    pgStream.SendChar('D'); // Describe
-    pgStream.SendInteger4(encodedSize); // message size
-    pgStream.SendChar('P'); // Describe (Portal)
+    pgStream.sendChar('D'); // Describe
+    pgStream.sendInteger4(encodedSize); // message size
+    pgStream.sendChar('P'); // Describe (Portal)
     if (encodedPortalName != null) {
-      pgStream.Send(encodedPortalName); // portal name to close
+      pgStream.send(encodedPortalName); // portal name to close
     }
-    pgStream.SendChar(0); // end of portal name
+    pgStream.sendChar(0); // end of portal name
 
     pendingDescribePortalQueue.add(query);
     query.setPortalDescribed(true);
@@ -1522,13 +1585,13 @@ private void sendDescribeStatement(SimpleQuery query, SimpleParameterList params
     // Total size = 4 (size field) + 1 (describe type, 'S') + N + 1 (portal name)
     int encodedSize = 4 + 1 + (encodedStatementName == null ? 0 : encodedStatementName.length) + 1;
 
-    pgStream.SendChar('D'); // Describe
-    pgStream.SendInteger4(encodedSize); // Message size
-    pgStream.SendChar('S'); // Describe (Statement);
+    pgStream.sendChar('D'); // Describe
+    pgStream.sendInteger4(encodedSize); // Message size
+    pgStream.sendChar('S'); // Describe (Statement);
     if (encodedStatementName != null) {
-      pgStream.Send(encodedStatementName); // Statement name
+      pgStream.send(encodedStatementName); // Statement name
     }
-    pgStream.SendChar(0); // end message
+    pgStream.sendChar(0); // end message
 
     // Note: statement name can change over time for the same query object
     // Thus we take a snapshot of the query name
@@ -1552,15 +1615,15 @@ private void sendExecute(SimpleQuery query, Portal portal, int limit) throws IOE
     int encodedSize = (encodedPortalName == null ? 0 : encodedPortalName.length);
 
     // Total size = 4 (size field) + 1 + N (source portal) + 4 (max rows)
-    pgStream.SendChar('E'); // Execute
-    pgStream.SendInteger4(4 + 1 + encodedSize + 4); // message size
+    pgStream.sendChar('E'); // Execute
+    pgStream.sendInteger4(4 + 1 + encodedSize + 4); // message size
     if (encodedPortalName != null) {
-      pgStream.Send(encodedPortalName); // portal name
+      pgStream.send(encodedPortalName); // portal name
     }
-    pgStream.SendChar(0); // portal name terminator
-    pgStream.SendInteger4(limit); // row limit
+    pgStream.sendChar(0); // portal name terminator
+    pgStream.sendInteger4(limit); // row limit
 
-    pendingExecuteQueue.add(new ExecuteRequest(query, portal));
+    pendingExecuteQueue.add(new ExecuteRequest(query, portal, false));
   }
 
   private void sendClosePortal(String portalName) throws IOException {
@@ -1576,13 +1639,13 @@ private void sendClosePortal(String portalName) throws IOException {
     int encodedSize = (encodedPortalName == null ? 0 : encodedPortalName.length);
 
     // Total size = 4 (size field) + 1 (close type, 'P') + 1 + N (portal name)
-    pgStream.SendChar('C'); // Close
-    pgStream.SendInteger4(4 + 1 + 1 + encodedSize); // message size
-    pgStream.SendChar('P'); // Close (Portal)
+    pgStream.sendChar('C'); // Close
+    pgStream.sendInteger4(4 + 1 + 1 + encodedSize); // message size
+    pgStream.sendChar('P'); // Close (Portal)
     if (encodedPortalName != null) {
-      pgStream.Send(encodedPortalName);
+      pgStream.send(encodedPortalName);
     }
-    pgStream.SendChar(0); // unnamed portal
+    pgStream.sendChar(0); // unnamed portal
   }
 
   private void sendCloseStatement(String statementName) throws IOException {
@@ -1597,13 +1660,15 @@ private void sendCloseStatement(String statementName) throws IOException {
     byte[] encodedStatementName = Utils.encodeUTF8(statementName);
 
     // Total size = 4 (size field) + 1 (close type, 'S') + N + 1 (statement name)
-    pgStream.SendChar('C'); // Close
-    pgStream.SendInteger4(4 + 1 + encodedStatementName.length + 1); // message size
-    pgStream.SendChar('S'); // Close (Statement)
-    pgStream.Send(encodedStatementName); // statement to close
-    pgStream.SendChar(0); // statement name terminator
+    pgStream.sendChar('C'); // Close
+    pgStream.sendInteger4(4 + 1 + encodedStatementName.length + 1); // message size
+    pgStream.sendChar('S'); // Close (Statement)
+    pgStream.send(encodedStatementName); // statement to close
+    pgStream.sendChar(0); // statement name terminator
   }
 
+
+
   // sendOneQuery sends a single statement via the extended query protocol.
   // Per the FE/BE docs this is essentially the same as how a simple query runs
   // (except that it generates some extra acknowledgement messages, and we
@@ -1619,6 +1684,19 @@ private void sendCloseStatement(String statementName) throws IOException {
   //
   private void sendOneQuery(SimpleQuery query, SimpleParameterList params, int maxRows,
       int fetchSize, int flags) throws IOException {
+    boolean asSimple = (flags & QueryExecutor.QUERY_EXECUTE_AS_SIMPLE) != 0;
+    if (asSimple) {
+      assert (flags & QueryExecutor.QUERY_DESCRIBE_ONLY) == 0
+          : "Simple mode does not support describe requests. sql = " + query.getNativeSql()
+          + ", flags = " + flags;
+      sendSimpleQuery(query, params);
+      return;
+    }
+
+    assert !query.getNativeQuery().multiStatement
+        : "Queries that might contain ; must be executed with QueryExecutor.QUERY_EXECUTE_AS_SIMPLE mode. "
+        + "Given query is " + query.getNativeSql();
+
     // nb: if we decide to use a portal (usePortal == true) we must also use a named statement
     // (oneShot == false) as otherwise the portal will be closed under us unexpectedly when
     // the unnamed statement is next reused.
@@ -1705,7 +1783,7 @@ private void sendOneQuery(SimpleQuery query, SimpleParameterList params, int max
        * that the field information available when we decoded the results. This is undeniably a
        * hack, but there aren't many good alternatives.
        */
-      if (query.getFields() == null || forceDescribePortal) {
+      if (!query.isPortalDescribed() || forceDescribePortal) {
         sendDescribePortal(query, portal);
       }
     }
@@ -1713,6 +1791,24 @@ private void sendOneQuery(SimpleQuery query, SimpleParameterList params, int max
     sendExecute(query, portal, rows);
   }
 
+  private void sendSimpleQuery(SimpleQuery query, SimpleParameterList params) throws IOException {
+    String nativeSql = query.toString(params);
+
+    if (logger.logDebug()) {
+      logger.debug(" FE=> SimpleQuery(query=\"" + nativeSql + "\")");
+    }
+    Encoding encoding = pgStream.getEncoding();
+
+    byte[] encoded = encoding.encode(nativeSql);
+    pgStream.sendChar('Q');
+    pgStream.sendInteger4(encoded.length + 4 + 1);
+    pgStream.send(encoded);
+    pgStream.sendChar(0);
+    pgStream.flush();
+    pendingExecuteQueue.add(new ExecuteRequest(query, null, true));
+    pendingDescribePortalQueue.add(query);
+  }
+
   //
   // Garbage collection of parsed statements.
   //
@@ -1815,14 +1911,14 @@ protected void processResults(ResultHandler handler, int flags) throws IOExcepti
     boolean doneAfterRowDescNoData = false;
 
     while (!endQuery) {
-      c = pgStream.ReceiveChar();
+      c = pgStream.receiveChar();
       switch (c) {
         case 'A': // Asynchronous Notify
           receiveAsyncNotify();
           break;
 
         case '1': // Parse Complete (response to Parse)
-          pgStream.ReceiveInteger4(); // len, discarded
+          pgStream.receiveInteger4(); // len, discarded
 
           SimpleQuery parsedQuery = pendingParseQueue.removeFirst();
           String parsedStatementName = parsedQuery.getStatementName();
@@ -1834,7 +1930,7 @@ protected void processResults(ResultHandler handler, int flags) throws IOExcepti
           break;
 
         case 't': // ParameterDescription
-          pgStream.ReceiveInteger4(); // len, discarded
+          pgStream.receiveInteger4(); // len, discarded
 
           if (logger.logDebug()) {
             logger.debug(" <=BE ParameterDescription");
@@ -1848,10 +1944,10 @@ protected void processResults(ResultHandler handler, int flags) throws IOExcepti
           // This might differ from query.getStatementName if the query was re-prepared
           String origStatementName = describeData.statementName;
 
-          int numParams = pgStream.ReceiveInteger2();
+          int numParams = pgStream.receiveInteger2();
 
           for (int i = 1; i <= numParams; i++) {
-            int typeOid = pgStream.ReceiveInteger4();
+            int typeOid = pgStream.receiveInteger4();
             params.setResolvedType(i, typeOid);
           }
 
@@ -1875,7 +1971,7 @@ protected void processResults(ResultHandler handler, int flags) throws IOExcepti
         }
 
         case '2': // Bind Complete (response to Bind)
-          pgStream.ReceiveInteger4(); // len, discarded
+          pgStream.receiveInteger4(); // len, discarded
 
           Portal boundPortal = pendingBindQueue.removeFirst();
           if (logger.logDebug()) {
@@ -1886,14 +1982,14 @@ protected void processResults(ResultHandler handler, int flags) throws IOExcepti
           break;
 
         case '3': // Close Complete (response to Close)
-          pgStream.ReceiveInteger4(); // len, discarded
+          pgStream.receiveInteger4(); // len, discarded
           if (logger.logDebug()) {
             logger.debug(" <=BE CloseComplete");
           }
           break;
 
         case 'n': // No Data (response to Describe)
-          pgStream.ReceiveInteger4(); // len, discarded
+          pgStream.receiveInteger4(); // len, discarded
           if (logger.logDebug()) {
             logger.debug(" <=BE NoData");
           }
@@ -1918,7 +2014,7 @@ protected void processResults(ResultHandler handler, int flags) throws IOExcepti
           // nb: this appears *instead* of CommandStatus.
           // Must be a SELECT if we suspended, so don't worry about it.
 
-          pgStream.ReceiveInteger4(); // len, discarded
+          pgStream.receiveInteger4(); // len, discarded
           if (logger.logDebug()) {
             logger.debug(" <=BE PortalSuspended");
           }
@@ -1941,14 +2037,41 @@ protected void processResults(ResultHandler handler, int flags) throws IOExcepti
         case 'C': // Command Status (end of Execute)
           // Handle status.
           String status = receiveCommandStatus();
+          if (isFlushCacheOnDeallocate()
+              && (status.startsWith("DEALLOCATE ALL") || status.startsWith("DISCARD ALL"))) {
+            deallocateEpoch++;
+          }
 
           doneAfterRowDescNoData = false;
 
         {
-          ExecuteRequest executeData = pendingExecuteQueue.removeFirst();
+          ExecuteRequest executeData = pendingExecuteQueue.peekFirst();
           SimpleQuery currentQuery = executeData.query;
           Portal currentPortal = executeData.portal;
 
+          if (status.startsWith("SET")) {
+            String nativeSql = currentQuery.getNativeQuery().nativeSql;
+            // Scan only the first 1024 characters to
+            // avoid big overhead for long queries.
+            if (nativeSql.lastIndexOf("search_path", 1024) != -1
+                && !nativeSql.equals(lastSetSearchPathQuery)) {
+              // Search path was changed, invalidate prepared statement cache
+              lastSetSearchPathQuery = nativeSql;
+              deallocateEpoch++;
+            }
+          }
+
+          if (!executeData.asSimple) {
+            pendingExecuteQueue.removeFirst();
+          } else {
+            // For simple 'Q' queries, executeQueue is cleared via ReadyForQuery message
+          }
+
+          if (currentQuery == autoSaveQuery) {
+            // ignore "SAVEPOINT" status from autosave query
+            break;
+          }
+
           Field[] fields = currentQuery.getFields();
           if (fields != null && !noResults && tuples == null) {
             tuples = new ArrayList<byte[][]>();
@@ -1974,6 +2097,13 @@ protected void processResults(ResultHandler handler, int flags) throws IOExcepti
             interpretCommandStatus(status, handler);
           }
 
+          if (executeData.asSimple) {
+            // Simple queries might return several resultsets, thus we clear
+            // fields, so queries like "select 1;update; select2" will properly
+            // identify that "update" did not return any results
+            currentQuery.setFields(null);
+          }
+
           if (currentPortal != null) {
             currentPortal.close();
           }
@@ -1983,7 +2113,7 @@ protected void processResults(ResultHandler handler, int flags) throws IOExcepti
         case 'D': // Data Transfer (ongoing Execute response)
           byte[][] tuple = null;
           try {
-            tuple = pgStream.ReceiveTupleV3();
+            tuple = pgStream.receiveTupleV3();
           } catch (OutOfMemoryError oome) {
             if (!noResults) {
               handler.handleError(
@@ -2022,12 +2152,21 @@ protected void processResults(ResultHandler handler, int flags) throws IOExcepti
           // Error Response (response to pretty much everything; backend then skips until Sync)
           SQLException error = receiveErrorResponse();
           handler.handleError(error);
-
+          if (willHealViaReparse(error)) {
+            // prepared statement ... is not valid kind of error
+            // Technically speaking, the error is unexpected, thus we invalidate other
+            // server-prepared statements just in case.
+            deallocateEpoch++;
+            if (logger.logDebug()) {
+              logger.debug(" FE: received " + error.getSQLState() + ", will invalidate statements. "
+                  + "deallocateEpoch is now " + deallocateEpoch);
+            }
+          }
           // keep processing
           break;
 
         case 'I': // Empty Query (end of Execute)
-          pgStream.ReceiveInteger4();
+          pgStream.receiveInteger4();
 
           if (logger.logDebug()) {
             logger.debug(" <=BE EmptyQuery");
@@ -2050,16 +2189,16 @@ protected void processResults(ResultHandler handler, int flags) throws IOExcepti
 
         case 'S': // Parameter Status
         {
-          int l_len = pgStream.ReceiveInteger4();
-          String name = pgStream.ReceiveString();
-          String value = pgStream.ReceiveString();
+          int l_len = pgStream.receiveInteger4();
+          String name = pgStream.receiveString();
+          String value = pgStream.receiveString();
           if (logger.logDebug()) {
             logger.debug(" <=BE ParameterStatus(" + name + " = " + value + ")");
           }
 
           if (name.equals("client_encoding") && !value.equalsIgnoreCase("UTF8")
               && !allowEncodingChanges) {
-            protoConnection.close(); // we're screwed now; we can't trust any subsequent string.
+            close(); // we're screwed now; we can't trust any subsequent string.
             handler.handleError(new PSQLException(GT.tr(
                 "The server''s client_encoding parameter was changed to {0}. The JDBC driver requires client_encoding to be UTF8 for correct operation.",
                 value), PSQLState.CONNECTION_FAILURE));
@@ -2067,7 +2206,7 @@ protected void processResults(ResultHandler handler, int flags) throws IOExcepti
           }
 
           if (name.equals("DateStyle") && !value.startsWith("ISO,")) {
-            protoConnection.close(); // we're screwed now; we can't trust any subsequent date.
+            close(); // we're screwed now; we can't trust any subsequent date.
             handler.handleError(new PSQLException(GT.tr(
                 "The server''s DateStyle parameter was changed to {0}. The JDBC driver requires DateStyle to begin with ISO for correct operation.",
                 value), PSQLState.CONNECTION_FAILURE));
@@ -2076,11 +2215,11 @@ protected void processResults(ResultHandler handler, int flags) throws IOExcepti
 
           if (name.equals("standard_conforming_strings")) {
             if (value.equals("on")) {
-              protoConnection.setStandardConformingStrings(true);
+              setStandardConformingStrings(true);
             } else if (value.equals("off")) {
-              protoConnection.setStandardConformingStrings(false);
+              setStandardConformingStrings(false);
             } else {
-              protoConnection.close();
+              close();
               // we're screwed now; we don't know how to escape string literals
               handler.handleError(new PSQLException(GT.tr(
                   "The server''s standard_conforming_strings parameter was reported as {0}. The JDBC driver expected on or off.",
@@ -2090,10 +2229,10 @@ protected void processResults(ResultHandler handler, int flags) throws IOExcepti
           }
 
           if ("TimeZone".equals(name)) {
-            protoConnection.setTimeZone(TimestampUtils.parseBackendTimeZone(value));
+            setTimeZone(TimestampUtils.parseBackendTimeZone(value));
           }
           if ("application_name".equals(name)) {
-            protoConnection.setApplicationName(value);
+            setApplicationName(value);
           }
           break;
         }
@@ -2102,7 +2241,10 @@ protected void processResults(ResultHandler handler, int flags) throws IOExcepti
           Field[] fields = receiveFields();
           tuples = new ArrayList<byte[][]>();
 
-          SimpleQuery query = pendingDescribePortalQueue.removeFirst();
+          SimpleQuery query = pendingDescribePortalQueue.peekFirst();
+          if (!pendingExecuteQueue.isEmpty() && !pendingExecuteQueue.peekFirst().asSimple) {
+            pendingDescribePortalQueue.removeFirst();
+          }
           query.setFields(fields);
 
           if (doneAfterRowDescNoData) {
@@ -2117,6 +2259,24 @@ protected void processResults(ResultHandler handler, int flags) throws IOExcepti
 
         case 'Z': // Ready For Query (eventual response to Sync)
           receiveRFQ();
+          if (!pendingExecuteQueue.isEmpty() && pendingExecuteQueue.peekFirst().asSimple) {
+            tuples = null;
+
+            ExecuteRequest executeRequest = pendingExecuteQueue.removeFirst();
+            // Simple queries might return several resultsets, thus we clear
+            // fields, so queries like "select 1;update; select2" will properly
+            // identify that "update" did not return any results
+            executeRequest.query.setFields(null);
+
+            pendingDescribePortalQueue.removeFirst();
+            if (!pendingExecuteQueue.isEmpty()) {
+              if (getTransactionState() == TransactionState.IDLE) {
+                handler.secureProgress();
+              }
+              // process subsequent results (e.g. for cases like batched execution of simple 'Q' queries)
+              break;
+            }
+          }
           endQuery = true;
 
           // Reset the statement name of Parses that failed.
@@ -2144,10 +2304,10 @@ protected void processResults(ResultHandler handler, int flags) throws IOExcepti
 
           byte[] buf =
               Utils.encodeUTF8("The JDBC driver currently does not support COPY operations.");
-          pgStream.SendChar('f');
-          pgStream.SendInteger4(buf.length + 4 + 1);
-          pgStream.Send(buf);
-          pgStream.SendChar(0);
+          pgStream.sendChar('f');
+          pgStream.sendInteger4(buf.length + 4 + 1);
+          pgStream.send(buf);
+          pgStream.sendChar(0);
           pgStream.flush();
           sendSync(); // send sync message
           skipMessage(); // skip the response message
@@ -2192,9 +2352,9 @@ protected void processResults(ResultHandler handler, int flags) throws IOExcepti
    * communication stream.
    */
   private void skipMessage() throws IOException {
-    int l_len = pgStream.ReceiveInteger4();
+    int l_len = pgStream.receiveInteger4();
     // skip l_len-4 (length includes the 4 bytes for message length itself
-    pgStream.Skip(l_len - 4);
+    pgStream.skip(l_len - 4);
   }
 
   public synchronized void fetch(ResultCursor cursor, ResultHandler handler, int fetchSize)
@@ -2205,27 +2365,10 @@ public synchronized void fetch(ResultCursor cursor, ResultHandler handler, int f
     // Insert a ResultHandler that turns bare command statuses into empty datasets
     // (if the fetch returns no rows, we see just a CommandStatus..)
     final ResultHandler delegateHandler = handler;
-    handler = new ResultHandler() {
-      public void handleResultRows(Query fromQuery, Field[] fields, List<byte[][]> tuples,
-          ResultCursor cursor) {
-        delegateHandler.handleResultRows(fromQuery, fields, tuples, cursor);
-      }
-
+    handler = new ResultHandlerDelegate(delegateHandler) {
       public void handleCommandStatus(String status, int updateCount, long insertOID) {
         handleResultRows(portal.getQuery(), null, new ArrayList<byte[][]>(), null);
       }
-
-      public void handleWarning(SQLWarning warning) {
-        delegateHandler.handleWarning(warning);
-      }
-
-      public void handleError(SQLException error) {
-        delegateHandler.handleError(error);
-      }
-
-      public void handleCompletion() throws SQLException {
-        delegateHandler.handleCompletion();
-      }
     };
 
     // Now actually run it.
@@ -2240,7 +2383,7 @@ public void handleCompletion() throws SQLException {
       processResults(handler, 0);
       estimatedReceiveBufferBytes = 0;
     } catch (IOException e) {
-      protoConnection.abort();
+      abort();
       handler.handleError(
           new PSQLException(GT.tr("An I/O error occurred while sending to the backend."),
               PSQLState.CONNECTION_FAILURE, e));
@@ -2253,8 +2396,8 @@ public void handleCompletion() throws SQLException {
    * Receive the field descriptions from the back end.
    */
   private Field[] receiveFields() throws IOException {
-    int l_msgSize = pgStream.ReceiveInteger4();
-    int size = pgStream.ReceiveInteger2();
+    int l_msgSize = pgStream.receiveInteger4();
+    int size = pgStream.receiveInteger2();
     Field[] fields = new Field[size];
 
     if (logger.logDebug()) {
@@ -2262,13 +2405,13 @@ private Field[] receiveFields() throws IOException {
     }
 
     for (int i = 0; i < fields.length; i++) {
-      String columnLabel = pgStream.ReceiveString();
-      int tableOid = pgStream.ReceiveInteger4();
-      short positionInTable = (short) pgStream.ReceiveInteger2();
-      int typeOid = pgStream.ReceiveInteger4();
-      int typeLength = pgStream.ReceiveInteger2();
-      int typeModifier = pgStream.ReceiveInteger4();
-      int formatType = pgStream.ReceiveInteger2();
+      String columnLabel = pgStream.receiveString();
+      int tableOid = pgStream.receiveInteger4();
+      short positionInTable = (short) pgStream.receiveInteger2();
+      int typeOid = pgStream.receiveInteger4();
+      int typeLength = pgStream.receiveInteger2();
+      int typeModifier = pgStream.receiveInteger4();
+      int formatType = pgStream.receiveInteger2();
       fields[i] = new Field(columnLabel,
           typeOid, typeLength, typeModifier, tableOid, positionInTable);
       fields[i].setFormat(formatType);
@@ -2282,11 +2425,11 @@ private Field[] receiveFields() throws IOException {
   }
 
   private void receiveAsyncNotify() throws IOException {
-    int msglen = pgStream.ReceiveInteger4();
-    int pid = pgStream.ReceiveInteger4();
-    String msg = pgStream.ReceiveString();
-    String param = pgStream.ReceiveString();
-    protoConnection.addNotification(new org.postgresql.core.Notification(msg, pid, param));
+    int msglen = pgStream.receiveInteger4();
+    int pid = pgStream.receiveInteger4();
+    String msg = pgStream.receiveString();
+    String param = pgStream.receiveString();
+    addNotification(new org.postgresql.core.Notification(msg, pid, param));
 
     if (logger.logDebug()) {
       logger.debug(" <=BE AsyncNotify(" + pid + "," + msg + "," + param + ")");
@@ -2299,8 +2442,8 @@ private SQLException receiveErrorResponse() throws IOException {
     // so, append messages to a string buffer and keep processing
     // check at the bottom to see if we need to throw an exception
 
-    int elen = pgStream.ReceiveInteger4();
-    String totalMessage = pgStream.ReceiveString(elen - 4);
+    int elen = pgStream.receiveInteger4();
+    EncodingPredictor.DecodeResult totalMessage = pgStream.receiveErrorString(elen - 4);
     ServerErrorMessage errorMsg = new ServerErrorMessage(totalMessage, logger.getLogLevel());
 
     if (logger.logDebug()) {
@@ -2311,9 +2454,9 @@ private SQLException receiveErrorResponse() throws IOException {
   }
 
   private SQLWarning receiveNoticeResponse() throws IOException {
-    int nlen = pgStream.ReceiveInteger4();
+    int nlen = pgStream.receiveInteger4();
     ServerErrorMessage warnMsg =
-        new ServerErrorMessage(pgStream.ReceiveString(nlen - 4), logger.getLogLevel());
+        new ServerErrorMessage(pgStream.receiveString(nlen - 4), logger.getLogLevel());
 
     if (logger.logDebug()) {
       logger.debug(" <=BE NoticeResponse(" + warnMsg.toString() + ")");
@@ -2324,11 +2467,11 @@ private SQLWarning receiveNoticeResponse() throws IOException {
 
   private String receiveCommandStatus() throws IOException {
     // TODO: better handle the msg len
-    int l_len = pgStream.ReceiveInteger4();
+    int l_len = pgStream.receiveInteger4();
     // read l_len -5 bytes (-4 for l_len and -1 for trailing \0)
-    String status = pgStream.ReceiveString(l_len - 5);
+    String status = pgStream.receiveString(l_len - 5);
     // now read and discard the trailing \0
-    pgStream.ReceiveChar(); // Receive(1) would allocate new byte[1], so avoid it
+    pgStream.receiveChar(); // Receive(1) would allocate new byte[1], so avoid it
 
     if (logger.logDebug()) {
       logger.debug(" <=BE CommandStatus(" + status + ")");
@@ -2369,11 +2512,11 @@ private void interpretCommandStatus(String status, ResultHandler handler) {
   }
 
   private void receiveRFQ() throws IOException {
-    if (pgStream.ReceiveInteger4() != 5) {
+    if (pgStream.receiveInteger4() != 5) {
       throw new IOException("unexpected length of ReadyForQuery message");
     }
 
-    char tStatus = (char) pgStream.ReceiveChar();
+    char tStatus = (char) pgStream.receiveChar();
     if (logger.logDebug()) {
       logger.debug(" <=BE ReadyForQuery(" + tStatus + ")");
     }
@@ -2381,13 +2524,13 @@ private void receiveRFQ() throws IOException {
     // Update connection state.
     switch (tStatus) {
       case 'I':
-        protoConnection.setTransactionState(ProtocolConnection.TRANSACTION_IDLE);
+        setTransactionState(TransactionState.IDLE);
         break;
       case 'T':
-        protoConnection.setTransactionState(ProtocolConnection.TRANSACTION_OPEN);
+        setTransactionState(TransactionState.OPEN);
         break;
       case 'E':
-        protoConnection.setTransactionState(ProtocolConnection.TRANSACTION_FAILED);
+        setTransactionState(TransactionState.FAILED);
         break;
       default:
         throw new IOException(
@@ -2395,6 +2538,153 @@ private void receiveRFQ() throws IOException {
     }
   }
 
+  @Override
+  protected void sendCloseMessage() throws IOException {
+    pgStream.sendChar('X');
+    pgStream.sendInteger4(4);
+  }
+
+  public void readStartupMessages() throws IOException, SQLException {
+    for (int i = 0; i < 1000; i++) {
+      int beresp = pgStream.receiveChar();
+      switch (beresp) {
+        case 'Z':
+          receiveRFQ();
+          // Ready For Query; we're done.
+          return;
+
+        case 'K':
+          // BackendKeyData
+          int l_msgLen = pgStream.receiveInteger4();
+          if (l_msgLen != 12) {
+            throw new PSQLException(GT.tr("Protocol error.  Session setup failed."),
+                PSQLState.PROTOCOL_VIOLATION);
+          }
+
+          int pid = pgStream.receiveInteger4();
+          int ckey = pgStream.receiveInteger4();
+
+          if (logger.logDebug()) {
+            logger.debug(" <=BE BackendKeyData(pid=" + pid + ",ckey=" + ckey + ")");
+          }
+
+          setBackendKeyData(pid, ckey);
+          break;
+
+        case 'E':
+          // Error
+          throw receiveErrorResponse();
+
+        case 'N':
+          // Warning
+          addWarning(receiveNoticeResponse());
+          break;
+
+        case 'S':
+          // ParameterStatus
+          int l_len = pgStream.receiveInteger4();
+          String name = pgStream.receiveString();
+          String value = pgStream.receiveString();
+
+          if (logger.logDebug()) {
+            logger.debug(" <=BE ParameterStatus(" + name + " = " + value + ")");
+          }
+
+          if ("server_version_num".equals(name)) {
+            setServerVersionNum(Integer.parseInt(value));
+          } else if ("server_version".equals(name)) {
+            setServerVersion(value);
+          } else if ("client_encoding".equals(name)) {
+            if (!"UTF8".equals(value)) {
+              throw new PSQLException(GT.tr("Protocol error.  Session setup failed."),
+                  PSQLState.PROTOCOL_VIOLATION);
+            }
+            pgStream.setEncoding(Encoding.getDatabaseEncoding("UTF8"));
+          } else if ("standard_conforming_strings".equals(name)) {
+            if ("on".equals(value)) {
+              setStandardConformingStrings(true);
+            } else if ("off".equals(value)) {
+              setStandardConformingStrings(false);
+            } else {
+              throw new PSQLException(GT.tr("Protocol error.  Session setup failed."),
+                  PSQLState.PROTOCOL_VIOLATION);
+            }
+          } else if ("integer_datetimes".equals(name)) {
+            if ("on".equals(value)) {
+              setIntegerDateTimes(true);
+            } else if ("off".equals(value)) {
+              setIntegerDateTimes(false);
+            } else {
+              throw new PSQLException(GT.tr("Protocol error.  Session setup failed."),
+                  PSQLState.PROTOCOL_VIOLATION);
+            }
+          }
+
+          break;
+
+        default:
+          if (logger.logDebug()) {
+            logger.debug("invalid message type=" + (char) beresp);
+          }
+          throw new PSQLException(GT.tr("Protocol error.  Session setup failed."),
+              PSQLState.PROTOCOL_VIOLATION);
+      }
+    }
+    throw new PSQLException(GT.tr("Protocol error.  Session setup failed."),
+        PSQLState.PROTOCOL_VIOLATION);
+  }
+
+
+
+  public void setTimeZone(TimeZone timeZone) {
+    this.timeZone = timeZone;
+  }
+
+  public TimeZone getTimeZone() {
+    return timeZone;
+  }
+
+  public void setApplicationName(String applicationName) {
+    this.applicationName = applicationName;
+  }
+
+  public String getApplicationName() {
+    if (applicationName == null) {
+      return "";
+    }
+    return applicationName;
+  }
+
+  @Override
+  public boolean useBinaryForReceive(int oid) {
+    return useBinaryReceiveForOids.contains(oid);
+  }
+
+  @Override
+  public void setBinaryReceiveOids(Set<Integer> oids) {
+    useBinaryReceiveForOids.clear();
+    useBinaryReceiveForOids.addAll(oids);
+  }
+
+  @Override
+  public boolean useBinaryForSend(int oid) {
+    return useBinarySendForOids.contains(oid);
+  }
+
+  @Override
+  public void setBinarySendOids(Set<Integer> oids) {
+    useBinarySendForOids.clear();
+    useBinarySendForOids.addAll(oids);
+  }
+
+  private void setIntegerDateTimes(boolean state) {
+    integerDateTimes = state;
+  }
+
+  public boolean getIntegerDateTimes() {
+    return integerDateTimes;
+  }
+
   private final Deque<SimpleQuery> pendingParseQueue = new ArrayDeque<SimpleQuery>();
   private final Deque<Portal> pendingBindQueue = new ArrayDeque<Portal>();
   private final Deque<ExecuteRequest> pendingExecuteQueue = new ArrayDeque<ExecuteRequest>();
@@ -2403,11 +2693,7 @@ private void receiveRFQ() throws IOException {
   private final Deque<SimpleQuery> pendingDescribePortalQueue = new ArrayDeque<SimpleQuery>();
 
   private long nextUniqueID = 1;
-  private final ProtocolConnectionImpl protoConnection;
-  private final PGStream pgStream;
-  private final Logger logger;
   private final boolean allowEncodingChanges;
-  private final boolean allowReWriteBatchedInserts;
 
 
   /**
@@ -2421,9 +2707,23 @@ private void receiveRFQ() throws IOException {
   private int estimatedReceiveBufferBytes = 0;
 
   private final SimpleQuery beginTransactionQuery =
-      new SimpleQuery(new NativeQuery("BEGIN", new int[0], SqlCommand.createStatementTypeInfo(
-          SqlCommandType.BLANK)), null);
-
-  private final SimpleQuery EMPTY_QUERY = new SimpleQuery(new NativeQuery("", new int[0], SqlCommand
-      .createStatementTypeInfo(SqlCommandType.BLANK)), null);
+      new SimpleQuery(
+          new NativeQuery("BEGIN", new int[0], false, SqlCommand.BLANK),
+          null, false);
+
+  private final SimpleQuery EMPTY_QUERY =
+      new SimpleQuery(
+          new NativeQuery("", new int[0], false,
+              SqlCommand.createStatementTypeInfo(SqlCommandType.BLANK)
+          ), null, false);
+
+  private final SimpleQuery autoSaveQuery =
+      new SimpleQuery(
+          new NativeQuery("SAVEPOINT PGJDBC_AUTOSAVE", new int[0], false, SqlCommand.BLANK),
+          null, false);
+
+  private final SimpleQuery restoreToAutoSave =
+      new SimpleQuery(
+          new NativeQuery("ROLLBACK TO SAVEPOINT PGJDBC_AUTOSAVE", new int[0], false, SqlCommand.BLANK),
+          null, false);
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v3/SimpleParameterList.java b/pgjdbc/src/main/java/org/postgresql/core/v3/SimpleParameterList.java
index a9b59912ce..f7aee82f60 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v3/SimpleParameterList.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v3/SimpleParameterList.java
@@ -13,6 +13,9 @@
 import org.postgresql.core.PGStream;
 import org.postgresql.core.ParameterList;
 import org.postgresql.core.Utils;
+import org.postgresql.geometric.PGbox;
+import org.postgresql.geometric.PGpoint;
+import org.postgresql.jdbc.UUIDArrayAssistant;
 import org.postgresql.util.ByteConverter;
 import org.postgresql.util.GT;
 import org.postgresql.util.PSQLException;
@@ -39,19 +42,20 @@ class SimpleParameterList implements V3ParameterList {
   private final static byte TEXT = 0;
   private final static byte BINARY = 4;
 
-  SimpleParameterList(int paramCount, ProtocolConnectionImpl protoConnection) {
+  SimpleParameterList(int paramCount, TypeTransferModeRegistry transferModeRegistry) {
     this.paramValues = new Object[paramCount];
     this.paramTypes = new int[paramCount];
     this.encoded = new byte[paramCount][];
     this.flags = new byte[paramCount];
-    this.protoConnection = protoConnection;
+    this.transferModeRegistry = transferModeRegistry;
   }
 
+  @Override
   public void registerOutParameter(int index, int sqlType) throws SQLException {
     if (index < 1 || index > paramValues.length) {
       throw new PSQLException(
           GT.tr("The column index is out of range: {0}, number of columns: {1}.",
-              new Object[]{index, paramValues.length}),
+              index, paramValues.length),
           PSQLState.INVALID_PARAMETER_VALUE);
     }
 
@@ -62,7 +66,7 @@ private void bind(int index, Object value, int oid, byte binary) throws SQLExcep
     if (index < 1 || index > paramValues.length) {
       throw new PSQLException(
           GT.tr("The column index is out of range: {0}, number of columns: {1}.",
-              new Object[]{index, paramValues.length}),
+              index, paramValues.length),
           PSQLState.INVALID_PARAMETER_VALUE);
     }
 
@@ -147,13 +151,13 @@ public void setNull(int index, int oid) throws SQLException {
 
     byte binaryTransfer = TEXT;
 
-    if (protoConnection.useBinaryForReceive(oid)) {
+    if (transferModeRegistry.useBinaryForReceive(oid)) {
       binaryTransfer = BINARY;
     }
     bind(index, NULL_OBJECT, oid, binaryTransfer);
   }
 
-  public String toString(int index) {
+  public String toString(int index, boolean standardConformingStrings) {
     --index;
     if (paramValues[index] == null) {
       return "?";
@@ -182,26 +186,31 @@ public String toString(int index) {
         case Oid.FLOAT8:
           double d = ByteConverter.float8((byte[]) paramValues[index], 0);
           return Double.toString(d);
+
+        case Oid.UUID:
+          String uuid =
+              new UUIDArrayAssistant().buildElement((byte[]) paramValues[index], 0, 16).toString();
+          return "'" + uuid + "'::uuid";
+
+        case Oid.POINT:
+          PGpoint pgPoint = new PGpoint();
+          pgPoint.setByteValue((byte[]) paramValues[index], 0);
+          return "'" + pgPoint.toString() + "'::point";
+
+        case Oid.BOX:
+          PGbox pgBox = new PGbox();
+          pgBox.setByteValue((byte[]) paramValues[index], 0);
+          return "'" + pgBox.toString() + "'::box";
       }
       return "?";
     } else {
       String param = paramValues[index].toString();
-      boolean hasBackslash = param.indexOf('\\') != -1;
 
       // add room for quotes + potential escaping.
       StringBuilder p = new StringBuilder(3 + param.length() * 11 / 10);
 
-      boolean standardConformingStrings = false;
-      boolean supportsEStringSyntax = false;
-      if (protoConnection != null) {
-        standardConformingStrings = protoConnection.getStandardConformingStrings();
-        supportsEStringSyntax = protoConnection.getServerVersionNum() >= 80100;
-      }
-
-      if (hasBackslash && !standardConformingStrings && supportsEStringSyntax) {
-        p.append('E');
-      }
-
+      // No E'..' here since escapeLiteral escapes all things and it does not use \123 kind of
+      // escape codes
       p.append('\'');
       try {
         p = Utils.escapeLiteral(p, param, standardConformingStrings);
@@ -216,6 +225,20 @@ public String toString(int index) {
         p.append(param);
       }
       p.append('\'');
+      int paramType = paramTypes[index];
+      if (paramType == Oid.TIMESTAMP) {
+        p.append("::timestamp");
+      } else if (paramType == Oid.TIMESTAMPTZ) {
+        p.append("::timestamp with time zone");
+      } else if (paramType == Oid.TIME) {
+        p.append("::time");
+      } else if (paramType == Oid.TIMETZ) {
+        p.append("::time with time zone");
+      } else if (paramType == Oid.DATE) {
+        p.append("::date");
+      } else if (paramType == Oid.INTERVAL) {
+        p.append("::interval");
+      }
       return p.toString();
     }
   }
@@ -245,11 +268,11 @@ public void convertFunctionOutParameters() {
   private static void streamBytea(PGStream pgStream, StreamWrapper wrapper) throws IOException {
     byte[] rawData = wrapper.getBytes();
     if (rawData != null) {
-      pgStream.Send(rawData, wrapper.getOffset(), wrapper.getLength());
+      pgStream.send(rawData, wrapper.getOffset(), wrapper.getLength());
       return;
     }
 
-    pgStream.SendStream(wrapper.getStream(), wrapper.getLength());
+    pgStream.sendStream(wrapper.getStream(), wrapper.getLength());
   }
 
   public int[] getTypeOIDs() {
@@ -332,7 +355,7 @@ void writeV3Value(int index, PGStream pgStream) throws IOException {
 
     // Directly encoded?
     if (paramValues[index] instanceof byte[]) {
-      pgStream.Send((byte[]) paramValues[index]);
+      pgStream.send((byte[]) paramValues[index]);
       return;
     }
 
@@ -346,12 +369,12 @@ void writeV3Value(int index, PGStream pgStream) throws IOException {
     if (encoded[index] == null) {
       encoded[index] = Utils.encodeUTF8((String) paramValues[index]);
     }
-    pgStream.Send(encoded[index]);
+    pgStream.send(encoded[index]);
   }
 
 
   public ParameterList copy() {
-    SimpleParameterList newCopy = new SimpleParameterList(paramValues.length, protoConnection);
+    SimpleParameterList newCopy = new SimpleParameterList(paramValues.length, transferModeRegistry);
     System.arraycopy(paramValues, 0, newCopy.paramValues, 0, paramValues.length);
     System.arraycopy(paramTypes, 0, newCopy.paramTypes, 0, paramTypes.length);
     System.arraycopy(flags, 0, newCopy.flags, 0, flags.length);
@@ -387,6 +410,7 @@ public byte[][] getEncoding() {
     return encoded;
   }
 
+  @Override
   public void appendAll(ParameterList list) throws SQLException {
     if (list instanceof org.postgresql.core.v3.SimpleParameterList ) {
       /* only v3.SimpleParameterList is compatible with this type
@@ -396,7 +420,7 @@ public void appendAll(ParameterList list) throws SQLException {
       if ((pos + inParamCount) > paramValues.length) {
         throw new PSQLException(
           GT.tr("Added parameters index out of range: {0}, number of columns: {1}.",
-            new Object[]{(pos + inParamCount), paramValues.length}),
+              (pos + inParamCount), paramValues.length),
               PSQLState.INVALID_PARAMETER_VALUE);
       }
       System.arraycopy(spl.getValues(), 0, this.paramValues, pos, inParamCount);
@@ -407,17 +431,17 @@ public void appendAll(ParameterList list) throws SQLException {
     }
   }
 
-  @Override
   /**
    * Useful implementation of toString.
    * @return String representation of the list values
    */
+  @Override
   public String toString() {
     StringBuilder ts = new StringBuilder("<[");
     if (paramValues.length > 0) {
-      ts.append(toString(1));
+      ts.append(toString(1, true));
       for (int c = 2; c <= paramValues.length; c++) {
-        ts.append(" ,").append(toString(c));
+        ts.append(" ,").append(toString(c, true));
       }
     }
     ts.append("]>");
@@ -428,7 +452,7 @@ public String toString() {
   private final int[] paramTypes;
   private final byte[] flags;
   private final byte[][] encoded;
-  private final ProtocolConnectionImpl protoConnection;
+  private final TypeTransferModeRegistry transferModeRegistry;
 
   /**
    * Marker object representing NULL; this distinguishes "parameter never set" from "parameter set
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v3/SimpleQuery.java b/pgjdbc/src/main/java/org/postgresql/core/v3/SimpleQuery.java
index 70b9f74d46..11a44a5330 100644
--- a/pgjdbc/src/main/java/org/postgresql/core/v3/SimpleQuery.java
+++ b/pgjdbc/src/main/java/org/postgresql/core/v3/SimpleQuery.java
@@ -13,9 +13,13 @@
 import org.postgresql.core.NativeQuery;
 import org.postgresql.core.Oid;
 import org.postgresql.core.ParameterList;
+import org.postgresql.core.Query;
+import org.postgresql.core.SqlCommand;
 import org.postgresql.core.Utils;
+import org.postgresql.jdbc.PgResultSet;
 
 import java.lang.ref.PhantomReference;
+import java.util.Map;
 
 /**
  * V3 Query implementation for a single-statement query. This also holds the state of any associated
@@ -24,15 +28,17 @@
  *
  * @author Oliver Jowett (oliver@opencloud.com)
  */
-class SimpleQuery implements V3Query {
+class SimpleQuery implements Query {
 
   SimpleQuery(SimpleQuery src) {
-    this(src.nativeQuery, src.protoConnection);
+    this(src.nativeQuery, src.transferModeRegistry, src.sanitiserDisabled);
   }
 
-  SimpleQuery(NativeQuery query, ProtocolConnectionImpl protoConnection) {
+  SimpleQuery(NativeQuery query, TypeTransferModeRegistry transferModeRegistry,
+      boolean sanitiserDisabled) {
     this.nativeQuery = query;
-    this.protoConnection = protoConnection;
+    this.transferModeRegistry = transferModeRegistry;
+    this.sanitiserDisabled = sanitiserDisabled;
   }
 
   public ParameterList createParameterList() {
@@ -40,7 +46,7 @@ public ParameterList createParameterList() {
       return NO_PARAMETERS;
     }
 
-    return new SimpleParameterList(getBindCount(), protoConnection);
+    return new SimpleParameterList(getBindCount(), transferModeRegistry);
   }
 
   public String toString(ParameterList parameters) {
@@ -55,10 +61,6 @@ public void close() {
     unprepare();
   }
 
-  //
-  // V3Query
-  //
-
   public SimpleQuery[] getSubqueries() {
     return null;
   }
@@ -104,14 +106,15 @@ public int getMaxResultRowSize() {
   // Implementation guts
   //
 
-  String getNativeSql() {
+  public String getNativeSql() {
     return nativeQuery.nativeSql;
   }
 
-  void setStatementName(String statementName) {
+  void setStatementName(String statementName, short deallocateEpoch) {
     assert statementName != null : "statement name should not be null";
     this.statementName = statementName;
     this.encodedStatementName = Utils.encodeUTF8(statementName);
+    this.deallocateEpoch = deallocateEpoch;
   }
 
   void setStatementTypes(int[] paramTypes) {
@@ -126,10 +129,13 @@ String getStatementName() {
     return statementName;
   }
 
-  boolean isPreparedFor(int[] paramTypes) {
+  boolean isPreparedFor(int[] paramTypes, short deallocateEpoch) {
     if (statementName == null) {
       return false; // Not prepared.
     }
+    if (this.deallocateEpoch != deallocateEpoch) {
+      return false;
+    }
 
     assert preparedTypes == null || paramTypes.length == preparedTypes.length
         : String.format("paramTypes:%1$d preparedTypes:%2$d", paramTypes.length,
@@ -169,6 +175,7 @@ byte[] getEncodedStatementName() {
    */
   void setFields(Field[] fields) {
     this.fields = fields;
+    this.resultSetColumnNameIndexMap = null;
     this.cachedMaxResultRowSize = null;
     this.needUpdateFieldFormats = fields != null;
     this.hasBinaryFields = false; // just in case
@@ -252,6 +259,7 @@ void unprepare() {
     statementName = null;
     encodedStatementName = null;
     fields = null;
+    this.resultSetColumnNameIndexMap = null;
     portalDescribed = false;
     statementDescribed = false;
     cachedMaxResultRowSize = null;
@@ -269,9 +277,30 @@ public final int getBindCount() {
     return nativeQuery.bindPositions.length * getBatchSize();
   }
 
+  private Map<String, Integer> resultSetColumnNameIndexMap;
+
+  @Override
+  public Map<String, Integer> getResultSetColumnNameIndexMap() {
+    Map<String, Integer> columnPositions = this.resultSetColumnNameIndexMap;
+    if (columnPositions == null && fields != null) {
+      columnPositions =
+          PgResultSet.createColumnNameIndexMap(fields, sanitiserDisabled);
+      if (statementName != null) {
+        // Cache column positions for server-prepared statements only
+        this.resultSetColumnNameIndexMap = columnPositions;
+      }
+    }
+    return columnPositions;
+  }
+
+  @Override
+  public SqlCommand getSqlCommand() {
+    return nativeQuery.getCommand();
+  }
+
   private final NativeQuery nativeQuery;
 
-  private final ProtocolConnectionImpl protoConnection;
+  private final TypeTransferModeRegistry transferModeRegistry;
   private String statementName;
   private byte[] encodedStatementName;
   /**
@@ -283,8 +312,10 @@ public final int getBindCount() {
   private boolean hasBinaryFields;
   private boolean portalDescribed;
   private boolean statementDescribed;
+  private final boolean sanitiserDisabled;
   private PhantomReference<?> cleanupRef;
   private int[] preparedTypes;
+  private short deallocateEpoch;
 
   private Integer cachedMaxResultRowSize;
 
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v3/TypeTransferModeRegistry.java b/pgjdbc/src/main/java/org/postgresql/core/v3/TypeTransferModeRegistry.java
new file mode 100644
index 0000000000..3d1d5e9a32
--- /dev/null
+++ b/pgjdbc/src/main/java/org/postgresql/core/v3/TypeTransferModeRegistry.java
@@ -0,0 +1,17 @@
+package org.postgresql.core.v3;
+
+public interface TypeTransferModeRegistry {
+  /**
+   * Returns if given oid should be sent in binary format
+   * @param oid type oid
+   * @return true if given oid should be sent in binary format
+   */
+  boolean useBinaryForSend(int oid);
+
+  /**
+   * Returns if given oid should be received in binary format
+   * @param oid type oid
+   * @return true if given oid should be received in binary format
+   */
+  boolean useBinaryForReceive(int oid);
+}
diff --git a/pgjdbc/src/main/java/org/postgresql/core/v3/V3Query.java b/pgjdbc/src/main/java/org/postgresql/core/v3/V3Query.java
deleted file mode 100644
index b4fccb27c5..0000000000
--- a/pgjdbc/src/main/java/org/postgresql/core/v3/V3Query.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*-------------------------------------------------------------------------
-*
-* Copyright (c) 2004-2014, PostgreSQL Global Development Group
-* Copyright (c) 2004, Open Cloud Limited.
-*
-*
-*-------------------------------------------------------------------------
-*/
-
-package org.postgresql.core.v3;
-
-import org.postgresql.core.Query;
-
-/**
- * Common interface for all V3 query implementations.
- *
- * @author Oliver Jowett (oliver@opencloud.com)
- */
-interface V3Query extends Query {
-  /**
-   * Return a list of the SimpleQuery objects that make up this query. If this object is already a
-   * SimpleQuery, returns null (avoids an extra array construction in the common case).
-   *
-   * @return an array of single-statement queries, or <code>null</code> if this object is already a
-   *         single-statement query.
-   */
-  SimpleQuery[] getSubqueries();
-}
diff --git a/pgjdbc/src/main/java/org/postgresql/ds/common/BaseDataSource.java b/pgjdbc/src/main/java/org/postgresql/ds/common/BaseDataSource.java
index 7ea7985cab..776fd055da 100644
--- a/pgjdbc/src/main/java/org/postgresql/ds/common/BaseDataSource.java
+++ b/pgjdbc/src/main/java/org/postgresql/ds/common/BaseDataSource.java
@@ -9,6 +9,8 @@
 package org.postgresql.ds.common;
 
 import org.postgresql.PGProperty;
+import org.postgresql.jdbc.AutoSave;
+import org.postgresql.jdbc.PreferQueryMode;
 import org.postgresql.util.GT;
 import org.postgresql.util.PSQLException;
 import org.postgresql.util.PSQLState;
@@ -1228,6 +1230,38 @@ public int getLoglevel() {
     return PGProperty.LOG_LEVEL.getIntNoCheck(properties);
   }
 
+  /**
+   * @see PGProperty#PREFER_QUERY_MODE
+   * @return preferred query execution mode
+   */
+  public PreferQueryMode getPreferQueryMode() {
+    return PreferQueryMode.of(PGProperty.PREFER_QUERY_MODE.get(properties));
+  }
+
+  /**
+   * @see PGProperty#PREFER_QUERY_MODE
+   * @param preferQueryMode extended, simple, extendedForPrepared, or extendedCacheEveryting
+   */
+  public void setPreferQueryMode(PreferQueryMode preferQueryMode) {
+    PGProperty.PREFER_QUERY_MODE.set(properties, preferQueryMode.value());
+  }
+
+  /**
+   * @see PGProperty#AUTOSAVE
+   * @return connection configuration regarding automatic per-query savepoints
+   */
+  public AutoSave getAutosave() {
+    return AutoSave.of(PGProperty.AUTOSAVE.get(properties));
+  }
+
+  /**
+   * @see PGProperty#AUTOSAVE
+   * @param autoSave connection configuration regarding automatic per-query savepoints
+   */
+  public void setAutosave(AutoSave autoSave) {
+    PGProperty.AUTOSAVE.set(properties, autoSave.value());
+  }
+
   /**
    * @see PGProperty#REWRITE_BATCHED_INSERTS
    * @return boolean indicating property is enabled or not.
diff --git a/pgjdbc/src/main/java/org/postgresql/geometric/PGbox.java b/pgjdbc/src/main/java/org/postgresql/geometric/PGbox.java
index ed15c293df..38bc30ce00 100644
--- a/pgjdbc/src/main/java/org/postgresql/geometric/PGbox.java
+++ b/pgjdbc/src/main/java/org/postgresql/geometric/PGbox.java
@@ -72,11 +72,12 @@ public PGbox() {
    * @param value a string representation of the value of the object
    * @throws SQLException thrown if value is invalid for this type
    */
+  @Override
   public void setValue(String value) throws SQLException {
     PGtokenizer t = new PGtokenizer(value, ',');
     if (t.getSize() != 2) {
       throw new PSQLException(
-          GT.tr("Conversion to type {0} failed: {1}.", new Object[]{type, value}),
+          GT.tr("Conversion to type {0} failed: {1}.", type, value),
           PSQLState.DATA_TYPE_MISMATCH);
     }
 
diff --git a/pgjdbc/src/main/java/org/postgresql/geometric/PGcircle.java b/pgjdbc/src/main/java/org/postgresql/geometric/PGcircle.java
index 5921062a38..d1448ca856 100644
--- a/pgjdbc/src/main/java/org/postgresql/geometric/PGcircle.java
+++ b/pgjdbc/src/main/java/org/postgresql/geometric/PGcircle.java
@@ -70,10 +70,11 @@ public PGcircle() {
    * @param s definition of the circle in PostgreSQL's syntax.
    * @throws SQLException on conversion failure
    */
+  @Override
   public void setValue(String s) throws SQLException {
     PGtokenizer t = new PGtokenizer(PGtokenizer.removeAngle(s), ',');
     if (t.getSize() != 2) {
-      throw new PSQLException(GT.tr("Conversion to type {0} failed: {1}.", new Object[]{type, s}),
+      throw new PSQLException(GT.tr("Conversion to type {0} failed: {1}.", type, s),
           PSQLState.DATA_TYPE_MISMATCH);
     }
 
@@ -81,7 +82,7 @@ public void setValue(String s) throws SQLException {
       center = new PGpoint(t.getToken(0));
       radius = Double.parseDouble(t.getToken(1));
     } catch (NumberFormatException e) {
-      throw new PSQLException(GT.tr("Conversion to type {0} failed: {1}.", new Object[]{type, s}),
+      throw new PSQLException(GT.tr("Conversion to type {0} failed: {1}.", type, s),
           PSQLState.DATA_TYPE_MISMATCH, e);
     }
   }
diff --git a/pgjdbc/src/main/java/org/postgresql/geometric/PGline.java b/pgjdbc/src/main/java/org/postgresql/geometric/PGline.java
index 74fabd2f40..dccff9279f 100644
--- a/pgjdbc/src/main/java/org/postgresql/geometric/PGline.java
+++ b/pgjdbc/src/main/java/org/postgresql/geometric/PGline.java
@@ -102,11 +102,12 @@ public PGline() {
    * @param s Definition of the line in PostgreSQL's syntax
    * @throws SQLException on conversion failure
    */
+  @Override
   public void setValue(String s) throws SQLException {
     if (s.trim().startsWith("{")) {
       PGtokenizer t = new PGtokenizer(PGtokenizer.removeCurlyBrace(s), ',');
       if (t.getSize() != 3) {
-        throw new PSQLException(GT.tr("Conversion to type {0} failed: {1}.", new Object[]{type, s}),
+        throw new PSQLException(GT.tr("Conversion to type {0} failed: {1}.", type, s),
             PSQLState.DATA_TYPE_MISMATCH);
       }
       a = Double.parseDouble(t.getToken(0));
@@ -115,7 +116,7 @@ public void setValue(String s) throws SQLException {
     } else if (s.trim().startsWith("[")) {
       PGtokenizer t = new PGtokenizer(PGtokenizer.removeBox(s), ',');
       if (t.getSize() != 2) {
-        throw new PSQLException(GT.tr("Conversion to type {0} failed: {1}.", new Object[]{type, s}),
+        throw new PSQLException(GT.tr("Conversion to type {0} failed: {1}.", type, s),
             PSQLState.DATA_TYPE_MISMATCH);
       }
       PGpoint point1 = new PGpoint(t.getToken(0));
diff --git a/pgjdbc/src/main/java/org/postgresql/geometric/PGlseg.java b/pgjdbc/src/main/java/org/postgresql/geometric/PGlseg.java
index ef210a9210..5cb38725f9 100644
--- a/pgjdbc/src/main/java/org/postgresql/geometric/PGlseg.java
+++ b/pgjdbc/src/main/java/org/postgresql/geometric/PGlseg.java
@@ -66,10 +66,11 @@ public PGlseg() {
    * @param s Definition of the line segment in PostgreSQL's syntax
    * @throws SQLException on conversion failure
    */
+  @Override
   public void setValue(String s) throws SQLException {
     PGtokenizer t = new PGtokenizer(PGtokenizer.removeBox(s), ',');
     if (t.getSize() != 2) {
-      throw new PSQLException(GT.tr("Conversion to type {0} failed: {1}.", new Object[]{type, s}),
+      throw new PSQLException(GT.tr("Conversion to type {0} failed: {1}.", type, s),
           PSQLState.DATA_TYPE_MISMATCH);
     }
 
diff --git a/pgjdbc/src/main/java/org/postgresql/geometric/PGpoint.java b/pgjdbc/src/main/java/org/postgresql/geometric/PGpoint.java
index dfa50a8b16..475176f546 100644
--- a/pgjdbc/src/main/java/org/postgresql/geometric/PGpoint.java
+++ b/pgjdbc/src/main/java/org/postgresql/geometric/PGpoint.java
@@ -69,13 +69,14 @@ public PGpoint() {
    * @param s Definition of this point in PostgreSQL's syntax
    * @throws SQLException on conversion failure
    */
+  @Override
   public void setValue(String s) throws SQLException {
     PGtokenizer t = new PGtokenizer(PGtokenizer.removePara(s), ',');
     try {
       x = Double.parseDouble(t.getToken(0));
       y = Double.parseDouble(t.getToken(1));
     } catch (NumberFormatException e) {
-      throw new PSQLException(GT.tr("Conversion to type {0} failed: {1}.", new Object[]{type, s}),
+      throw new PSQLException(GT.tr("Conversion to type {0} failed: {1}.", type, s),
           PSQLState.DATA_TYPE_MISMATCH, e);
     }
   }
diff --git a/pgjdbc/src/main/java/org/postgresql/gss/GssAction.java b/pgjdbc/src/main/java/org/postgresql/gss/GssAction.java
index e87efc863c..24635209c8 100644
--- a/pgjdbc/src/main/java/org/postgresql/gss/GssAction.java
+++ b/pgjdbc/src/main/java/org/postgresql/gss/GssAction.java
@@ -93,19 +93,19 @@ public Exception run() {
             logger.debug(" FE=> Password(GSS Authentication Token)");
           }
 
-          pgStream.SendChar('p');
-          pgStream.SendInteger4(4 + outToken.length);
-          pgStream.Send(outToken);
+          pgStream.sendChar('p');
+          pgStream.sendInteger4(4 + outToken.length);
+          pgStream.send(outToken);
           pgStream.flush();
         }
 
         if (!secContext.isEstablished()) {
-          int response = pgStream.ReceiveChar();
+          int response = pgStream.receiveChar();
           // Error
           if (response == 'E') {
-            int l_elen = pgStream.ReceiveInteger4();
+            int l_elen = pgStream.receiveInteger4();
             ServerErrorMessage l_errorMsg =
-                new ServerErrorMessage(pgStream.ReceiveString(l_elen - 4), logger.getLogLevel());
+                new ServerErrorMessage(pgStream.receiveErrorString(l_elen - 4), logger.getLogLevel());
 
             if (logger.logDebug()) {
               logger.debug(" <=BE ErrorMessage(" + l_errorMsg + ")");
@@ -119,10 +119,10 @@ public Exception run() {
               logger.debug(" <=BE AuthenticationGSSContinue");
             }
 
-            int len = pgStream.ReceiveInteger4();
-            int type = pgStream.ReceiveInteger4();
+            int len = pgStream.receiveInteger4();
+            int type = pgStream.receiveInteger4();
             // should check type = 8
-            inToken = pgStream.Receive(len - 8);
+            inToken = pgStream.receive(len - 8);
           } else {
             // Unknown/unexpected message type.
             return new PSQLException(GT.tr("Protocol error.  Session setup failed."),
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/AutoSave.java b/pgjdbc/src/main/java/org/postgresql/jdbc/AutoSave.java
new file mode 100644
index 0000000000..e45dbb67e9
--- /dev/null
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/AutoSave.java
@@ -0,0 +1,21 @@
+package org.postgresql.jdbc;
+
+public enum AutoSave {
+  NEVER,
+  ALWAYS,
+  CONSERVATIVE;
+
+  private final String value;
+
+  AutoSave() {
+    value = this.name().toLowerCase();
+  }
+
+  public String value() {
+    return value;
+  }
+
+  public static AutoSave of(String value) {
+    return valueOf(value.toUpperCase());
+  }
+}
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/BatchResultHandler.java b/pgjdbc/src/main/java/org/postgresql/jdbc/BatchResultHandler.java
index b31038ab3d..c9d63199cf 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/BatchResultHandler.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/BatchResultHandler.java
@@ -1,10 +1,18 @@
+/*-------------------------------------------------------------------------
+*
+* Copyright (c) 2016-2016, PostgreSQL Global Development Group
+*
+*
+*-------------------------------------------------------------------------
+*/
+
 package org.postgresql.jdbc;
 
 import org.postgresql.core.Field;
 import org.postgresql.core.ParameterList;
 import org.postgresql.core.Query;
 import org.postgresql.core.ResultCursor;
-import org.postgresql.core.ResultHandler;
+import org.postgresql.core.ResultHandlerBase;
 import org.postgresql.core.v3.BatchedQuery;
 import org.postgresql.util.GT;
 import org.postgresql.util.PSQLException;
@@ -22,9 +30,8 @@
 /**
  * Internal class, it is not a part of public API.
  */
-public class BatchResultHandler implements ResultHandler {
+public class BatchResultHandler extends ResultHandlerBase {
   private PgStatement pgStatement;
-  private BatchUpdateException batchException = null;
   private int resultIndex = 0;
 
   private final Query[] queries;
@@ -75,7 +82,7 @@ public void handleCommandStatus(String status, int updateCount, long insertOID)
       resultIndex--;
       // If exception thrown, no need to collect generated keys
       // Note: some generated keys might be secured in generatedKeys
-      if (updateCount > 0 && batchException == null) {
+      if (updateCount > 0 && (getException() == null || isAutoCommit())) {
         allGeneratedRows.add(latestGeneratedRows);
         if (generatedKeys == null) {
           generatedKeys = latestGeneratedKeysRs;
@@ -94,14 +101,20 @@ public void handleCommandStatus(String status, int updateCount, long insertOID)
     updateCounts[resultIndex++] = updateCount;
   }
 
-  public void secureProgress() {
+  private boolean isAutoCommit() {
     try {
-      if (batchException == null && pgStatement.getConnection().getAutoCommit()) {
-        committedRows = resultIndex;
-        updateGeneratedKeys();
-      }
+      return pgStatement.getConnection().getAutoCommit();
     } catch (SQLException e) {
-        /* Should not get here */
+      assert false : "pgStatement.getConnection().getAutoCommit() should not throw";
+      return false;
+    }
+  }
+
+  @Override
+  public void secureProgress() {
+    if (isAutoCommit()) {
+      committedRows = resultIndex;
+      updateGeneratedKeys();
     }
   }
 
@@ -119,8 +132,9 @@ public void handleWarning(SQLWarning warning) {
     pgStatement.addWarning(warning);
   }
 
+  @Override
   public void handleError(SQLException newError) {
-    if (batchException == null) {
+    if (getException() == null) {
       Arrays.fill(updateCounts, committedRows, updateCounts.length, Statement.EXECUTE_FAILED);
       if (allGeneratedRows != null) {
         allGeneratedRows.clear();
@@ -131,20 +145,35 @@ public void handleError(SQLException newError) {
         queryString = queries[resultIndex].toString(parameterLists[resultIndex]);
       }
 
-      batchException = new BatchUpdateException(
-          GT.tr("Batch entry {0} {1} was aborted.  Call getNextException to see the cause.",
-              new Object[]{resultIndex, queryString}),
-          newError.getSQLState(), uncompressUpdateCount());
+      super.handleError(new BatchUpdateException(
+          GT.tr("Batch entry {0} {1} was aborted: {2}  Call getNextException to see the cause.",
+              resultIndex, queryString, newError.getMessage()),
+          newError.getSQLState(), uncompressUpdateCount()));
     }
+    resultIndex++;
 
-    batchException.setNextException(newError);
+    super.handleError(newError);
   }
 
   public void handleCompletion() throws SQLException {
+    updateGeneratedKeys();
+    SQLException batchException = getException();
     if (batchException != null) {
+      if (isAutoCommit()) {
+        // Re-create batch exception since rows after exception might indeed succeed.
+        BatchUpdateException newException = new BatchUpdateException(
+            batchException.getMessage(),
+            batchException.getSQLState(),
+            uncompressUpdateCount()
+        );
+        SQLException next = batchException.getNextException();
+        if (next != null) {
+          newException.setNextException(next);
+        }
+        batchException = newException;
+      }
       throw batchException;
     }
-    updateGeneratedKeys();
   }
 
   public ResultSet getGeneratedKeys() {
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/CachedQueryCreateAction.java b/pgjdbc/src/main/java/org/postgresql/jdbc/CachedQueryCreateAction.java
deleted file mode 100644
index fbd36a6a33..0000000000
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/CachedQueryCreateAction.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*-------------------------------------------------------------------------
-*
-* Copyright (c) 2015, PostgreSQL Global Development Group
-*
-*
-*-------------------------------------------------------------------------
-*/
-
-package org.postgresql.jdbc;
-
-import org.postgresql.core.CachedQuery;
-import org.postgresql.core.JdbcCallParseInfo;
-import org.postgresql.core.Parser;
-import org.postgresql.core.Query;
-import org.postgresql.util.LruCache;
-
-import java.sql.SQLException;
-
-/**
- * Creates an instance of {@link CachedQuery} for a given connection.
- */
-class CachedQueryCreateAction implements LruCache.CreateAction<Object, CachedQuery> {
-  private final int serverVersionNum;
-  private final PgConnection connection;
-
-  public CachedQueryCreateAction(PgConnection connection, int serverVersionNum) {
-    this.connection = connection;
-    this.serverVersionNum = serverVersionNum;
-  }
-
-  @Override
-  public CachedQuery create(Object key) throws SQLException {
-    String sql = key == null ? null : key.toString();
-    String parsedSql =
-        PgStatement.replaceProcessing(sql, true, connection.getStandardConformingStrings());
-    boolean isFunction;
-    boolean outParmBeforeFunc;
-    if (key instanceof CallableQueryKey) {
-      JdbcCallParseInfo callInfo =
-          Parser.modifyJdbcCall(parsedSql, connection.getStandardConformingStrings(),
-              serverVersionNum, connection.getProtocolVersion());
-      parsedSql = callInfo.getSql();
-      isFunction = callInfo.isFunction();
-      outParmBeforeFunc = callInfo.isOutParmBeforeFunc();
-    } else {
-      isFunction = false;
-      outParmBeforeFunc = false;
-    }
-    Query query = connection.getQueryExecutor().createParameterizedQuery(parsedSql, connection.getAutoCommit());
-    return new CachedQuery(key, query, isFunction, outParmBeforeFunc);
-  }
-}
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/CallableBatchResultHandler.java b/pgjdbc/src/main/java/org/postgresql/jdbc/CallableBatchResultHandler.java
index f89421688d..3e49405b6c 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/CallableBatchResultHandler.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/CallableBatchResultHandler.java
@@ -1,3 +1,11 @@
+/*-------------------------------------------------------------------------
+*
+* Copyright (c) 2016-2016, PostgreSQL Global Development Group
+*
+*
+*-------------------------------------------------------------------------
+*/
+
 package org.postgresql.jdbc;
 
 import org.postgresql.core.Field;
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/CallableQueryKey.java b/pgjdbc/src/main/java/org/postgresql/jdbc/CallableQueryKey.java
deleted file mode 100644
index 0a3ef5443d..0000000000
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/CallableQueryKey.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*-------------------------------------------------------------------------
-*
-* Copyright (c) 2015, PostgreSQL Global Development Group
-*
-*
-*-------------------------------------------------------------------------
-*/
-
-package org.postgresql.jdbc;
-
-/**
- * Serves as a cache key for callable statements. For regular statements, just sql string is used as
- * a key.
- */
-class CallableQueryKey {
-  public final String sql;
-
-  public CallableQueryKey(String sql) {
-    this.sql = sql;
-  }
-
-  @Override
-  public String toString() {
-    return sql;
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this == o) {
-      return true;
-    }
-    if (!(o instanceof CallableQueryKey)) {
-      return false;
-    }
-
-    CallableQueryKey that = (CallableQueryKey) o;
-
-    return sql == null ? that.sql == null : sql.equals(that.sql);
-
-  }
-
-  @Override
-  public int hashCode() {
-    return sql == null ? 0 : sql.hashCode();
-  }
-}
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/PgArray.java b/pgjdbc/src/main/java/org/postgresql/jdbc/PgArray.java
index 5ed6a5a0ab..3fd522667c 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/PgArray.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/PgArray.java
@@ -185,7 +185,7 @@ public Object getArrayImpl(long index, int count, Map<String, Class<?>> map) thr
     if ((--index) + count > arrayList.size()) {
       throw new PSQLException(
           GT.tr("The array index is out of range: {0}, number of elements: {1}.",
-              new Object[]{index + count, (long) arrayList.size()}),
+              index + count, (long) arrayList.size()),
           PSQLState.DATA_ERROR);
     }
 
@@ -841,7 +841,7 @@ public ResultSet getResultSetImpl(long index, int count, Map<String, Class<?>> m
     if ((--index) + count > arrayList.size()) {
       throw new PSQLException(
           GT.tr("The array index is out of range: {0}, number of elements: {1}.",
-              new Object[]{index + count, (long) arrayList.size()}),
+                  index + count, (long) arrayList.size()),
           PSQLState.DATA_ERROR);
     }
 
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/PgCallableStatement.java b/pgjdbc/src/main/java/org/postgresql/jdbc/PgCallableStatement.java
index e35235b7c7..7acac41057 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/PgCallableStatement.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/PgCallableStatement.java
@@ -49,7 +49,7 @@ class PgCallableStatement extends PgPreparedStatement implements CallableStateme
 
   PgCallableStatement(PgConnection connection, String sql, int rsType, int rsConcurrency,
       int rsHoldability) throws SQLException {
-    super(connection, sql, true, rsType, rsConcurrency, rsHoldability);
+    super(connection, connection.borrowCallableQuery(sql), rsType, rsConcurrency, rsHoldability);
     this.isFunction = preparedQuery.isFunction;
     this.outParmBeforeFunc = preparedQuery.outParmBeforeFunc;
 
@@ -133,11 +133,16 @@ public boolean executeWithFlags(int flags) throws SQLException {
           if (callResult[j] != null) {
             callResult[j] = ((Double) callResult[j]).floatValue();
           }
+          //#if mvn.project.property.postgresql.jdbc.spec >= "JDBC4.2"
+        } else if (columnType == Types.REF_CURSOR && functionReturnType[j] == Types.OTHER) {
+          // For backwards compatibility reasons we support that ref cursors can be
+          // registered with both Types.OTHER and Types.REF_CURSOR so we allow
+          // this specific mismatch
+          //#endif
         } else {
           throw new PSQLException(GT.tr(
               "A CallableStatement function was executed and the out parameter {0} was of type {1} however type {2} was registered.",
-              new Object[]{i + 1, "java.sql.Types=" + columnType,
-                  "java.sql.Types=" + functionReturnType[j]}),
+              i + 1, "java.sql.Types=" + columnType, "java.sql.Types=" + functionReturnType[j]),
               PSQLState.DATA_TYPE_MISMATCH);
         }
       }
@@ -374,8 +379,8 @@ protected void checkIndex(int parameterIndex, int type1, int type2, String getNa
         && type2 != this.testReturn[parameterIndex - 1]) {
       throw new PSQLException(
           GT.tr("Parameter of type {0} was registered, but call to get{1} (sqltype={2}) was made.",
-              new Object[]{"java.sql.Types=" + testReturn[parameterIndex - 1], getName,
-                  "java.sql.Types=" + type1}),
+                  "java.sql.Types=" + testReturn[parameterIndex - 1], getName,
+                  "java.sql.Types=" + type1),
           PSQLState.MOST_SPECIFIC_TYPE_DOES_NOT_MATCH);
     }
   }
@@ -393,8 +398,8 @@ protected void checkIndex(int parameterIndex, int type, String getName) throws S
     if (type != this.testReturn[parameterIndex - 1]) {
       throw new PSQLException(
           GT.tr("Parameter of type {0} was registered, but call to get{1} (sqltype={2}) was made.",
-              new Object[]{"java.sql.Types=" + testReturn[parameterIndex - 1], getName,
-                  "java.sql.Types=" + type}),
+              "java.sql.Types=" + testReturn[parameterIndex - 1], getName,
+                  "java.sql.Types=" + type),
           PSQLState.MOST_SPECIFIC_TYPE_DOES_NOT_MATCH);
     }
   }
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/PgConnection.java b/pgjdbc/src/main/java/org/postgresql/jdbc/PgConnection.java
index 78d37b3164..cb88823526 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/PgConnection.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/PgConnection.java
@@ -17,16 +17,15 @@
 import org.postgresql.core.CachedQuery;
 import org.postgresql.core.ConnectionFactory;
 import org.postgresql.core.Encoding;
-import org.postgresql.core.Field;
 import org.postgresql.core.Logger;
 import org.postgresql.core.Oid;
-import org.postgresql.core.ProtocolConnection;
 import org.postgresql.core.Provider;
 import org.postgresql.core.Query;
 import org.postgresql.core.QueryExecutor;
-import org.postgresql.core.ResultCursor;
-import org.postgresql.core.ResultHandler;
+import org.postgresql.core.ResultHandlerBase;
 import org.postgresql.core.ServerVersion;
+import org.postgresql.core.SqlCommand;
+import org.postgresql.core.TransactionState;
 import org.postgresql.core.TypeInfo;
 import org.postgresql.core.Utils;
 import org.postgresql.core.Version;
@@ -63,7 +62,6 @@
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.NoSuchElementException;
@@ -97,7 +95,7 @@ public class PgConnection implements BaseConnection {
   private Throwable openStackTrace;
 
   /* Actual network handler */
-  private final ProtocolConnection protoConnection;
+  private final QueryExecutor queryExecutor;
   /* Compatible version as xxyyzz form */
   private final int compatibleInt;
 
@@ -133,34 +131,43 @@ public class PgConnection implements BaseConnection {
   // Bind String to UNSPECIFIED or VARCHAR?
   private final boolean bindStringAsVarchar;
 
-  // Current warnings; there might be more on protoConnection too.
+  // Current warnings; there might be more on queryExecutor too.
   private SQLWarning firstWarning = null;
 
-  /**
-   * Set of oids that use binary transfer when sending to server.
-   */
-  private Set<Integer> useBinarySendForOids;
-  /**
-   * Set of oids that use binary transfer when receiving from server.
-   */
-  private Set<Integer> useBinaryReceiveForOids;
-
   // Timer for scheduling TimerTasks for this connection.
   // Only instantiated if a task is actually scheduled.
   private volatile Timer cancelTimer = null;
 
-  private final LruCache<Object, CachedQuery> statementCache;
+  private PreparedStatement checkConnectionQuery;
+
   private final LruCache<FieldMetadata.Key, FieldMetadata> fieldMetadataCache;
 
-  private boolean reWriteBatchedInserts = false;
+  final CachedQuery borrowQuery(String sql) throws SQLException {
+    return queryExecutor.borrowQuery(sql);
+  }
 
-  CachedQuery borrowQuery(String sql, boolean isCallable) throws SQLException {
-    Object key = isCallable ? new CallableQueryKey(sql) : sql;
-    return statementCache.borrow(key);
+  final CachedQuery borrowCallableQuery(String sql) throws SQLException {
+    return queryExecutor.borrowCallableQuery(sql);
+  }
+
+  private CachedQuery borrowReturningQuery(String sql, String[] columnNames) throws SQLException {
+    return queryExecutor.borrowReturningQuery(sql, columnNames);
+  }
+
+  @Override
+  public CachedQuery createQuery(String sql, boolean escapeProcessing, boolean isParameterized,
+      String... columnNames)
+      throws SQLException {
+    return queryExecutor.createQuery(sql, escapeProcessing, isParameterized, columnNames);
   }
 
   void releaseQuery(CachedQuery cachedQuery) {
-    statementCache.put(cachedQuery.key, cachedQuery);
+    queryExecutor.releaseQuery(cachedQuery);
+  }
+
+  @Override
+  public void setFlushCacheOnDeallocate(boolean flushCacheOnDeallocate) {
+    queryExecutor.setFlushCacheOnDeallocate(flushCacheOnDeallocate);
   }
 
   //
@@ -208,7 +215,7 @@ public PgConnection(HostSpec[] hostSpecs,
     }
 
     // Now make the initial connection and set up local state
-    this.protoConnection =
+    this.queryExecutor =
         ConnectionFactory.openConnection(hostSpecs, user, database, info, logger);
     int compat = Utils.parseServerVersionStr(PGProperty.COMPATIBLE.get(info));
     if (compat == 0) {
@@ -223,7 +230,7 @@ public PgConnection(HostSpec[] hostSpecs,
 
     // Formats that currently have binary protocol support
     Set<Integer> binaryOids = new HashSet<Integer>();
-    if (binaryTransfer && protoConnection.getProtocolVersion() >= 3) {
+    if (binaryTransfer && queryExecutor.getProtocolVersion() >= 3) {
       binaryOids.add(Oid.BYTEA);
       binaryOids.add(Oid.INT2);
       binaryOids.add(Oid.INT4);
@@ -271,9 +278,10 @@ public PgConnection(HostSpec[] hostSpecs,
     binaryOids.removeAll(getOidSet(PGProperty.BINARY_TRANSFER_DISABLE.get(info)));
 
     // split for receive and send for better control
-    useBinarySendForOids = new HashSet<Integer>();
+    Set<Integer> useBinarySendForOids = new HashSet<Integer>();
     useBinarySendForOids.addAll(binaryOids);
-    useBinaryReceiveForOids = new HashSet<Integer>();
+
+    Set<Integer> useBinaryReceiveForOids = new HashSet<Integer>();
     useBinaryReceiveForOids.addAll(binaryOids);
 
     /*
@@ -282,7 +290,8 @@ public PgConnection(HostSpec[] hostSpecs,
      */
     useBinarySendForOids.remove(Oid.DATE);
 
-    protoConnection.setBinaryReceiveOids(useBinaryReceiveForOids);
+    queryExecutor.setBinaryReceiveOids(useBinaryReceiveForOids);
+    queryExecutor.setBinarySendOids(useBinarySendForOids);
 
     if (logger.logDebug()) {
       logger.debug("    compatible = " + compatibleInt);
@@ -290,7 +299,7 @@ public PgConnection(HostSpec[] hostSpecs,
       logger.debug("    prepare threshold = " + prepareThreshold);
       logger.debug("    types using binary send = " + oidsToString(useBinarySendForOids));
       logger.debug("    types using binary receive = " + oidsToString(useBinaryReceiveForOids));
-      logger.debug("    integer date/time = " + protoConnection.getIntegerDateTimes());
+      logger.debug("    integer date/time = " + queryExecutor.getIntegerDateTimes());
     }
 
     //
@@ -314,17 +323,19 @@ public PgConnection(HostSpec[] hostSpecs,
 
     // Initialize timestamp stuff
     timestampUtils = new TimestampUtils(haveMinimumServerVersion(ServerVersion.v7_4),
-        haveMinimumServerVersion(ServerVersion.v8_2), !protoConnection.getIntegerDateTimes(),
+        haveMinimumServerVersion(ServerVersion.v8_2), !queryExecutor.getIntegerDateTimes(),
         new Provider<TimeZone>() {
           @Override
           public TimeZone get() {
-            return protoConnection.getTimeZone();
+            return queryExecutor.getTimeZone();
           }
         });
 
     // Initialize common queries.
-    commitQuery = getQueryExecutor().createSimpleQuery("COMMIT", getAutoCommit());
-    rollbackQuery = getQueryExecutor().createSimpleQuery("ROLLBACK", getAutoCommit());
+    // isParameterized==true so full parse is performed and the engine knows the query
+    // is not a compound query with ; inside, so it could use parse/bind/exec messages
+    commitQuery = createQuery("COMMIT", false, true).query;
+    rollbackQuery = createQuery("ROLLBACK", false, true).query;
 
     int unknownLength = PGProperty.UNKNOWN_LENGTH.getInt(info);
 
@@ -336,17 +347,6 @@ public TimeZone get() {
       openStackTrace = new Throwable("Connection was created at this point:");
     }
     this.disableColumnSanitiser = PGProperty.DISABLE_COLUMN_SANITISER.getBoolean(info);
-    statementCache = new LruCache<Object, CachedQuery>(
-        Math.max(0, PGProperty.PREPARED_STATEMENT_CACHE_QUERIES.getInt(info)),
-        Math.max(0, PGProperty.PREPARED_STATEMENT_CACHE_SIZE_MIB.getInt(info) * 1024 * 1024),
-        false,
-        new CachedQueryCreateAction(this, protoConnection.getServerVersionNum()),
-        new LruCache.EvictAction<CachedQuery>() {
-          @Override
-          public void evict(CachedQuery cachedQuery) throws SQLException {
-            cachedQuery.query.close();
-          }
-        });
 
     TypeInfo types1 = getTypeInfo();
     if (haveMinimumServerVersion(ServerVersion.v8_3)) {
@@ -367,8 +367,6 @@ public void evict(CachedQuery cachedQuery) throws SQLException {
       this._clientInfo.put("ApplicationName", appName);
     }
 
-    reWriteBatchedInserts = PGProperty.REWRITE_BATCHED_INSERTS.getBoolean(info);
-
     fieldMetadataCache = new LruCache<FieldMetadata.Key, FieldMetadata>(
             Math.max(0, PGProperty.DATABASE_METADATA_CACHE_FIELDS.getInt(info)),
             Math.max(0, PGProperty.DATABASE_METADATA_CACHE_FIELDS_MIB.getInt(info) * 1024 * 1024),
@@ -432,7 +430,7 @@ public Map<String, Class<?>> getTypeMap() throws SQLException {
   }
 
   public QueryExecutor getQueryExecutor() {
-    return protoConnection.getQueryExecutor();
+    return queryExecutor;
   }
 
   /**
@@ -541,7 +539,7 @@ public String getURL() throws SQLException {
    * @throws SQLException just in case...
    */
   public String getUserName() throws SQLException {
-    return protoConnection.getUser();
+    return queryExecutor.getUser();
   }
 
   public Fastpath getFastpathAPI() throws SQLException {
@@ -640,6 +638,7 @@ public TypeInfo getTypeInfo() {
     return _typeCache;
   }
 
+  @Override
   public void addDataType(String type, String name) {
     try {
       addDataType(type, Class.forName(name).asSubclass(PGobject.class));
@@ -648,6 +647,7 @@ public void addDataType(String type, String name) {
     }
   }
 
+  @Override
   public void addDataType(String type, Class<? extends PGobject> klass) throws SQLException {
     checkClosed();
     _typeCache.addDataType(type, klass);
@@ -680,7 +680,7 @@ private void initObjectTypes(Properties info) throws SQLException {
         } catch (ClassNotFoundException cnfe) {
           throw new PSQLException(
               GT.tr("Unable to load the class {0} responsible for the datatype {1}",
-                  new Object[]{className, typeName}),
+                  className, typeName),
               PSQLState.SYSTEM_ERROR, cnfe);
         }
 
@@ -697,20 +697,20 @@ private void initObjectTypes(Properties info) throws SQLException {
    */
   public void close() throws SQLException {
     releaseTimer();
-    protoConnection.close();
+    queryExecutor.close();
     openStackTrace = null;
   }
 
   public String nativeSQL(String sql) throws SQLException {
     checkClosed();
-    StringBuilder buf = new StringBuilder(sql.length());
-    PgStatement.parseSql(sql, 0, buf, false, getStandardConformingStrings());
-    return buf.toString();
+    CachedQuery cachedQuery = queryExecutor.createQuery(sql, false, true);
+
+    return cachedQuery.query.getNativeSql();
   }
 
   public synchronized SQLWarning getWarnings() throws SQLException {
     checkClosed();
-    SQLWarning newWarnings = protoConnection.getWarnings(); // NB: also clears them.
+    SQLWarning newWarnings = queryExecutor.getWarnings(); // NB: also clears them.
     if (firstWarning == null) {
       firstWarning = newWarnings;
     } else {
@@ -722,14 +722,14 @@ public synchronized SQLWarning getWarnings() throws SQLException {
 
   public synchronized void clearWarnings() throws SQLException {
     checkClosed();
-    protoConnection.getWarnings(); // Clear and discard.
+    queryExecutor.getWarnings(); // Clear and discard.
     firstWarning = null;
   }
 
 
   public void setReadOnly(boolean readOnly) throws SQLException {
     checkClosed();
-    if (protoConnection.getTransactionState() != ProtocolConnection.TRANSACTION_IDLE) {
+    if (queryExecutor.getTransactionState() != TransactionState.IDLE) {
       throw new PSQLException(
           GT.tr("Cannot change transaction read-only property in the middle of a transaction."),
           PSQLState.ACTIVE_SQL_TRANSACTION);
@@ -775,7 +775,17 @@ private void executeTransactionCommand(Query query) throws SQLException {
       flags |= QueryExecutor.QUERY_ONESHOT;
     }
 
-    getQueryExecutor().execute(query, null, new TransactionCommandHandler(), 0, 0, flags);
+    try {
+      getQueryExecutor().execute(query, null, new TransactionCommandHandler(), 0, 0, flags);
+    } catch (SQLException e) {
+      // Don't retry composite queries as it might get partially executed
+      if (query.getSubqueries() != null || !queryExecutor.willHealOnRetry(e)) {
+        throw e;
+      }
+      query.close();
+      // retry
+      getQueryExecutor().execute(query, null, new TransactionCommandHandler(), 0, 0, flags);
+    }
   }
 
   public void commit() throws SQLException {
@@ -786,7 +796,7 @@ public void commit() throws SQLException {
           PSQLState.NO_ACTIVE_SQL_TRANSACTION);
     }
 
-    if (protoConnection.getTransactionState() != ProtocolConnection.TRANSACTION_IDLE) {
+    if (queryExecutor.getTransactionState() != TransactionState.IDLE) {
       executeTransactionCommand(commitQuery);
     }
   }
@@ -807,13 +817,13 @@ public void rollback() throws SQLException {
           PSQLState.NO_ACTIVE_SQL_TRANSACTION);
     }
 
-    if (protoConnection.getTransactionState() != ProtocolConnection.TRANSACTION_IDLE) {
+    if (queryExecutor.getTransactionState() != TransactionState.IDLE) {
       executeTransactionCommand(rollbackQuery);
     }
   }
 
-  public int getTransactionState() {
-    return protoConnection.getTransactionState();
+  public TransactionState getTransactionState() {
+    return queryExecutor.getTransactionState();
   }
 
   public int getTransactionIsolation() throws SQLException {
@@ -875,7 +885,7 @@ public int getTransactionIsolation() throws SQLException {
   public void setTransactionIsolation(int level) throws SQLException {
     checkClosed();
 
-    if (protoConnection.getTransactionState() != ProtocolConnection.TRANSACTION_IDLE) {
+    if (queryExecutor.getTransactionState() != TransactionState.IDLE) {
       throw new PSQLException(
           GT.tr("Cannot change transaction isolation level in the middle of a transaction."),
           PSQLState.ACTIVE_SQL_TRANSACTION);
@@ -915,7 +925,7 @@ public void setCatalog(String catalog) throws SQLException {
 
   public String getCatalog() throws SQLException {
     checkClosed();
-    return protoConnection.getDatabase();
+    return queryExecutor.getDatabase();
   }
 
   /**
@@ -943,7 +953,7 @@ protected void finalize() throws Throwable {
    * @return server version number
    */
   public String getDBVersionNumber() {
-    return protoConnection.getServerVersion();
+    return queryExecutor.getServerVersion();
   }
 
   /**
@@ -953,7 +963,7 @@ public String getDBVersionNumber() {
    */
   public int getServerMajorVersion() {
     try {
-      StringTokenizer versionTokens = new StringTokenizer(protoConnection.getServerVersion(), "."); // aaXbb.ccYdd
+      StringTokenizer versionTokens = new StringTokenizer(queryExecutor.getServerVersion(), "."); // aaXbb.ccYdd
       return integerPart(versionTokens.nextToken()); // return X
     } catch (NoSuchElementException e) {
       return 0;
@@ -967,7 +977,7 @@ public int getServerMajorVersion() {
    */
   public int getServerMinorVersion() {
     try {
-      StringTokenizer versionTokens = new StringTokenizer(protoConnection.getServerVersion(), "."); // aaXbb.ccYdd
+      StringTokenizer versionTokens = new StringTokenizer(queryExecutor.getServerVersion(), "."); // aaXbb.ccYdd
       versionTokens.nextToken(); // Skip aaXbb
       return integerPart(versionTokens.nextToken()); // return Y
     } catch (NoSuchElementException e) {
@@ -981,14 +991,14 @@ public boolean haveMinimumServerVersion(String ver) {
       /*
        * Failed to parse input version. Fall back on legacy behaviour for BC.
        */
-      return (protoConnection.getServerVersion().compareTo(ver) >= 0);
+      return (queryExecutor.getServerVersion().compareTo(ver) >= 0);
     } else {
       return haveMinimumServerVersion(requiredver);
     }
   }
 
   public boolean haveMinimumServerVersion(int ver) {
-    return protoConnection.getServerVersionNum() >= ver;
+    return queryExecutor.getServerVersionNum() >= ver;
   }
 
   public boolean haveMinimumServerVersion(Version ver) {
@@ -1009,7 +1019,7 @@ public boolean haveMinimumCompatibleVersion(Version ver) {
 
 
   public Encoding getEncoding() {
-    return protoConnection.getEncoding();
+    return queryExecutor.getEncoding();
   }
 
   public byte[] encodeString(String str) throws SQLException {
@@ -1022,63 +1032,44 @@ public byte[] encodeString(String str) throws SQLException {
   }
 
   public String escapeString(String str) throws SQLException {
-    return Utils.escapeLiteral(null, str, protoConnection.getStandardConformingStrings())
+    return Utils.escapeLiteral(null, str, queryExecutor.getStandardConformingStrings())
         .toString();
   }
 
   public boolean getStandardConformingStrings() {
-    return protoConnection.getStandardConformingStrings();
+    return queryExecutor.getStandardConformingStrings();
   }
 
   // This is a cache of the DatabaseMetaData instance for this connection
   protected java.sql.DatabaseMetaData metadata;
 
   public boolean isClosed() throws SQLException {
-    return protoConnection.isClosed();
+    return queryExecutor.isClosed();
   }
 
   public void cancelQuery() throws SQLException {
     checkClosed();
-    protoConnection.sendQueryCancel();
+    queryExecutor.sendQueryCancel();
   }
 
   public PGNotification[] getNotifications() throws SQLException {
     checkClosed();
     getQueryExecutor().processNotifies();
     // Backwards-compatibility hand-holding.
-    PGNotification[] notifications = protoConnection.getNotifications();
+    PGNotification[] notifications = queryExecutor.getNotifications();
     return (notifications.length == 0 ? null : notifications);
   }
 
   /**
    * Handler for transaction queries
    */
-  private class TransactionCommandHandler implements ResultHandler {
-    private SQLException error;
-
-    public void handleResultRows(Query fromQuery, Field[] fields, List<byte[][]> tuples,
-        ResultCursor cursor) {
-    }
-
-    public void handleCommandStatus(String status, int updateCount, long insertOID) {
-    }
-
-    public void handleWarning(SQLWarning warning) {
-      PgConnection.this.addWarning(warning);
-    }
-
-    public void handleError(SQLException newError) {
-      if (error == null) {
-        error = newError;
-      } else {
-        error.setNextException(newError);
-      }
-    }
-
+  private class TransactionCommandHandler extends ResultHandlerBase {
     public void handleCompletion() throws SQLException {
-      if (error != null) {
-        throw error;
+      SQLWarning warning = getWarning();
+      if (warning != null) {
+        PgConnection.this.addWarning(warning);
       }
+      super.handleCompletion();
     }
   }
 
@@ -1115,22 +1106,12 @@ public void setTypeMapImpl(Map<String, Class<?>> map) throws SQLException {
     typemap = map;
   }
 
-  @Override
-  public boolean isReWriteBatchedInsertsEnabled() {
-    return this.reWriteBatchedInserts;
-  }
-
-  public void setReWriteBatchedInserts(boolean reWrite) {
-    this.reWriteBatchedInserts = reWrite;
-  }
-
   public Logger getLogger() {
     return logger;
   }
 
-
   public int getProtocolVersion() {
-    return protoConnection.getProtocolVersion();
+    return queryExecutor.getProtocolVersion();
   }
 
   public boolean getStringVarcharFlag() {
@@ -1148,11 +1129,11 @@ public CopyManager getCopyAPI() throws SQLException {
   }
 
   public boolean binaryTransferSend(int oid) {
-    return useBinarySendForOids.contains(oid);
+    return queryExecutor.useBinaryForSend(oid);
   }
 
   public int getBackendPID() {
-    return protoConnection.getBackendPID();
+    return queryExecutor.getBackendPID();
   }
 
   public boolean isColumnSanitiserDisabled() {
@@ -1163,8 +1144,23 @@ public void setDisableColumnSanitiser(boolean disableColumnSanitiser) {
     this.disableColumnSanitiser = disableColumnSanitiser;
   }
 
+  @Override
+  public PreferQueryMode getPreferQueryMode() {
+    return queryExecutor.getPreferQueryMode();
+  }
+
+  @Override
+  public AutoSave getAutosave() {
+    return queryExecutor.getAutoSave();
+  }
+
+  @Override
+  public void setAutosave(AutoSave autoSave) {
+    queryExecutor.setAutoSave(autoSave);
+  }
+
   protected void abort() {
-    protoConnection.abort();
+    queryExecutor.abort();
   }
 
   private synchronized Timer getTimer() {
@@ -1198,7 +1194,7 @@ public String escapeIdentifier(String identifier) throws SQLException {
   }
 
   public String escapeLiteral(String literal) throws SQLException {
-    return Utils.escapeLiteral(null, literal, protoConnection.getStandardConformingStrings())
+    return Utils.escapeLiteral(null, literal, queryExecutor.getStandardConformingStrings())
         .toString();
   }
 
@@ -1343,33 +1339,28 @@ public Array createArrayOf(String typeName, Object[] elements) throws SQLExcepti
   }
 
   public boolean isValid(int timeout) throws SQLException {
-    if (isClosed()) {
-      return false;
-    }
     if (timeout < 0) {
       throw new PSQLException(GT.tr("Invalid timeout ({0}<0).", timeout),
           PSQLState.INVALID_PARAMETER_VALUE);
     }
-    boolean valid = false;
-    Statement stmt = null;
+    if (isClosed()) {
+      return false;
+    }
     try {
-      if (!isClosed()) {
-        stmt = createStatement();
-        stmt.setQueryTimeout(timeout);
-        stmt.executeUpdate("");
-        valid = true;
+      if (checkConnectionQuery == null) {
+        checkConnectionQuery = prepareStatement("");
       }
+      checkConnectionQuery.setQueryTimeout(timeout);
+      checkConnectionQuery.executeUpdate();
+      return true;
     } catch (SQLException e) {
-      getLogger().log(GT.tr("Validating connection."), e);
-    } finally {
-      if (stmt != null) {
-        try {
-          stmt.close();
-        } catch (Exception ex) {
-        }
+      if (PSQLState.IN_FAILED_SQL_TRANSACTION.getState().equals(e.getSQLState())) {
+        // "current transaction aborted", assume the connection is up and running
+        return true;
       }
+      getLogger().log(GT.tr("Validating connection."), e);
     }
-    return valid;
+    return false;
   }
 
   public void setClientInfo(String name, String value) throws SQLClientInfoException {
@@ -1385,7 +1376,7 @@ public void setClientInfo(String name, String value) throws SQLClientInfoExcepti
       if (value == null) {
         value = "";
       }
-      final String oldValue = protoConnection.getApplicationName();
+      final String oldValue = queryExecutor.getApplicationName();
       if (value.equals(oldValue)) {
         return;
       }
@@ -1439,13 +1430,13 @@ public void setClientInfo(Properties properties) throws SQLClientInfoException {
 
   public String getClientInfo(String name) throws SQLException {
     checkClosed();
-    _clientInfo.put("ApplicationName", protoConnection.getApplicationName());
+    _clientInfo.put("ApplicationName", queryExecutor.getApplicationName());
     return _clientInfo.getProperty(name);
   }
 
   public Properties getClientInfo() throws SQLException {
     checkClosed();
-    _clientInfo.put("ApplicationName", protoConnection.getApplicationName());
+    _clientInfo.put("ApplicationName", queryExecutor.getApplicationName());
     return _clientInfo;
   }
 
@@ -1641,22 +1632,15 @@ public CallableStatement prepareCall(String sql, int resultSetType, int resultSe
   }
 
   public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
-    checkClosed();
-    if (autoGeneratedKeys != Statement.NO_GENERATED_KEYS) {
-      sql = PgStatement.addReturning(this, sql, new String[]{"*"}, false);
-    }
-
-    PreparedStatement ps = prepareStatement(sql);
-
-    if (autoGeneratedKeys != Statement.NO_GENERATED_KEYS) {
-      ((PgStatement) ps).wantsGeneratedKeysAlways = true;
+    if (autoGeneratedKeys != Statement.RETURN_GENERATED_KEYS) {
+      return prepareStatement(sql);
     }
 
-    return ps;
+    return prepareStatement(sql, (String[]) null);
   }
 
   public PreparedStatement prepareStatement(String sql, int columnIndexes[]) throws SQLException {
-    if (columnIndexes == null || columnIndexes.length == 0) {
+    if (columnIndexes != null && columnIndexes.length == 0) {
       return prepareStatement(sql);
     }
 
@@ -1666,16 +1650,23 @@ public PreparedStatement prepareStatement(String sql, int columnIndexes[]) throw
   }
 
   public PreparedStatement prepareStatement(String sql, String columnNames[]) throws SQLException {
-    if (columnNames != null && columnNames.length != 0) {
-      sql = PgStatement.addReturning(this, sql, columnNames, true);
+    if (columnNames != null && columnNames.length == 0) {
+      return prepareStatement(sql);
     }
 
-    PreparedStatement ps = prepareStatement(sql);
-
-    if (columnNames != null && columnNames.length != 0) {
-      ((PgStatement) ps).wantsGeneratedKeysAlways = true;
+    CachedQuery cachedQuery = borrowReturningQuery(sql, columnNames);
+    PgPreparedStatement ps =
+        new PgPreparedStatement(this, cachedQuery,
+            ResultSet.TYPE_FORWARD_ONLY,
+            ResultSet.CONCUR_READ_ONLY,
+            getHoldability());
+    Query query = cachedQuery.query;
+    SqlCommand sqlCommand = query.getSqlCommand();
+    if (sqlCommand != null) {
+      ps.wantsGeneratedKeysAlways = sqlCommand.isReturningKeywordPresent();
+    } else {
+      // If composite query is given, just ignore "generated keys" arguments
     }
-
     return ps;
   }
 }
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/PgDatabaseMetaData.java b/pgjdbc/src/main/java/org/postgresql/jdbc/PgDatabaseMetaData.java
index 26ae89944e..b7ede65618 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/PgDatabaseMetaData.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/PgDatabaseMetaData.java
@@ -3153,7 +3153,7 @@ public long getMaxLogicalLobSize() throws SQLException {
   }
 
   public boolean supportsRefCursors() throws SQLException {
-    return false;
+    return true;
   }
 
   public RowIdLifetime getRowIdLifetime() throws SQLException {
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/PgParameterMetaData.java b/pgjdbc/src/main/java/org/postgresql/jdbc/PgParameterMetaData.java
index f06676ee29..73ea8b928b 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/PgParameterMetaData.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/PgParameterMetaData.java
@@ -84,7 +84,7 @@ private void checkParamIndex(int param) throws PSQLException {
     if (param < 1 || param > _oids.length) {
       throw new PSQLException(
           GT.tr("The parameter index is out of range: {0}, number of parameters: {1}.",
-              new Object[]{param, _oids.length}),
+              param, _oids.length),
           PSQLState.INVALID_PARAMETER_VALUE);
     }
   }
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/PgPreparedStatement.java b/pgjdbc/src/main/java/org/postgresql/jdbc/PgPreparedStatement.java
index e4e8157f17..8194c0ccaa 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/PgPreparedStatement.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/PgPreparedStatement.java
@@ -88,15 +88,16 @@ class PgPreparedStatement extends PgStatement implements PreparedStatement {
 
   PgPreparedStatement(PgConnection connection, String sql, int rsType, int rsConcurrency,
       int rsHoldability) throws SQLException {
-    this(connection, sql, false, rsType, rsConcurrency, rsHoldability);
+    this(connection, connection.borrowQuery(sql), rsType, rsConcurrency, rsHoldability);
   }
 
-  PgPreparedStatement(PgConnection connection, String sql, boolean isCallable, int rsType,
+  PgPreparedStatement(PgConnection connection, CachedQuery query, int rsType,
       int rsConcurrency, int rsHoldability) throws SQLException {
     super(connection, rsType, rsConcurrency, rsHoldability);
 
-    this.preparedQuery = connection.borrowQuery(sql, isCallable);
+    this.preparedQuery = query;
     this.preparedParameters = this.preparedQuery.query.createParameterList();
+    // TODO: this.wantsGeneratedKeysAlways = true;
 
     setPoolable(true); // As per JDBC spec: prepared and callable statements are poolable by
   }
@@ -163,7 +164,11 @@ public boolean executeWithFlags(int flags) throws SQLException {
     try {
       checkClosed();
 
-      execute(preparedQuery.query, preparedParameters, flags);
+      if (connection.getPreferQueryMode() == PreferQueryMode.SIMPLE) {
+        flags |= QueryExecutor.QUERY_EXECUTE_AS_SIMPLE;
+      }
+
+      execute(preparedQuery, preparedParameters, flags);
 
       return (result != null && result.getResultSet() != null);
     } finally {
@@ -171,16 +176,11 @@ public boolean executeWithFlags(int flags) throws SQLException {
     }
   }
 
-  protected boolean isOneShotQuery(Query query) {
-    if (preparedQuery != null && (query == null || preparedQuery.query == query)) {
-      preparedQuery.increaseExecuteCount();
-      if ((m_prepareThreshold == 0 || preparedQuery.getExecuteCount() < m_prepareThreshold)
-          && !getForceBinaryTransfer()) {
-        return true;
-      }
-      return false;
+  protected boolean isOneShotQuery(CachedQuery cachedQuery) {
+    if (cachedQuery == null) {
+      cachedQuery = preparedQuery;
     }
-    return true;
+    return super.isOneShotQuery(cachedQuery);
   }
 
   @Override
@@ -573,6 +573,7 @@ private void setMap(int parameterIndex, Map<?, ?> x) throws SQLException {
     }
   }
 
+  @Override
   public void setObject(int parameterIndex, Object in, int targetSqlType, int scale)
       throws SQLException {
     checkClosed();
@@ -693,7 +694,7 @@ public void setObject(int parameterIndex, Object in, int targetSqlType, int scal
         } else {
           throw new PSQLException(
               GT.tr("Cannot cast an instance of {0} to type {1}",
-                  new Object[]{in.getClass().getName(), "Types.TIMESTAMP_WITH_TIMEZONE"}),
+                  in.getClass().getName(), "Types.TIMESTAMP_WITH_TIMEZONE"),
               PSQLState.INVALID_PARAMETER_TYPE);
         }
         break;
@@ -715,7 +716,7 @@ public void setObject(int parameterIndex, Object in, int targetSqlType, int scal
         } else {
           throw new PSQLException(
               GT.tr("Cannot cast an instance of {0} to type {1}",
-                  new Object[]{in.getClass().getName(), "Types.BLOB"}),
+                  in.getClass().getName(), "Types.BLOB"),
               PSQLState.INVALID_PARAMETER_TYPE);
         }
         break;
@@ -725,7 +726,7 @@ public void setObject(int parameterIndex, Object in, int targetSqlType, int scal
         } else {
           throw new PSQLException(
               GT.tr("Cannot cast an instance of {0} to type {1}",
-                  new Object[]{in.getClass().getName(), "Types.CLOB"}),
+                  in.getClass().getName(), "Types.CLOB"),
               PSQLState.INVALID_PARAMETER_TYPE);
         }
         break;
@@ -735,7 +736,7 @@ public void setObject(int parameterIndex, Object in, int targetSqlType, int scal
         } else {
           throw new PSQLException(
               GT.tr("Cannot cast an instance of {0} to type {1}",
-                  new Object[]{in.getClass().getName(), "Types.ARRAY"}),
+                  in.getClass().getName(), "Types.ARRAY"),
               PSQLState.INVALID_PARAMETER_TYPE);
         }
         break;
@@ -981,7 +982,7 @@ private static PSQLException cannotCastException(final String fromType, final St
   private static PSQLException cannotCastException(final String fromType, final String toType,
       final Exception cause) {
     return new PSQLException(
-        GT.tr("Cannot convert an instance of {0} to type {1}", new Object[]{fromType, toType}),
+        GT.tr("Cannot convert an instance of {0} to type {1}", fromType, toType),
         PSQLState.INVALID_PARAMETER_TYPE, cause);
   }
 
@@ -1706,8 +1707,8 @@ protected void transformQueriesAndParameters() throws SQLException {
     // we cap maximum batch size and split there.
     final int bindCount = originalQuery.getBindCount();
     final int highestBlockCount = 128;
-    final int maxValueBlocks =
-        Integer.highestOneBit( // deriveForMultiBatch supports powers of two only
+    final int maxValueBlocks = bindCount == 0 ? 1024 /* if no binds, use 1024 rows */
+        : Integer.highestOneBit( // deriveForMultiBatch supports powers of two only
             Math.min(Math.max(1, (Short.MAX_VALUE - 1) / bindCount), highestBlockCount));
     int unprocessedBatchCount = batchParameters.size();
     final int fullValueBlocksCount = unprocessedBatchCount / maxValueBlocks;
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/PgResultSet.java b/pgjdbc/src/main/java/org/postgresql/jdbc/PgResultSet.java
index 088f303c32..1090b22a8f 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/PgResultSet.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/PgResultSet.java
@@ -16,7 +16,7 @@
 import org.postgresql.core.Oid;
 import org.postgresql.core.Query;
 import org.postgresql.core.ResultCursor;
-import org.postgresql.core.ResultHandler;
+import org.postgresql.core.ResultHandlerBase;
 import org.postgresql.core.ServerVersion;
 import org.postgresql.core.TypeInfo;
 import org.postgresql.core.Utils;
@@ -123,7 +123,7 @@ public class PgResultSet implements ResultSet, org.postgresql.PGRefCursorResultS
   protected int fetchSize; // Current fetch size (might be 0).
   protected ResultCursor cursor; // Cursor for fetching additional data.
 
-  private HashMap<String, Integer> columnNameIndexMap; // Speed up findColumn by caching lookups
+  private Map<String, Integer> columnNameIndexMap; // Speed up findColumn by caching lookups
 
   private ResultSetMetaData rsMetaData;
 
@@ -483,6 +483,7 @@ public int getConcurrency() throws SQLException {
   }
 
 
+  @Override
   public java.sql.Date getDate(int i, java.util.Calendar cal) throws SQLException {
     checkResultSet(i);
     if (wasNullFlag) {
@@ -507,7 +508,7 @@ public java.sql.Date getDate(int i, java.util.Calendar cal) throws SQLException
       } else {
         throw new PSQLException(
             GT.tr("Cannot convert the column of type {0} to requested type {1}.",
-                new Object[]{Oid.toString(oid), "date"}),
+                Oid.toString(oid), "date"),
             PSQLState.DATA_TYPE_MISMATCH);
       }
     }
@@ -516,6 +517,7 @@ public java.sql.Date getDate(int i, java.util.Calendar cal) throws SQLException
   }
 
 
+  @Override
   public Time getTime(int i, java.util.Calendar cal) throws SQLException {
     checkResultSet(i);
     if (wasNullFlag) {
@@ -540,7 +542,7 @@ public Time getTime(int i, java.util.Calendar cal) throws SQLException {
       } else {
         throw new PSQLException(
             GT.tr("Cannot convert the column of type {0} to requested type {1}.",
-                new Object[]{Oid.toString(oid), "time"}),
+                Oid.toString(oid), "time"),
             PSQLState.DATA_TYPE_MISMATCH);
       }
     }
@@ -550,6 +552,7 @@ public Time getTime(int i, java.util.Calendar cal) throws SQLException {
   }
 
 
+  @Override
   public Timestamp getTimestamp(int i, java.util.Calendar cal) throws SQLException {
     checkResultSet(i);
     if (wasNullFlag) {
@@ -576,7 +579,7 @@ public Timestamp getTimestamp(int i, java.util.Calendar cal) throws SQLException
         } else {
           throw new PSQLException(
               GT.tr("Cannot convert the column of type {0} to requested type {1}.",
-                  new Object[]{Oid.toString(oid), "timestamp"}),
+                  Oid.toString(oid), "timestamp"),
               PSQLState.DATA_TYPE_MISMATCH);
         }
         return new Timestamp(millis);
@@ -606,7 +609,7 @@ private LocalDateTime getLocalDateTime(int i) throws SQLException {
     if (oid != Oid.TIMESTAMP) {
       throw new PSQLException(
               GT.tr("Cannot convert the column of type {0} to requested type {1}.",
-                      new Object[]{Oid.toString(oid), "timestamp"}),
+                  Oid.toString(oid), "timestamp"),
               PSQLState.DATA_TYPE_MISMATCH);
     }
     if (isBinary(i)) {
@@ -976,12 +979,10 @@ public synchronized void insertRow() throws SQLException {
       insertSQL.append(paramSQL.toString());
       insertStatement = connection.prepareStatement(insertSQL.toString());
 
-      Iterator<String> keys = updateValues.keySet().iterator();
+      Iterator<Object> values = updateValues.values().iterator();
 
-      for (int i = 1; keys.hasNext(); i++) {
-        String key = keys.next();
-        Object o = updateValues.get(key);
-        insertStatement.setObject(i, o);
+      for (int i = 1; values.hasNext(); i++) {
+        insertStatement.setObject(i, values.next());
       }
 
       insertStatement.executeUpdate();
@@ -1688,10 +1689,10 @@ private void parseQuery() {
 
   private void updateRowBuffer() throws SQLException {
 
-    for (String columnName : updateValues.keySet()) {
-      int columnIndex = findColumn(columnName) - 1;
+    for (Map.Entry<String, Object> entry : updateValues.entrySet()) {
+      int columnIndex = findColumn(entry.getKey()) - 1;
 
-      Object valueObject = updateValues.get(columnName);
+      Object valueObject = entry.getValue();
       if (valueObject instanceof PGobject) {
         String value = ((PGobject) valueObject).getValue();
         rowBuffer[columnIndex] = (value == null) ? null : connection.encodeString(value);
@@ -1753,8 +1754,7 @@ private void updateRowBuffer() throws SQLException {
     }
   }
 
-  public class CursorResultHandler implements ResultHandler {
-    private SQLException error;
+  public class CursorResultHandler extends ResultHandlerBase {
 
     public void handleResultRows(Query fromQuery, Field[] fields, List<byte[][]> tuples,
         ResultCursor cursor) {
@@ -1767,27 +1767,15 @@ public void handleCommandStatus(String status, int updateCount, long insertOID)
           PSQLState.PROTOCOL_VIOLATION));
     }
 
-    public void handleWarning(SQLWarning warning) {
-      PgResultSet.this.addWarning(warning);
-    }
-
-    public void handleError(SQLException newError) {
-      if (error == null) {
-        error = newError;
-      } else {
-        error.setNextException(newError);
-      }
-    }
-
     public void handleCompletion() throws SQLException {
-      if (error != null) {
-        throw error;
+      SQLWarning warning = getWarning();
+      if (warning != null) {
+        PgResultSet.this.addWarning(warning);
       }
+      super.handleCompletion();
     }
   }
 
-  ;
-
 
   public BaseStatement getPGStatement() {
     return statement;
@@ -1942,6 +1930,7 @@ public boolean getBoolean(int columnIndex) throws SQLException {
   private static final BigInteger BYTEMAX = new BigInteger(Byte.toString(Byte.MAX_VALUE));
   private static final BigInteger BYTEMIN = new BigInteger(Byte.toString(Byte.MIN_VALUE));
 
+  @Override
   public byte getByte(int columnIndex) throws SQLException {
     checkResultSet(columnIndex);
     if (wasNullFlag) {
@@ -1976,12 +1965,12 @@ public byte getByte(int columnIndex) throws SQLException {
           int lt = i.compareTo(BYTEMIN);
 
           if (gt > 0 || lt < 0) {
-            throw new PSQLException(GT.tr("Bad value for type {0} : {1}", new Object[]{"byte", s}),
+            throw new PSQLException(GT.tr("Bad value for type {0} : {1}", "byte", s),
                 PSQLState.NUMERIC_VALUE_OUT_OF_RANGE);
           }
           return i.byteValue();
         } catch (NumberFormatException ex) {
-          throw new PSQLException(GT.tr("Bad value for type {0} : {1}", new Object[]{"byte", s}),
+          throw new PSQLException(GT.tr("Bad value for type {0} : {1}", "byte", s),
               PSQLState.NUMERIC_VALUE_OUT_OF_RANGE);
         }
       }
@@ -1992,6 +1981,7 @@ public byte getByte(int columnIndex) throws SQLException {
   private static final BigInteger SHORTMAX = new BigInteger(Short.toString(Short.MAX_VALUE));
   private static final BigInteger SHORTMIN = new BigInteger(Short.toString(Short.MIN_VALUE));
 
+  @Override
   public short getShort(int columnIndex) throws SQLException {
     checkResultSet(columnIndex);
     if (wasNullFlag) {
@@ -2021,13 +2011,13 @@ public short getShort(int columnIndex) throws SQLException {
           int lt = i.compareTo(SHORTMIN);
 
           if (gt > 0 || lt < 0) {
-            throw new PSQLException(GT.tr("Bad value for type {0} : {1}", new Object[]{"short", s}),
+            throw new PSQLException(GT.tr("Bad value for type {0} : {1}", "short", s),
                 PSQLState.NUMERIC_VALUE_OUT_OF_RANGE);
           }
           return i.shortValue();
 
         } catch (NumberFormatException ne) {
-          throw new PSQLException(GT.tr("Bad value for type {0} : {1}", new Object[]{"short", s}),
+          throw new PSQLException(GT.tr("Bad value for type {0} : {1}", "short", s),
               PSQLState.NUMERIC_VALUE_OUT_OF_RANGE);
         }
       }
@@ -2605,19 +2595,30 @@ public int findColumn(String columnName) throws SQLException {
     return col;
   }
 
+  public static Map<String, Integer> createColumnNameIndexMap(Field[] fields,
+      boolean isSanitiserDisabled) {
+    Map<String, Integer> columnNameIndexMap = new HashMap<String, Integer>(fields.length * 2);
+    // The JDBC spec says when you have duplicate columns names,
+    // the first one should be returned. So load the map in
+    // reverse order so the first ones will overwrite later ones.
+    for (int i = fields.length - 1; i >= 0; i--) {
+      String columnLabel = fields[i].getColumnLabel();
+      if (isSanitiserDisabled) {
+        columnNameIndexMap.put(columnLabel, i + 1);
+      } else {
+        columnNameIndexMap.put(columnLabel.toLowerCase(Locale.US), i + 1);
+      }
+    }
+    return columnNameIndexMap;
+  }
+
   private int findColumnIndex(String columnName) {
     if (columnNameIndexMap == null) {
-      columnNameIndexMap = new HashMap<String, Integer>(fields.length * 2);
-      // The JDBC spec says when you have duplicate columns names,
-      // the first one should be returned. So load the map in
-      // reverse order so the first ones will overwrite later ones.
-      boolean isSanitiserDisabled = connection.isColumnSanitiserDisabled();
-      for (int i = fields.length - 1; i >= 0; i--) {
-        if (isSanitiserDisabled) {
-          columnNameIndexMap.put(fields[i].getColumnLabel(), i + 1);
-        } else {
-          columnNameIndexMap.put(fields[i].getColumnLabel().toLowerCase(Locale.US), i + 1);
-        }
+      if (originalQuery != null) {
+        columnNameIndexMap = originalQuery.getResultSetColumnNameIndexMap();
+      }
+      if (columnNameIndexMap == null) {
+        columnNameIndexMap = createColumnNameIndexMap(fields, connection.isColumnSanitiserDisabled());
       }
     }
 
@@ -2751,7 +2752,7 @@ protected void checkColumnIndex(int column) throws SQLException {
     if (column < 1 || column > fields.length) {
       throw new PSQLException(
           GT.tr("The column index is out of range: {0}, number of columns: {1}.",
-              new Object[]{column, fields.length}),
+              column, fields.length),
           PSQLState.INVALID_PARAMETER_VALUE);
     }
   }
@@ -2825,13 +2826,13 @@ public static int toInt(String s) throws SQLException {
           int lt = i.compareTo(INTMIN);
 
           if (gt > 0 || lt < 0) {
-            throw new PSQLException(GT.tr("Bad value for type {0} : {1}", new Object[]{"int", s}),
+            throw new PSQLException(GT.tr("Bad value for type {0} : {1}", "int", s),
                 PSQLState.NUMERIC_VALUE_OUT_OF_RANGE);
           }
           return i.intValue();
 
         } catch (NumberFormatException ne) {
-          throw new PSQLException(GT.tr("Bad value for type {0} : {1}", new Object[]{"int", s}),
+          throw new PSQLException(GT.tr("Bad value for type {0} : {1}", "int", s),
               PSQLState.NUMERIC_VALUE_OUT_OF_RANGE);
         }
       }
@@ -2855,12 +2856,12 @@ public static long toLong(String s) throws SQLException {
           int lt = i.compareTo(LONGMIN);
 
           if (gt > 0 || lt < 0) {
-            throw new PSQLException(GT.tr("Bad value for type {0} : {1}", new Object[]{"long", s}),
+            throw new PSQLException(GT.tr("Bad value for type {0} : {1}", "long", s),
                 PSQLState.NUMERIC_VALUE_OUT_OF_RANGE);
           }
           return i.longValue();
         } catch (NumberFormatException ne) {
-          throw new PSQLException(GT.tr("Bad value for type {0} : {1}", new Object[]{"long", s}),
+          throw new PSQLException(GT.tr("Bad value for type {0} : {1}", "long", s),
               PSQLState.NUMERIC_VALUE_OUT_OF_RANGE);
         }
       }
@@ -2876,7 +2877,7 @@ public static BigDecimal toBigDecimal(String s) throws SQLException {
       s = s.trim();
       return new BigDecimal(s);
     } catch (NumberFormatException e) {
-      throw new PSQLException(GT.tr("Bad value for type {0} : {1}", new Object[]{"BigDecimal", s}),
+      throw new PSQLException(GT.tr("Bad value for type {0} : {1}", "BigDecimal", s),
           PSQLState.NUMERIC_VALUE_OUT_OF_RANGE);
     }
   }
@@ -2897,7 +2898,7 @@ private BigDecimal scaleBigDecimal(BigDecimal val, int scale) throws PSQLExcepti
       return val.setScale(scale);
     } catch (ArithmeticException e) {
       throw new PSQLException(
-          GT.tr("Bad value for type {0} : {1}", new Object[]{"BigDecimal", val}),
+          GT.tr("Bad value for type {0} : {1}", "BigDecimal", val),
           PSQLState.NUMERIC_VALUE_OUT_OF_RANGE);
     }
   }
@@ -2908,7 +2909,7 @@ public static float toFloat(String s) throws SQLException {
         s = s.trim();
         return Float.parseFloat(s);
       } catch (NumberFormatException e) {
-        throw new PSQLException(GT.tr("Bad value for type {0} : {1}", new Object[]{"float", s}),
+        throw new PSQLException(GT.tr("Bad value for type {0} : {1}", "float", s),
             PSQLState.NUMERIC_VALUE_OUT_OF_RANGE);
       }
     }
@@ -2921,7 +2922,7 @@ public static double toDouble(String s) throws SQLException {
         s = s.trim();
         return Double.parseDouble(s);
       } catch (NumberFormatException e) {
-        throw new PSQLException(GT.tr("Bad value for type {0} : {1}", new Object[]{"double", s}),
+        throw new PSQLException(GT.tr("Bad value for type {0} : {1}", "double", s),
             PSQLState.NUMERIC_VALUE_OUT_OF_RANGE);
       }
     }
@@ -3000,7 +3001,7 @@ private double readDoubleValue(byte[] bytes, int oid, String targetType) throws
         return ByteConverter.float8(bytes, 0);
     }
     throw new PSQLException(GT.tr("Cannot convert the column of type {0} to requested type {1}.",
-        new Object[]{Oid.toString(oid), targetType}), PSQLState.DATA_TYPE_MISMATCH);
+        Oid.toString(oid), targetType), PSQLState.DATA_TYPE_MISMATCH);
   }
 
   /**
@@ -3044,11 +3045,11 @@ private long readLongValue(byte[] bytes, int oid, long minVal, long maxVal, Stri
       default:
         throw new PSQLException(
             GT.tr("Cannot convert the column of type {0} to requested type {1}.",
-                new Object[]{Oid.toString(oid), targetType}),
+                Oid.toString(oid), targetType),
             PSQLState.DATA_TYPE_MISMATCH);
     }
     if (val < minVal || val > maxVal) {
-      throw new PSQLException(GT.tr("Bad value for type {0} : {1}", new Object[]{targetType, val}),
+      throw new PSQLException(GT.tr("Bad value for type {0} : {1}", targetType, val),
           PSQLState.NUMERIC_VALUE_OUT_OF_RANGE);
     }
     return val;
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/PgResultSetMetaData.java b/pgjdbc/src/main/java/org/postgresql/jdbc/PgResultSetMetaData.java
index 75c1d66641..0899bf13b8 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/PgResultSetMetaData.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/PgResultSetMetaData.java
@@ -487,7 +487,7 @@ protected Field getField(int columnIndex) throws SQLException {
     if (columnIndex < 1 || columnIndex > fields.length) {
       throw new PSQLException(
           GT.tr("The column index is out of range: {0}, number of columns: {1}.",
-              new Object[]{columnIndex, fields.length}),
+              columnIndex, fields.length),
           PSQLState.INVALID_PARAMETER_VALUE);
     }
     return fields[columnIndex - 1];
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/PgStatement.java b/pgjdbc/src/main/java/org/postgresql/jdbc/PgStatement.java
index 5f907d5a68..8014a679df 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/PgStatement.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/PgStatement.java
@@ -12,23 +12,19 @@
 import org.postgresql.Driver;
 import org.postgresql.core.BaseConnection;
 import org.postgresql.core.BaseStatement;
+import org.postgresql.core.CachedQuery;
 import org.postgresql.core.Field;
 import org.postgresql.core.ParameterList;
-import org.postgresql.core.Parser;
 import org.postgresql.core.Query;
 import org.postgresql.core.QueryExecutor;
 import org.postgresql.core.ResultCursor;
-import org.postgresql.core.ResultHandler;
-import org.postgresql.core.ServerVersion;
-import org.postgresql.core.Utils;
+import org.postgresql.core.ResultHandlerBase;
+import org.postgresql.core.SqlCommand;
 import org.postgresql.util.GT;
 import org.postgresql.util.PSQLException;
 import org.postgresql.util.PSQLState;
 
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
 import java.sql.Connection;
-import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.SQLFeatureNotSupportedException;
@@ -41,6 +37,8 @@
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 
 public class PgStatement implements Statement, BaseStatement {
+  private static final String[] NO_RETURNING_COLUMNS = new String[0];
+
   /**
    * Default state for use or not binary transfers. Can use only for testing purposes
    */
@@ -143,20 +141,6 @@ public class PgStatement implements Statement, BaseStatement {
    */
   protected ResultWrapper generatedKeys = null;
 
-  // Static variables for parsing SQL when replaceProcessing is true.
-  private enum SqlParseState {
-    IN_SQLCODE,
-    IN_STRING,
-    IN_IDENTIFIER,
-    BACKSLASH,
-    ESC_TIMEDATE,
-    ESC_FUNCTION,
-    ESC_OUTERJOIN,
-    ESC_ESCAPECHAR;
-  }
-
-  protected Query lastSimpleQuery;
-
   protected int m_prepareThreshold; // Reuse threshold to enable use of PREPARE
 
   protected int maxfieldSize = 0;
@@ -164,7 +148,6 @@ private enum SqlParseState {
   PgStatement(PgConnection c, int rsType, int rsConcurrency, int rsHoldability)
       throws SQLException {
     this.connection = c;
-    this.lastSimpleQuery = null;
     forceBinaryTransfers |= c.getForceBinary();
     resultsettype = rsType;
     concurrency = rsConcurrency;
@@ -207,9 +190,9 @@ protected boolean wantsHoldableResultSet() {
   /**
    * ResultHandler implementations for updates, queries, and either-or.
    */
-  public class StatementResultHandler implements ResultHandler {
-    private SQLException error;
+  public class StatementResultHandler extends ResultHandlerBase {
     private ResultWrapper results;
+    private ResultWrapper lastResult;
 
     ResultWrapper getResults() {
       return results;
@@ -217,12 +200,13 @@ ResultWrapper getResults() {
 
     private void append(ResultWrapper newResult) {
       if (results == null) {
-        results = newResult;
+        lastResult = results = newResult;
       } else {
-        results.append(newResult);
+        lastResult.append(newResult);
       }
     }
 
+    @Override
     public void handleResultRows(Query fromQuery, Field[] fields, List<byte[][]> tuples,
         ResultCursor cursor) {
       try {
@@ -233,51 +217,22 @@ public void handleResultRows(Query fromQuery, Field[] fields, List<byte[][]> tup
       }
     }
 
+    @Override
     public void handleCommandStatus(String status, int updateCount, long insertOID) {
       append(new ResultWrapper(updateCount, insertOID));
     }
 
-    public void handleWarning(SQLWarning warning) {
-      PgStatement.this.addWarning(warning);
-    }
-
-    public void handleError(SQLException newError) {
-      if (error == null) {
-        error = newError;
-      } else {
-        error.setNextException(newError);
-      }
-    }
-
+    @Override
     public void handleCompletion() throws SQLException {
-      if (error != null) {
-        throw error;
+      SQLWarning warning = getWarning();
+      if (warning != null) {
+        PgStatement.this.addWarning(warning);
       }
+      super.handleCompletion();
     }
   }
 
   public java.sql.ResultSet executeQuery(String p_sql) throws SQLException {
-    if (forceBinaryTransfers) {
-      clearWarnings();
-      // Close any existing resultsets associated with this statement.
-      while (firstUnclosedResult != null) {
-        if (firstUnclosedResult.getResultSet() != null) {
-          firstUnclosedResult.getResultSet().close();
-        }
-        firstUnclosedResult = firstUnclosedResult.getNext();
-      }
-
-      PreparedStatement ps =
-          connection.prepareStatement(p_sql, resultsettype, concurrency, getResultSetHoldability());
-      ps.setMaxFieldSize(getMaxFieldSize());
-      ps.setFetchSize(getFetchSize());
-      ps.setFetchDirection(getFetchDirection());
-      PgResultSet rs = (PgResultSet) ps.executeQuery();
-
-      result = firstUnclosedResult = new ResultWrapper(rs);
-      return rs;
-    }
-
     if (!executeWithFlags(p_sql, 0)) {
       throw new PSQLException(GT.tr("No results were returned by the query."), PSQLState.NO_DATA);
     }
@@ -310,13 +265,44 @@ public boolean execute(String p_sql) throws SQLException {
     return executeWithFlags(p_sql, 0);
   }
 
-  public boolean executeWithFlags(String p_sql, int flags) throws SQLException {
+  public boolean executeWithFlags(String sql, int flags) throws SQLException {
+    return executeCachedSql(sql, flags, NO_RETURNING_COLUMNS);
+  }
+
+  private boolean executeCachedSql(String sql, int flags, String[] columnNames) throws SQLException {
+    PreferQueryMode preferQueryMode = connection.getPreferQueryMode();
+    boolean shouldUseParameterized = preferQueryMode.compareTo(PreferQueryMode.EXTENDED) >= 0;
+    QueryExecutor queryExecutor = connection.getQueryExecutor();
+    Object key = queryExecutor
+        .createQueryKey(sql, replaceProcessingEnabled, shouldUseParameterized, columnNames);
+    CachedQuery cachedQuery;
+    boolean shouldCache = preferQueryMode == PreferQueryMode.EXTENDED_CACHE_EVERYTING;
+    if (shouldCache) {
+      cachedQuery = queryExecutor.borrowQueryByKey(key);
+    } else {
+      cachedQuery = queryExecutor.createQueryByKey(key);
+    }
+    if (wantsGeneratedKeysOnce) {
+      SqlCommand sqlCommand = cachedQuery.query.getSqlCommand();
+      wantsGeneratedKeysOnce = sqlCommand != null && sqlCommand.isReturningKeywordPresent();
+    }
+    boolean res;
+    try {
+      res = executeWithFlags(cachedQuery, flags);
+    } finally {
+      if (shouldCache) {
+        queryExecutor.releaseQuery(cachedQuery);
+      }
+    }
+    return res;
+  }
+
+  public boolean executeWithFlags(CachedQuery simpleQuery, int flags) throws SQLException {
     checkClosed();
-    p_sql = replaceProcessing(p_sql, replaceProcessingEnabled,
-        connection.getStandardConformingStrings());
-    Query simpleQuery = connection.getQueryExecutor().createSimpleQuery(p_sql, connection.getAutoCommit());
-    execute(simpleQuery, null, QueryExecutor.QUERY_ONESHOT | flags);
-    this.lastSimpleQuery = simpleQuery;
+    if (connection.getPreferQueryMode().compareTo(PreferQueryMode.EXTENDED) < 0) {
+      flags |= QueryExecutor.QUERY_EXECUTE_AS_SIMPLE;
+    }
+    execute(simpleQuery, null, flags);
     return (result != null && result.getResultSet() != null);
   }
 
@@ -340,11 +326,6 @@ protected void closeForNextExecution() throws SQLException {
     }
     result = null;
 
-    if (lastSimpleQuery != null) {
-      lastSimpleQuery.close();
-      lastSimpleQuery = null;
-    }
-
     if (generatedKeys != null) {
       if (generatedKeys.getResultSet() != null) {
         generatedKeys.getResultSet().close();
@@ -356,14 +337,38 @@ protected void closeForNextExecution() throws SQLException {
   /**
    * Returns true if query is unlikely to be reused
    *
-   * @param query to check (null if current query)
+   * @param cachedQuery to check (null if current query)
    * @return true if query is unlikely to be reused
    */
-  protected boolean isOneShotQuery(Query query) {
-    return true;
+  protected boolean isOneShotQuery(CachedQuery cachedQuery) {
+    if (cachedQuery == null) {
+      return true;
+    }
+    cachedQuery.increaseExecuteCount();
+    if ((m_prepareThreshold == 0 || cachedQuery.getExecuteCount() < m_prepareThreshold)
+        && !getForceBinaryTransfer()) {
+      return true;
+    }
+    return false;
   }
 
-  protected void execute(Query queryToExecute, ParameterList queryParameters, int flags)
+  protected final void execute(CachedQuery cachedQuery, ParameterList queryParameters, int flags)
+      throws SQLException {
+    try {
+      executeInternal(cachedQuery, queryParameters, flags);
+    } catch (SQLException e) {
+      // Don't retry composite queries as it might get partially executed
+      if (cachedQuery.query.getSubqueries() != null
+          || !connection.getQueryExecutor().willHealOnRetry(e)) {
+        throw e;
+      }
+      cachedQuery.query.close();
+      // Execute the query one more time
+      executeInternal(cachedQuery, queryParameters, flags);
+    }
+  }
+
+  private void executeInternal(CachedQuery cachedQuery, ParameterList queryParameters, int flags)
       throws SQLException {
     closeForNextExecution();
 
@@ -384,7 +389,7 @@ protected void execute(Query queryToExecute, ParameterList queryParameters, int
       }
     }
 
-    if (isOneShotQuery(queryToExecute)) {
+    if (isOneShotQuery(cachedQuery)) {
       flags |= QueryExecutor.QUERY_ONESHOT;
     }
     // Only use named statements after we hit the threshold. Note that only
@@ -399,11 +404,17 @@ protected void execute(Query queryToExecute, ParameterList queryParameters, int
       flags |= QueryExecutor.QUERY_NO_BINARY_TRANSFER;
     }
 
+    Query queryToExecute = cachedQuery.query;
+
     if (queryToExecute.isEmpty()) {
       flags |= QueryExecutor.QUERY_SUPPRESS_BEGIN;
     }
 
-    if (!queryToExecute.isStatementDescribed() && forceBinaryTransfers) {
+    if (!queryToExecute.isStatementDescribed() && forceBinaryTransfers
+        && (flags & QueryExecutor.QUERY_EXECUTE_AS_SIMPLE) == 0) {
+      // Simple 'Q' execution does not need to know parameter types
+      // When binaryTransfer is forced, then we need to know resulting parameter and column types,
+      // thus sending a describe request.
       int flags2 = flags | QueryExecutor.QUERY_DESCRIBE_ONLY;
       StatementResultHandler handler2 = new StatementResultHandler();
       connection.getQueryExecutor().execute(queryToExecute, queryParameters, handler2, 0, 0,
@@ -598,256 +609,6 @@ public void close() throws SQLException {
     isClosed = true;
   }
 
-  /**
-   * Filter the SQL string of Java SQL Escape clauses.
-   *
-   * Currently implemented Escape clauses are those mentioned in 11.3 in the specification.
-   * Basically we look through the sql string for {d xxx}, {t xxx}, {ts xxx}, {oj xxx} or {fn xxx}
-   * in non-string sql code. When we find them, we just strip the escape part leaving only the xxx
-   * part. So, something like "select * from x where d={d '2001-10-09'}" would return "select * from
-   * x where d= '2001-10-09'".
-   *
-   * @param p_sql the original query text
-   * @param replaceProcessingEnabled whether replace_processing_enabled is on
-   * @param standardConformingStrings whether standard_conforming_strings is on
-   * @return PostgreSQL-compatible SQL
-   */
-  static String replaceProcessing(String p_sql, boolean replaceProcessingEnabled,
-      boolean standardConformingStrings) throws SQLException {
-    if (replaceProcessingEnabled) {
-      // Since escape codes can only appear in SQL CODE, we keep track
-      // of if we enter a string or not.
-      int len = p_sql.length();
-      StringBuilder newsql = new StringBuilder(len);
-      int i = 0;
-      while (i < len) {
-        i = parseSql(p_sql, i, newsql, false, standardConformingStrings);
-        // We need to loop here in case we encounter invalid
-        // SQL, consider: SELECT a FROM t WHERE (1 > 0)) ORDER BY a
-        // We can't ending replacing after the extra closing paren
-        // because that changes a syntax error to a valid query
-        // that isn't what the user specified.
-        if (i < len) {
-          newsql.append(p_sql.charAt(i));
-          i++;
-        }
-      }
-      return newsql.toString();
-    } else {
-      return p_sql;
-    }
-  }
-
-  /**
-   * parse the given sql from index i, appending it to the given buffer until we hit an unmatched
-   * right parentheses or end of string. When the stopOnComma flag is set we also stop processing
-   * when a comma is found in sql text that isn't inside nested parenthesis.
-   *
-   * @param p_sql the original query text
-   * @param i starting position for replacing
-   * @param newsql where to write the replaced output
-   * @param stopOnComma should we stop after hitting the first comma in sql text?
-   * @param stdStrings whether standard_conforming_strings is on
-   * @return the position we stopped processing at
-   * @throws SQLException if given SQL is wrong
-   */
-  protected static int parseSql(String p_sql, int i, StringBuilder newsql, boolean stopOnComma,
-      boolean stdStrings) throws SQLException {
-    SqlParseState state = SqlParseState.IN_SQLCODE;
-    int len = p_sql.length();
-    int nestedParenthesis = 0;
-    boolean endOfNested = false;
-
-    // because of the ++i loop
-    i--;
-    while (!endOfNested && ++i < len) {
-      char c = p_sql.charAt(i);
-      switch (state) {
-        case IN_SQLCODE:
-          if (c == '$' && (i == 0 || !Parser.isIdentifierContChar(p_sql.charAt(i - 1)))) {
-            // start of a dollar-quoted string
-            int tagEnd = -1;
-            if (i + 1 < len) {
-              tagEnd = p_sql.indexOf('$', i + 1);
-            }
-            if (tagEnd != -1) {
-              String dollarQuoteTag = p_sql.substring(i, tagEnd + 1);
-              int nextPos = p_sql.indexOf(dollarQuoteTag, i + dollarQuoteTag.length());
-              if (nextPos > 0) {
-                tagEnd = nextPos + dollarQuoteTag.length();
-              }
-            }
-            if (tagEnd == -1) {
-              tagEnd = len;
-            }
-            newsql.append(p_sql, i, tagEnd); // tagEnd is excluding
-            i = tagEnd - 1;
-            break;
-          } else if (c == '\'') {
-            // start of a string?
-            state = SqlParseState.IN_STRING;
-          } else if (c == '"') {
-            // start of a identifier?
-            state = SqlParseState.IN_IDENTIFIER;
-          } else if (c == '(') { // begin nested sql
-            nestedParenthesis++;
-          } else if (c == ')') { // end of nested sql
-            nestedParenthesis--;
-            if (nestedParenthesis < 0) {
-              endOfNested = true;
-              break;
-            }
-          } else if (stopOnComma && c == ',' && nestedParenthesis == 0) {
-            endOfNested = true;
-            break;
-          } else if (c == '{') { // start of an escape code?
-            if (i + 1 < len) {
-              char next = p_sql.charAt(i + 1);
-              char nextnext = (i + 2 < len) ? p_sql.charAt(i + 2) : '\0';
-              if (next == 'd' || next == 'D') {
-                state = SqlParseState.ESC_TIMEDATE;
-                i++;
-                newsql.append("DATE ");
-                break;
-              } else if (next == 't' || next == 'T') {
-                state = SqlParseState.ESC_TIMEDATE;
-                if (nextnext == 's' || nextnext == 'S') {
-                  // timestamp constant
-                  i += 2;
-                  newsql.append("TIMESTAMP ");
-                } else {
-                  // time constant
-                  i++;
-                  newsql.append("TIME ");
-                }
-                break;
-              } else if (next == 'f' || next == 'F') {
-                state = SqlParseState.ESC_FUNCTION;
-                i += (nextnext == 'n' || nextnext == 'N') ? 2 : 1;
-                break;
-              } else if (next == 'o' || next == 'O') {
-                state = SqlParseState.ESC_OUTERJOIN;
-                i += (nextnext == 'j' || nextnext == 'J') ? 2 : 1;
-                break;
-              } else if (next == 'e' || next == 'E') {
-                // we assume that escape is the only escape sequence beginning with e
-                state = SqlParseState.ESC_ESCAPECHAR;
-                break;
-              }
-            }
-          }
-          newsql.append(c);
-          break;
-
-        case IN_STRING:
-          if (c == '\'') {
-            // end of string?
-            state = SqlParseState.IN_SQLCODE;
-          } else if (c == '\\' && !stdStrings) {
-            // a backslash?
-            state = SqlParseState.BACKSLASH;
-          }
-
-          newsql.append(c);
-          break;
-
-        case IN_IDENTIFIER:
-          if (c == '"') {
-            // end of identifier
-            state = SqlParseState.IN_SQLCODE;
-          }
-          newsql.append(c);
-          break;
-
-        case BACKSLASH:
-          state = SqlParseState.IN_STRING;
-
-          newsql.append(c);
-          break;
-
-        case ESC_FUNCTION:
-          // extract function name
-          String functionName;
-          int posArgs = p_sql.indexOf('(', i);
-          if (posArgs != -1) {
-            functionName = p_sql.substring(i, posArgs).trim();
-            // extract arguments
-            i = posArgs + 1;// we start the scan after the first (
-            StringBuilder args = new StringBuilder();
-            i = parseSql(p_sql, i, args, false, stdStrings);
-            // translate the function and parse arguments
-            newsql.append(escapeFunction(functionName, args.toString(), stdStrings));
-          }
-          // go to the end of the function copying anything found
-          i++;
-          while (i < len && p_sql.charAt(i) != '}') {
-            newsql.append(p_sql.charAt(i++));
-          }
-          state = SqlParseState.IN_SQLCODE; // end of escaped function (or query)
-          break;
-        case ESC_TIMEDATE:
-        case ESC_OUTERJOIN:
-        case ESC_ESCAPECHAR:
-          if (c == '}') {
-            state = SqlParseState.IN_SQLCODE; // end of escape code.
-          } else {
-            newsql.append(c);
-          }
-          break;
-      } // end switch
-    }
-    return i;
-  }
-
-  /**
-   * generate sql for escaped functions
-   *
-   * @param functionName the escaped function name
-   * @param args the arguments for this function
-   * @param stdStrings whether standard_conforming_strings is on
-   * @return the right postgreSql sql
-   * @throws SQLException if something goes wrong
-   */
-  protected static String escapeFunction(String functionName, String args, boolean stdStrings)
-      throws SQLException {
-    // parse function arguments
-    int len = args.length();
-    int i = 0;
-    ArrayList<StringBuilder> parsedArgs = new ArrayList<StringBuilder>();
-    while (i < len) {
-      StringBuilder arg = new StringBuilder();
-      int lastPos = i;
-      i = parseSql(args, i, arg, true, stdStrings);
-      if (lastPos != i) {
-        parsedArgs.add(arg);
-      }
-      i++;
-    }
-    // we can now translate escape functions
-    try {
-      Method escapeMethod = EscapedFunctions.getFunction(functionName);
-      return (String) escapeMethod.invoke(null, new Object[]{parsedArgs});
-    } catch (InvocationTargetException e) {
-      if (e.getTargetException() instanceof SQLException) {
-        throw (SQLException) e.getTargetException();
-      } else {
-        throw new PSQLException(e.getTargetException().getMessage(), PSQLState.SYSTEM_ERROR);
-      }
-    } catch (Exception e) {
-      // by default the function name is kept unchanged
-      StringBuilder buf = new StringBuilder();
-      buf.append(functionName).append('(');
-      for (int iArg = 0; iArg < parsedArgs.size(); iArg++) {
-        buf.append(parsedArgs.get(iArg));
-        if (iArg != (parsedArgs.size() - 1)) {
-          buf.append(',');
-        }
-      }
-      buf.append(')');
-      return buf.toString();
-    }
-  }
-
   /*
    *
    * The following methods are postgres extensions and are defined in the interface BaseStatement
@@ -902,10 +663,9 @@ public void addBatch(String p_sql) throws SQLException {
       batchParameters = new ArrayList<ParameterList>();
     }
 
-    p_sql = replaceProcessing(p_sql, replaceProcessingEnabled,
-        connection.getStandardConformingStrings());
-
-    batchStatements.add(connection.getQueryExecutor().createSimpleQuery(p_sql, connection.getAutoCommit()));
+    boolean shouldUseParameterized = connection.getPreferQueryMode().compareTo(PreferQueryMode.EXTENDED) >= 0;
+    CachedQuery cachedQuery = connection.createQuery(p_sql, replaceProcessingEnabled, shouldUseParameterized);
+    batchStatements.add(cachedQuery.query);
     batchParameters.add(null);
   }
 
@@ -964,13 +724,20 @@ public int[] executeBatch() throws SQLException {
       flags = QueryExecutor.QUERY_NO_RESULTS;
     }
 
+    PreferQueryMode preferQueryMode = connection.getPreferQueryMode();
+    if (preferQueryMode == PreferQueryMode.SIMPLE
+        || (preferQueryMode == PreferQueryMode.EXTENDED_FOR_PREPARED
+        && parameterLists[0] == null)) {
+      flags |= QueryExecutor.QUERY_EXECUTE_AS_SIMPLE;
+    }
+
     boolean sameQueryAhead = queries.length > 1 && queries[0] == queries[1];
 
-    if (isOneShotQuery(null)
+    if (!sameQueryAhead
         // If executing the same query twice in a batch, make sure the statement
         // is server-prepared. In other words, "oneshot" only if the query is one in the batch
         // or the queries are different
-        && !sameQueryAhead) {
+        && isOneShotQuery(null)) {
       flags |= QueryExecutor.QUERY_ONESHOT;
     } else {
       // If a batch requests generated keys and isn't already described,
@@ -999,7 +766,8 @@ public int[] executeBatch() throws SQLException {
     BatchResultHandler handler;
     handler = createBatchHandler(queries, parameterLists);
 
-    if (preDescribe || forceBinaryTransfers) {
+    if ((preDescribe || forceBinaryTransfers)
+        && (flags & QueryExecutor.QUERY_EXECUTE_AS_SIMPLE) == 0) {
       // Do a client-server round trip, parsing and describing the query so we
       // can determine its result types for use in binary parameters, batch sizing,
       // etc.
@@ -1178,40 +946,6 @@ protected boolean getForceBinaryTransfer() {
     return forceBinaryTransfers;
   }
 
-  static String addReturning(BaseConnection connection, String sql, String columns[],
-      boolean escape) throws SQLException {
-    if (!connection.haveMinimumServerVersion(ServerVersion.v8_2)) {
-      throw new PSQLException(
-          GT.tr("Returning autogenerated keys is only supported for 8.2 and later servers."),
-          PSQLState.NOT_IMPLEMENTED);
-    }
-
-    sql = sql.trim();
-    if (sql.endsWith(";")) {
-      sql = sql.substring(0, sql.length() - 1);
-    }
-
-    StringBuilder sb = new StringBuilder(sql);
-    sb.append(" RETURNING ");
-    for (int i = 0; i < columns.length; i++) {
-      if (i != 0) {
-        sb.append(", ");
-      }
-      // If given user provided column names, quote and escape them.
-      // This isn't likely to be popular as it enforces case sensitivity,
-      // but it does match up with our handling of things like
-      // DatabaseMetaData.getColumns and is necessary for the same
-      // reasons.
-      if (escape) {
-        Utils.escapeIdentifier(sb, columns[i]);
-      } else {
-        sb.append(columns[i]);
-      }
-    }
-
-    return sb.toString();
-  }
-
   public long getLargeUpdateCount() throws SQLException {
     throw Driver.notImplemented(this.getClass(), "getLargeUpdateCount");
   }
@@ -1349,10 +1083,7 @@ public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException
       return executeUpdate(sql);
     }
 
-    sql = addReturning(connection, sql, new String[]{"*"}, false);
-    wantsGeneratedKeysOnce = true;
-
-    return executeUpdate(sql);
+    return executeUpdate(sql, (String[]) null);
   }
 
   public int executeUpdate(String sql, int columnIndexes[]) throws SQLException {
@@ -1365,29 +1096,26 @@ public int executeUpdate(String sql, int columnIndexes[]) throws SQLException {
   }
 
   public int executeUpdate(String sql, String columnNames[]) throws SQLException {
-    if (columnNames == null || columnNames.length == 0) {
+    if (columnNames != null && columnNames.length == 0) {
       return executeUpdate(sql);
     }
 
-    sql = PgStatement.addReturning(connection, sql, columnNames, true);
     wantsGeneratedKeysOnce = true;
-
-    return executeUpdate(sql);
+    if (!executeCachedSql(sql, 0, columnNames)) {
+      // no resultset returned. What's a pity!
+    }
+    return getUpdateCount();
   }
 
   public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
     if (autoGeneratedKeys == Statement.NO_GENERATED_KEYS) {
       return execute(sql);
     }
-
-    sql = PgStatement.addReturning(connection, sql, new String[]{"*"}, false);
-    wantsGeneratedKeysOnce = true;
-
-    return execute(sql);
+    return execute(sql, (String[]) null);
   }
 
   public boolean execute(String sql, int columnIndexes[]) throws SQLException {
-    if (columnIndexes == null || columnIndexes.length == 0) {
+    if (columnIndexes != null && columnIndexes.length == 0) {
       return execute(sql);
     }
 
@@ -1396,14 +1124,12 @@ public boolean execute(String sql, int columnIndexes[]) throws SQLException {
   }
 
   public boolean execute(String sql, String columnNames[]) throws SQLException {
-    if (columnNames == null || columnNames.length == 0) {
+    if (columnNames != null && columnNames.length == 0) {
       return execute(sql);
     }
 
-    sql = PgStatement.addReturning(connection, sql, columnNames, true);
     wantsGeneratedKeysOnce = true;
-
-    return execute(sql);
+    return executeCachedSql(sql, 0, columnNames);
   }
 
   public int getResultSetHoldability() throws SQLException {
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/PreferQueryMode.java b/pgjdbc/src/main/java/org/postgresql/jdbc/PreferQueryMode.java
new file mode 100644
index 0000000000..3b68fccabe
--- /dev/null
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/PreferQueryMode.java
@@ -0,0 +1,35 @@
+package org.postgresql.jdbc;
+
+/**
+ * Specifies which mode is used to execute queries to database: simple means ('Q' execute, no parse, no bind, text mode only),
+ * extended means always use bind/execute messages, extendedForPrepared means extended for prepared statements only.
+ *
+ * Note: this is for debugging purposes only.
+ *
+ * @see org.postgresql.PGProperty#PREFER_QUERY_MODE
+ */
+public enum PreferQueryMode {
+  SIMPLE("simple"),
+  EXTENDED_FOR_PREPARED("extendedForPrepared"),
+  EXTENDED("extended"),
+  EXTENDED_CACHE_EVERYTING("extendedCacheEveryting");
+
+  private final String value;
+
+  PreferQueryMode(String value) {
+    this.value = value;
+  }
+
+  public static PreferQueryMode of(String mode) {
+    for (PreferQueryMode preferQueryMode : values()) {
+      if (preferQueryMode.value.equals(mode)) {
+        return preferQueryMode;
+      }
+    }
+    return EXTENDED;
+  }
+
+  public String value() {
+    return value;
+  }
+}
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/TimestampUtils.java b/pgjdbc/src/main/java/org/postgresql/jdbc/TimestampUtils.java
index 7a13c09245..d362f096b0 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/TimestampUtils.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/TimestampUtils.java
@@ -79,7 +79,7 @@ public class TimestampUtils {
         continue;
       }
       GMT_ZONES.put(pgZoneName + Math.abs(i), timeZone);
-      GMT_ZONES.put(pgZoneName + NUMBERS[Math.abs(i)], timeZone);
+      GMT_ZONES.put(pgZoneName + new String(NUMBERS[Math.abs(i)]), timeZone);
     }
     // Fast path to getting the default timezone.
     // Accessing the default timezone over and over creates a clone with regular API.
@@ -356,7 +356,7 @@ private ParsedTimestamp parseBackendTimestamp(String str) throws SQLException {
 
     } catch (NumberFormatException nfe) {
       throw new PSQLException(
-          GT.tr("Bad value for type timestamp/date/time: {1}", new Object[]{str}),
+          GT.tr("Bad value for type timestamp/date/time: {1}", str),
           PSQLState.BAD_DATETIME_FORMAT, nfe);
     }
 
@@ -484,6 +484,7 @@ private Calendar setupCalendar(Calendar cal) {
   /**
    * Get a shared calendar, applying the supplied time zone or the default time zone if null.
    *
+   * @param timeZone time zone to be set for the calendar
    * @return The shared calendar.
    */
   public Calendar getSharedCalendar(TimeZone timeZone) {
@@ -993,6 +994,7 @@ private ParsedBinaryTimestamp toParsedTimestampBin(TimeZone tz, byte[] bytes, bo
    * Returns the local date time object matching the given bytes with {@link Oid#TIMESTAMP} or
    * {@link Oid#TIMESTAMPTZ}.
    *
+   * @param tz time zone to use
    * @param bytes The binary encoded local date time value.
    * @return The parsed local date time object.
    * @throws PSQLException If binary format could not be parsed.
@@ -1265,6 +1267,8 @@ public void toBinDate(TimeZone tz, byte[] bytes, Date value) throws PSQLExceptio
   /**
    * Converts backend's TimeZone parameter to java format.
    * Notable difference: backend's gmt-3 is GMT+03 in Java.
+   *
+   * @param timeZone time zone to use
    * @return java TimeZone
    */
   public static TimeZone parseBackendTimeZone(String timeZone) {
diff --git a/pgjdbc/src/main/java/org/postgresql/jdbc/TypeInfoCache.java b/pgjdbc/src/main/java/org/postgresql/jdbc/TypeInfoCache.java
index d80a58cf34..d628dab3fb 100644
--- a/pgjdbc/src/main/java/org/postgresql/jdbc/TypeInfoCache.java
+++ b/pgjdbc/src/main/java/org/postgresql/jdbc/TypeInfoCache.java
@@ -67,8 +67,6 @@ public class TypeInfoCache implements TypeInfo {
   // 2 - sql type
   // 3 - java class
   // 4 - array type oid
-  // 5 - conditional minimum server version
-  // 6 - conditional minimum JDK build version
   private static final Object types[][] = {
       {"int2", Oid.INT2, Types.SMALLINT, "java.lang.Integer", Oid.INT2_ARRAY},
       {"int4", Oid.INT4, Types.INTEGER, "java.lang.Integer", Oid.INT4_ARRAY},
@@ -92,6 +90,11 @@ public class TypeInfoCache implements TypeInfo {
       {"timestamp", Oid.TIMESTAMP, Types.TIMESTAMP, "java.sql.Timestamp", Oid.TIMESTAMP_ARRAY},
       {"timestamptz", Oid.TIMESTAMPTZ, Types.TIMESTAMP, "java.sql.Timestamp",
           Oid.TIMESTAMPTZ_ARRAY},
+      //#if mvn.project.property.postgresql.jdbc.spec >= "JDBC4.2"
+      {"refcursor", Oid.REF_CURSOR, Types.REF_CURSOR, "java.sql.ResultSet", Oid.REF_CURSOR_ARRAY},
+      //#endif
+      {"json", Oid.JSON, Types.VARCHAR, "java.lang.String", Oid.JSON_ARRAY},
+      {"point", Oid.POINT, Types.OTHER, "org.postgresql.geometric.PGpoint", Oid.POINT_ARRAY}
   };
 
   /**
diff --git a/pgjdbc/src/main/java/org/postgresql/ssl/MakeSSL.java b/pgjdbc/src/main/java/org/postgresql/ssl/MakeSSL.java
index e9108ae238..caeadc7087 100644
--- a/pgjdbc/src/main/java/org/postgresql/ssl/MakeSSL.java
+++ b/pgjdbc/src/main/java/org/postgresql/ssl/MakeSSL.java
@@ -82,7 +82,7 @@ public static void convert(PGStream stream, Properties info, Logger logger)
       if (!hvn.verify(stream.getHostSpec().getHost(), newConnection.getSession())) {
         throw new PSQLException(
             GT.tr("The hostname {0} could not be verified by hostnameverifier {1}.",
-                new Object[]{stream.getHostSpec().getHost(), sslhostnameverifier}),
+                stream.getHostSpec().getHost(), sslhostnameverifier),
             PSQLState.CONNECTION_FAILURE);
       }
     } else {
diff --git a/pgjdbc/src/main/java/org/postgresql/ssl/jdbc4/LazyKeyManager.java b/pgjdbc/src/main/java/org/postgresql/ssl/jdbc4/LazyKeyManager.java
index c3611a2760..99cb19ad54 100644
--- a/pgjdbc/src/main/java/org/postgresql/ssl/jdbc4/LazyKeyManager.java
+++ b/pgjdbc/src/main/java/org/postgresql/ssl/jdbc4/LazyKeyManager.java
@@ -78,6 +78,7 @@ public void throwKeyManagerException() throws PSQLException {
     }
   }
 
+  @Override
   public String chooseClientAlias(String[] keyType, Principal[] issuers, Socket socket) {
     if (certfile == null) {
       return null;
@@ -107,10 +108,12 @@ public String chooseClientAlias(String[] keyType, Principal[] issuers, Socket so
     }
   }
 
+  @Override
   public String chooseServerAlias(String keyType, Principal[] issuers, Socket socket) {
     return null; // We are not a server
   }
 
+  @Override
   public X509Certificate[] getCertificateChain(String alias) {
     if (cert == null && certfile != null) {
       // If certfile is null, we do not load the certificate
@@ -122,8 +125,8 @@ public X509Certificate[] getCertificateChain(String alias) {
         // For some strange reason it throws CertificateException instead of
         // NoSuchAlgorithmException...
         error = new PSQLException(GT.tr(
-            "Could not find a java cryptographic algorithm: X.509 CertificateFactory not available.",
-            null), PSQLState.CONNECTION_FAILURE, ex);
+            "Could not find a java cryptographic algorithm: X.509 CertificateFactory not available."),
+            PSQLState.CONNECTION_FAILURE, ex);
         return null;
       }
       Collection<? extends Certificate> certs;
@@ -132,13 +135,13 @@ public X509Certificate[] getCertificateChain(String alias) {
       } catch (FileNotFoundException ioex) {
         if (!defaultfile) { // It is not an error if there is no file at the default location
           error = new PSQLException(
-              GT.tr("Could not open SSL certificate file {0}.", new Object[]{certfile}),
+              GT.tr("Could not open SSL certificate file {0}.", certfile),
               PSQLState.CONNECTION_FAILURE, ioex);
         }
         return null;
       } catch (CertificateException gsex) {
         error = new PSQLException(GT.tr("Loading the SSL certificate {0} into a KeyManager failed.",
-            new Object[]{certfile}), PSQLState.CONNECTION_FAILURE, gsex);
+            certfile), PSQLState.CONNECTION_FAILURE, gsex);
         return null;
       }
       cert = certs.toArray(new X509Certificate[certs.size()]);
@@ -146,11 +149,13 @@ public X509Certificate[] getCertificateChain(String alias) {
     return cert;
   }
 
+  @Override
   public String[] getClientAliases(String keyType, Principal[] issuers) {
     String alias = chooseClientAlias(new String[]{keyType}, issuers, (Socket) null);
     return (alias == null ? new String[]{} : new String[]{alias});
   }
 
+  @Override
   public PrivateKey getPrivateKey(String alias) {
     RandomAccessFile raf = null;
     try {
@@ -199,13 +204,13 @@ public PrivateKey getPrivateKey(String alias) {
             if ((cbh instanceof LibPQFactory.ConsoleCallbackHandler)
                 && ("Console is not available".equals(ucex.getMessage()))) {
               error = new PSQLException(GT
-                  .tr("Could not read password for SSL key file, console is not available.", null),
+                  .tr("Could not read password for SSL key file, console is not available."),
                   PSQLState.CONNECTION_FAILURE, ucex);
             } else {
               error =
                   new PSQLException(
                       GT.tr("Could not read password for SSL key file by callbackhandler {0}.",
-                          new Object[]{cbh.getClass().getName()}),
+                              cbh.getClass().getName()),
                       PSQLState.CONNECTION_FAILURE, ucex);
             }
             return null;
@@ -223,7 +228,7 @@ public PrivateKey getPrivateKey(String alias) {
             key = kf.generatePrivate(pkcs8KeySpec);
           } catch (GeneralSecurityException ikex) {
             error = new PSQLException(
-                GT.tr("Could not decrypt SSL key file {0}.", new Object[]{keyfile}),
+                GT.tr("Could not decrypt SSL key file {0}.", keyfile),
                 PSQLState.CONNECTION_FAILURE, ikex);
             return null;
           }
@@ -237,17 +242,18 @@ public PrivateKey getPrivateKey(String alias) {
         }
       }
 
-      error = new PSQLException(GT.tr("Could not read SSL key file {0}.", new Object[]{keyfile}),
+      error = new PSQLException(GT.tr("Could not read SSL key file {0}.", keyfile),
           PSQLState.CONNECTION_FAILURE, ioex);
     } catch (NoSuchAlgorithmException ex) {
       error = new PSQLException(GT.tr("Could not find a java cryptographic algorithm: {0}.",
-          new Object[]{ex.getMessage()}), PSQLState.CONNECTION_FAILURE, ex);
+              ex.getMessage()), PSQLState.CONNECTION_FAILURE, ex);
       return null;
     }
 
     return key;
   }
 
+  @Override
   public String[] getServerAliases(String keyType, Principal[] issuers) {
     return new String[]{};
   }
diff --git a/pgjdbc/src/main/java/org/postgresql/ssl/jdbc4/LibPQFactory.java b/pgjdbc/src/main/java/org/postgresql/ssl/jdbc4/LibPQFactory.java
index 018c5ab284..cff09aaee2 100644
--- a/pgjdbc/src/main/java/org/postgresql/ssl/jdbc4/LibPQFactory.java
+++ b/pgjdbc/src/main/java/org/postgresql/ssl/jdbc4/LibPQFactory.java
@@ -119,7 +119,7 @@ public LibPQFactory(Properties info) throws PSQLException {
           fis = new FileInputStream(sslrootcertfile); // NOSONAR
         } catch (FileNotFoundException ex) {
           throw new PSQLException(
-              GT.tr("Could not open SSL root certificate file {0}.", new Object[]{sslrootcertfile}),
+              GT.tr("Could not open SSL root certificate file {0}.", sslrootcertfile),
               PSQLState.CONNECTION_FAILURE, ex);
         }
         try {
@@ -134,12 +134,12 @@ public LibPQFactory(Properties info) throws PSQLException {
           tmf.init(ks);
         } catch (IOException ioex) {
           throw new PSQLException(
-              GT.tr("Could not read SSL root certificate file {0}.", new Object[]{sslrootcertfile}),
+              GT.tr("Could not read SSL root certificate file {0}.", sslrootcertfile),
               PSQLState.CONNECTION_FAILURE, ioex);
         } catch (GeneralSecurityException gsex) {
           throw new PSQLException(
               GT.tr("Loading the SSL root certificate {0} into a TrustManager failed.",
-                  new Object[]{sslrootcertfile}),
+                      sslrootcertfile),
               PSQLState.CONNECTION_FAILURE, gsex);
         } finally {
           try {
@@ -157,14 +157,14 @@ public LibPQFactory(Properties info) throws PSQLException {
       try {
         ctx.init(new KeyManager[]{km}, tm, null);
       } catch (KeyManagementException ex) {
-        throw new PSQLException(GT.tr("Could not initialize SSL context.", null),
+        throw new PSQLException(GT.tr("Could not initialize SSL context."),
             PSQLState.CONNECTION_FAILURE, ex);
       }
 
       _factory = ctx.getSocketFactory();
     } catch (NoSuchAlgorithmException ex) {
       throw new PSQLException(GT.tr("Could not find a java cryptographic algorithm: {0}.",
-          new Object[]{ex.getMessage()}), PSQLState.CONNECTION_FAILURE, ex);
+              ex.getMessage()), PSQLState.CONNECTION_FAILURE, ex);
     }
   }
 
diff --git a/pgjdbc/src/main/java/org/postgresql/sspi/NTDSAPIWrapper.java b/pgjdbc/src/main/java/org/postgresql/sspi/NTDSAPIWrapper.java
index fee300acb3..80dd846673 100644
--- a/pgjdbc/src/main/java/org/postgresql/sspi/NTDSAPIWrapper.java
+++ b/pgjdbc/src/main/java/org/postgresql/sspi/NTDSAPIWrapper.java
@@ -9,7 +9,7 @@ public class NTDSAPIWrapper {
   static final NTDSAPIWrapper instance = new NTDSAPIWrapper();
 
   /**
-   * Convenience wrappre for NTDSAPI DsMakeSpn with Java friendly string and exception handling.
+   * Convenience wrapper for NTDSAPI DsMakeSpn with Java friendly string and exception handling.
    *
    * @param serviceClass See MSDN
    * @param serviceName See MSDN
diff --git a/pgjdbc/src/main/java/org/postgresql/sspi/SSPIClient.java b/pgjdbc/src/main/java/org/postgresql/sspi/SSPIClient.java
index b4999acb2d..a083e0a06f 100644
--- a/pgjdbc/src/main/java/org/postgresql/sspi/SSPIClient.java
+++ b/pgjdbc/src/main/java/org/postgresql/sspi/SSPIClient.java
@@ -203,7 +203,7 @@ public void continueSSPI(int msgLength) throws SQLException, IOException {
     logger.debug("Continuing SSPI negotiation");
 
     /* Read the response token from the server */
-    byte[] receivedToken = pgStream.Receive(msgLength);
+    byte[] receivedToken = pgStream.receive(msgLength);
 
     SecBufferDesc continueToken = new SecBufferDesc(Sspi.SECBUFFER_TOKEN, receivedToken);
 
@@ -229,9 +229,9 @@ private void sendSSPIResponse(byte[] outToken) throws IOException {
      * 'password' message containing the required data; the server knows we're doing SSPI
      * negotiation and will deal with it appropriately.
      */
-    pgStream.SendChar('p');
-    pgStream.SendInteger4(4 + outToken.length);
-    pgStream.Send(outToken);
+    pgStream.sendChar('p');
+    pgStream.sendInteger4(4 + outToken.length);
+    pgStream.send(outToken);
     pgStream.flush();
   }
 
diff --git a/pgjdbc/src/main/java/org/postgresql/util/GT.java b/pgjdbc/src/main/java/org/postgresql/util/GT.java
index a520f69b56..fb6e3473db 100644
--- a/pgjdbc/src/main/java/org/postgresql/util/GT.java
+++ b/pgjdbc/src/main/java/org/postgresql/util/GT.java
@@ -18,21 +18,12 @@
  * java.text.MessageFormat syntax and any arguments it may need. The returned String is the
  * localized version if available or the original if not.
  */
-
 public class GT {
 
   private final static GT _gt = new GT();
   private final static Object noargs[] = new Object[0];
 
-  public static String tr(String message) {
-    return _gt.translate(message, null);
-  }
-
-  public static String tr(String message, Object arg) {
-    return _gt.translate(message, new Object[]{arg});
-  }
-
-  public static String tr(String message, Object args[]) {
+  public static String tr(String message, Object... args) {
     return _gt.translate(message, args);
   }
 
diff --git a/pgjdbc/src/main/java/org/postgresql/util/LruCache.java b/pgjdbc/src/main/java/org/postgresql/util/LruCache.java
index 603be5bf7f..deda25d118 100644
--- a/pgjdbc/src/main/java/org/postgresql/util/LruCache.java
+++ b/pgjdbc/src/main/java/org/postgresql/util/LruCache.java
@@ -136,7 +136,15 @@ public synchronized void put(Key key, Value value) {
       return;
     }
     currentSize += valueSize;
-    cache.put(key, value);
+    Value prev = cache.put(key, value);
+    if (prev == null) {
+      return;
+    }
+    // This should be a rare case
+    currentSize -= prev.getSize();
+    if (prev != value) {
+      evictValue(prev);
+    }
   }
 
   public final static CreateAction NOOP_CREATE_ACTION = new CreateAction() {
diff --git a/pgjdbc/src/main/java/org/postgresql/util/PGbytea.java b/pgjdbc/src/main/java/org/postgresql/util/PGbytea.java
index 02ae1c64be..d088935a68 100644
--- a/pgjdbc/src/main/java/org/postgresql/util/PGbytea.java
+++ b/pgjdbc/src/main/java/org/postgresql/util/PGbytea.java
@@ -119,7 +119,7 @@ private static byte[] toBytesOctalEscaped(byte[] s) {
    * Converts a java byte[] into a PG bytea string (i.e. the text representation of the bytea data
    * type)
    */
-  public static String toPGString(byte[] p_buf) throws SQLException {
+  public static String toPGString(byte[] p_buf) {
     if (p_buf == null) {
       return null;
     }
diff --git a/pgjdbc/src/main/java/org/postgresql/util/PSQLState.java b/pgjdbc/src/main/java/org/postgresql/util/PSQLState.java
index 3b40229255..a0a986453b 100644
--- a/pgjdbc/src/main/java/org/postgresql/util/PSQLState.java
+++ b/pgjdbc/src/main/java/org/postgresql/util/PSQLState.java
@@ -83,6 +83,7 @@ public int hashCode() {
   public final static PSQLState NUMERIC_VALUE_OUT_OF_RANGE = new PSQLState("22003");
   public final static PSQLState BAD_DATETIME_FORMAT = new PSQLState("22007");
   public final static PSQLState DATETIME_OVERFLOW = new PSQLState("22008");
+  public final static PSQLState DIVISION_BY_ZERO = new PSQLState("22012");
   public final static PSQLState MOST_SPECIFIC_TYPE_DOES_NOT_MATCH = new PSQLState("2200G");
   public final static PSQLState INVALID_PARAMETER_VALUE = new PSQLState("22023");
 
@@ -91,6 +92,9 @@ public int hashCode() {
   public final static PSQLState TRANSACTION_STATE_INVALID = new PSQLState("25000");
   public final static PSQLState ACTIVE_SQL_TRANSACTION = new PSQLState("25001");
   public final static PSQLState NO_ACTIVE_SQL_TRANSACTION = new PSQLState("25P01");
+  public final static PSQLState IN_FAILED_SQL_TRANSACTION = new PSQLState("25P02");
+
+  public final static PSQLState INVALID_SQL_STATEMENT_NAME = new PSQLState("26000");
   public final static PSQLState INVALID_AUTHORIZATION_SPECIFICATION = new PSQLState("28000");
 
   public final static PSQLState STATEMENT_NOT_ALLOWED_IN_FUNCTION_CALL = new PSQLState("2F003");
diff --git a/pgjdbc/src/main/java/org/postgresql/util/ServerErrorMessage.java b/pgjdbc/src/main/java/org/postgresql/util/ServerErrorMessage.java
index 0fbeb4a946..df3fd260bb 100644
--- a/pgjdbc/src/main/java/org/postgresql/util/ServerErrorMessage.java
+++ b/pgjdbc/src/main/java/org/postgresql/util/ServerErrorMessage.java
@@ -8,6 +8,8 @@
 
 package org.postgresql.util;
 
+import org.postgresql.core.EncodingPredictor;
+
 import java.io.Serializable;
 import java.util.HashMap;
 import java.util.Map;
@@ -35,6 +37,16 @@ public class ServerErrorMessage implements Serializable {
   private final Map<Character, String> m_mesgParts = new HashMap<Character, String>();
   private final int verbosity;
 
+  public ServerErrorMessage(EncodingPredictor.DecodeResult serverError, int verbosity) {
+    this(serverError.result, verbosity);
+    if (serverError.encoding != null) {
+      m_mesgParts.put(MESSAGE, m_mesgParts.get(MESSAGE)
+          + GT.tr(" (pgjdbc: autodetected server-encoding to be {0}, if the message is not readable, please check database logs and/or host, port, dbname, user, password, pg_hba.conf)",
+          serverError.encoding)
+      );
+    }
+  }
+
   public ServerErrorMessage(String p_serverError, int verbosity) {
     this.verbosity = verbosity;
 
diff --git a/pgjdbc/src/main/java/org/postgresql/xa/PGXAConnection.java b/pgjdbc/src/main/java/org/postgresql/xa/PGXAConnection.java
index d857ab9ab7..6d670263a9 100644
--- a/pgjdbc/src/main/java/org/postgresql/xa/PGXAConnection.java
+++ b/pgjdbc/src/main/java/org/postgresql/xa/PGXAConnection.java
@@ -10,8 +10,8 @@
 import org.postgresql.PGConnection;
 import org.postgresql.core.BaseConnection;
 import org.postgresql.core.Logger;
-import org.postgresql.core.ProtocolConnection;
 import org.postgresql.core.ServerVersion;
+import org.postgresql.core.TransactionState;
 import org.postgresql.ds.PGPooledConnection;
 import org.postgresql.util.GT;
 import org.postgresql.util.PSQLException;
@@ -492,7 +492,7 @@ private void commitPrepared(Xid xid) throws XAException {
       // other XA or local transaction, or the COMMIT PREPARED command
       // would mess it up.
       if (state != STATE_IDLE
-          || conn.getTransactionState() != ProtocolConnection.TRANSACTION_IDLE) {
+          || conn.getTransactionState() != TransactionState.IDLE) {
         throw new PGXAException(
             GT.tr("Not implemented: 2nd phase commit must be issued using an idle connection"),
             XAException.XAER_RMERR);
diff --git a/pgjdbc/src/test/java/org/postgresql/core/ParserTest.java b/pgjdbc/src/test/java/org/postgresql/core/ParserTest.java
new file mode 100644
index 0000000000..3edb18f785
--- /dev/null
+++ b/pgjdbc/src/test/java/org/postgresql/core/ParserTest.java
@@ -0,0 +1,106 @@
+/*-------------------------------------------------------------------------
+ *
+ * Copyright (c) 2003-2016, PostgreSQL Global Development Group
+ *
+ *
+ *-------------------------------------------------------------------------
+ */
+
+package org.postgresql.core;
+
+import junit.framework.TestCase;
+
+import org.junit.Assert;
+
+/**
+ * Test cases for the Parser.
+ * @author Jeremy Whiting jwhiting@redhat.com
+ */
+public class ParserTest extends TestCase {
+
+  /**
+   * Test to make sure delete command is detected by parser and detected via
+   * api. Mix up the case of the command to check detection continues to work.
+   */
+  public void testDeleteCommandParsing() {
+    char[] command = new char[6];
+    "DELETE".getChars(0, 6, command, 0);
+    Assert.assertTrue("Failed to correctly parse upper case command.", Parser.parseDeleteKeyword(command, 0));
+    "DelEtE".getChars(0, 6, command, 0);
+    Assert.assertTrue("Failed to correctly parse mixed case command.", Parser.parseDeleteKeyword(command, 0));
+    "deleteE".getChars(0, 6, command, 0);
+    Assert.assertTrue("Failed to correctly parse mixed case command.", Parser.parseDeleteKeyword(command, 0));
+    "delete".getChars(0, 6, command, 0);
+    Assert.assertTrue("Failed to correctly parse lower case command.", Parser.parseDeleteKeyword(command, 0));
+    "Delete".getChars(0, 6, command, 0);
+    Assert.assertTrue("Failed to correctly parse mixed case command.", Parser.parseDeleteKeyword(command, 0));
+  }
+
+  /**
+   * Test UPDATE command parsing.
+   */
+  public void testUpdateCommandParsing() {
+    char[] command = new char[6];
+    "UPDATE".getChars(0, 6, command, 0);
+    Assert.assertTrue("Failed to correctly parse upper case command.", Parser.parseUpdateKeyword(command, 0));
+    "UpDateE".getChars(0, 6, command, 0);
+    Assert.assertTrue("Failed to correctly parse mixed case command.", Parser.parseUpdateKeyword(command, 0));
+    "updatE".getChars(0, 6, command, 0);
+    Assert.assertTrue("Failed to correctly parse mixed case command.", Parser.parseUpdateKeyword(command, 0));
+    "Update".getChars(0, 6, command, 0);
+    Assert.assertTrue("Failed to correctly parse mixed case command.", Parser.parseUpdateKeyword(command, 0));
+    "update".getChars(0, 6, command, 0);
+    Assert.assertTrue("Failed to correctly parse lower case command.", Parser.parseUpdateKeyword(command, 0));
+  }
+
+  /**
+   * Test MOVE command parsing.
+   */
+  public void testMoveCommandParsing() {
+    char[] command = new char[4];
+    "MOVE".getChars(0, 4, command, 0);
+    Assert.assertTrue("Failed to correctly parse upper case command.", Parser.parseMoveKeyword(command, 0));
+    "mOVe".getChars(0, 4, command, 0);
+    Assert.assertTrue("Failed to correctly parse mixed case command.", Parser.parseMoveKeyword(command, 0));
+    "movE".getChars(0, 4, command, 0);
+    Assert.assertTrue("Failed to correctly parse mixed case command.", Parser.parseMoveKeyword(command, 0));
+    "Move".getChars(0, 4, command, 0);
+    Assert.assertTrue("Failed to correctly parse mixed case command.", Parser.parseMoveKeyword(command, 0));
+    "move".getChars(0, 4, command, 0);
+    Assert.assertTrue("Failed to correctly parse lower case command.", Parser.parseMoveKeyword(command, 0));
+  }
+
+  /**
+   * Test WITH command parsing.
+   */
+  public void testWithCommandParsing() {
+    char[] command = new char[4];
+    "WITH".getChars(0, 4, command, 0);
+    Assert.assertTrue("Failed to correctly parse upper case command.", Parser.parseWithKeyword(command, 0));
+    "wITh".getChars(0, 4, command, 0);
+    Assert.assertTrue("Failed to correctly parse mixed case command.", Parser.parseWithKeyword(command, 0));
+    "witH".getChars(0, 4, command, 0);
+    Assert.assertTrue("Failed to correctly parse mixed case command.", Parser.parseWithKeyword(command, 0));
+    "With".getChars(0, 4, command, 0);
+    Assert.assertTrue("Failed to correctly parse mixed case command.", Parser.parseWithKeyword(command, 0));
+    "with".getChars(0, 4, command, 0);
+    Assert.assertTrue("Failed to correctly parse lower case command.", Parser.parseWithKeyword(command, 0));
+  }
+
+  /**
+   * Test SELECT command parsing.
+   */
+  public void testSelectCommandParsing() {
+    char[] command = new char[6];
+    "SELECT".getChars(0, 6, command, 0);
+    Assert.assertTrue("Failed to correctly parse upper case command.", Parser.parseSelectKeyword(command, 0));
+    "sELect".getChars(0, 6, command, 0);
+    Assert.assertTrue("Failed to correctly parse mixed case command.", Parser.parseSelectKeyword(command, 0));
+    "selecT".getChars(0, 6, command, 0);
+    Assert.assertTrue("Failed to correctly parse mixed case command.", Parser.parseSelectKeyword(command, 0));
+    "Select".getChars(0, 6, command, 0);
+    Assert.assertTrue("Failed to correctly parse mixed case command.", Parser.parseSelectKeyword(command, 0));
+    "select".getChars(0, 6, command, 0);
+    Assert.assertTrue("Failed to correctly parse lower case command.", Parser.parseSelectKeyword(command, 0));
+  }
+}
diff --git a/pgjdbc/src/test/java/org/postgresql/core/v2/V2ParameterListTests.java b/pgjdbc/src/test/java/org/postgresql/core/v2/V2ParameterListTests.java
deleted file mode 100644
index aab2c9c7a4..0000000000
--- a/pgjdbc/src/test/java/org/postgresql/core/v2/V2ParameterListTests.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*-------------------------------------------------------------------------
- *
- * Copyright (c) 2003-2016, PostgreSQL Global Development Group
- *
- *
- *-------------------------------------------------------------------------
- */
-
-package org.postgresql.core.v2;
-
-import org.postgresql.test.jdbc2.BaseTest;
-
-import java.sql.SQLException;
-
-/**
- * Test cases to make sure the parameterlist implementation works as expected.
- *
- * @author Jeremy Whiting jwhiting@redhat.com
- *
- */
-public class V2ParameterListTests extends BaseTest {
-
-  /**
-   * Test to check the merging of two parameter lists.
-   *
-   * @throws SQLException fault raised when setting parameter
-   */
-  public void testMergeOfParameterLists() throws SQLException {
-    SimpleParameterList o1SPL = new SimpleParameterList(8, Boolean.TRUE);
-    o1SPL.setIntParameter(1, 1);
-    o1SPL.setIntParameter(2, 2);
-    o1SPL.setIntParameter(3, 3);
-    o1SPL.setIntParameter(4, 4);
-
-    SimpleParameterList s2SPL = new SimpleParameterList(4, Boolean.TRUE);
-    s2SPL.setIntParameter(1, 5);
-    s2SPL.setIntParameter(2, 6);
-    s2SPL.setIntParameter(3, 7);
-    s2SPL.setIntParameter(4, 8);
-
-    o1SPL.appendAll(s2SPL);
-
-    assertEquals(
-        "Expected string representation of parameter list does not match product.",
-        "<[1 ,2 ,3 ,4 ,5 ,6 ,7 ,8]>", o1SPL.toString());
-  }
-
-  public V2ParameterListTests(String test) {
-    super(test);
-  }
-}
diff --git a/pgjdbc/src/test/java/org/postgresql/core/v3/V3ParameterListTests.java b/pgjdbc/src/test/java/org/postgresql/core/v3/V3ParameterListTests.java
index 056f88b702..a0e3a5df02 100644
--- a/pgjdbc/src/test/java/org/postgresql/core/v3/V3ParameterListTests.java
+++ b/pgjdbc/src/test/java/org/postgresql/core/v3/V3ParameterListTests.java
@@ -8,19 +8,11 @@
 
 package org.postgresql.core.v3;
 
-import org.postgresql.core.Logger;
-import org.postgresql.core.PGStream;
-import org.postgresql.core.v2.SocketFactoryFactory;
-import org.postgresql.test.TestUtil;
 import org.postgresql.test.jdbc2.BaseTest;
-import org.postgresql.util.HostSpec;
 
 import org.junit.Before;
 
 import java.sql.SQLException;
-import java.util.Properties;
-
-import javax.net.SocketFactory;
 
 /**
  * Test cases to make sure the parameterlist implementation works as expected.
@@ -38,13 +30,13 @@ public class V3ParameterListTests extends BaseTest {
    *           raised exception if setting parameter fails.
    */
   public void testMergeOfParameterLists() throws SQLException {
-    SimpleParameterList s1SPL = new SimpleParameterList(8, pci);
+    SimpleParameterList s1SPL = new SimpleParameterList(8, transferModeRegistry);
     s1SPL.setIntParameter(1, 1);
     s1SPL.setIntParameter(2, 2);
     s1SPL.setIntParameter(3, 3);
     s1SPL.setIntParameter(4, 4);
 
-    SimpleParameterList s2SPL = new SimpleParameterList(4, pci);
+    SimpleParameterList s2SPL = new SimpleParameterList(4, transferModeRegistry);
     s2SPL.setIntParameter(1, 5);
     s2SPL.setIntParameter(2, 6);
     s2SPL.setIntParameter(3, 7);
@@ -60,14 +52,22 @@ public V3ParameterListTests(String test) {
     super(test);
   }
 
-  private ProtocolConnectionImpl pci;
+  private TypeTransferModeRegistry transferModeRegistry;
 
   @Override
   @Before
   protected void setUp() throws Exception {
-    SocketFactory socketFactory = SocketFactoryFactory.getSocketFactory(System.getProperties());
-    HostSpec hostSpec = new HostSpec(TestUtil.getServer(), TestUtil.getPort());
-    pci = new ProtocolConnectionImpl(new PGStream(socketFactory, hostSpec), "",
-        "", new Properties(), new Logger(), 5000);
+    transferModeRegistry =
+        new TypeTransferModeRegistry() {
+          @Override
+          public boolean useBinaryForSend(int oid) {
+            return false;
+          }
+
+          @Override
+          public boolean useBinaryForReceive(int oid) {
+            return false;
+          }
+        };
   }
 }
diff --git a/pgjdbc/src/test/java/org/postgresql/jdbc/DeepBatchedInsertStatementTest.java b/pgjdbc/src/test/java/org/postgresql/jdbc/DeepBatchedInsertStatementTest.java
index 07db991ab0..8c40a07b9a 100644
--- a/pgjdbc/src/test/java/org/postgresql/jdbc/DeepBatchedInsertStatementTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/jdbc/DeepBatchedInsertStatementTest.java
@@ -21,7 +21,6 @@
 import java.sql.SQLException;
 import java.sql.Statement;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Properties;
 
 /**
@@ -120,8 +119,6 @@ public void testDeepInternalsBatchedQueryDecorator() throws Exception {
       assertEquals(3, getBatchSize(bqds));
 
       BatchExecuteTest.assertSimpleInsertBatch(3, pstmt.executeBatch());
-      assertTrue("Expected encoded name is not matched.", Arrays.equals( "S_2".getBytes(),
-          getEncodedStatementName(bqds[0])));
 
       pstmt.setInt(1, 1);
       pstmt.setInt(2, 2);
diff --git a/pgjdbc/src/test/java/org/postgresql/test/TestUtil.java b/pgjdbc/src/test/java/org/postgresql/test/TestUtil.java
index 1a8f881dc4..ab7f9378fe 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/TestUtil.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/TestUtil.java
@@ -13,6 +13,8 @@
 import org.postgresql.core.Version;
 import org.postgresql.jdbc.PgConnection;
 
+import org.junit.Assert;
+
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
@@ -291,6 +293,12 @@ public static java.sql.Connection openDB(Properties props) throws Exception {
     if (!props.containsKey(PGProperty.PREPARE_THRESHOLD.getName())) {
       PGProperty.PREPARE_THRESHOLD.set(props, getPrepareThreshold());
     }
+    if (!props.containsKey(PGProperty.PREFER_QUERY_MODE.getName())) {
+      String value = System.getProperty(PGProperty.PREFER_QUERY_MODE.getName());
+      if (value != null) {
+        props.put(PGProperty.PREFER_QUERY_MODE.getName(), value);
+      }
+    }
 
     return DriverManager.getConnection(getURL(), props);
   }
@@ -533,6 +541,21 @@ public static void dropType(Connection con, String type) throws SQLException {
     }
   }
 
+  public static void assertNumberOfRows(Connection con, String tableName, int expectedRows, String message)
+      throws SQLException {
+    PreparedStatement ps = null;
+    ResultSet rs = null;
+    try {
+      ps = con.prepareStatement("select count(*) from " + tableName + " as t");
+      rs = ps.executeQuery();
+      rs.next();
+      Assert.assertEquals(message, expectedRows, rs.getInt(1));
+    } finally {
+      closeQuietly(rs);
+      closeQuietly(ps);
+    }
+  }
+
   /*
    * Helper - generates INSERT SQL - very simple
    */
diff --git a/pgjdbc/src/test/java/org/postgresql/test/extensions/ExtensionsTestSuite.java b/pgjdbc/src/test/java/org/postgresql/test/extensions/ExtensionsTestSuite.java
index 95b32a15cd..6ba6a92fda 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/extensions/ExtensionsTestSuite.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/extensions/ExtensionsTestSuite.java
@@ -10,6 +10,7 @@
 
 import org.postgresql.test.TestUtil;
 
+import junit.framework.JUnit4TestAdapter;
 import junit.framework.TestSuite;
 
 import java.sql.Connection;
@@ -32,7 +33,7 @@ public static TestSuite suite() throws Exception {
     Connection connection = TestUtil.openDB();
     try {
       if (isHStoreEnabled(connection)) {
-        suite.addTestSuite(HStoreTest.class);
+        suite.addTest(new JUnit4TestAdapter(HStoreTest.class));
       }
     } finally {
       connection.close();
diff --git a/pgjdbc/src/test/java/org/postgresql/test/extensions/HStoreTest.java b/pgjdbc/src/test/java/org/postgresql/test/extensions/HStoreTest.java
index e9d82fdbe1..c339c09b7d 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/extensions/HStoreTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/extensions/HStoreTest.java
@@ -8,9 +8,16 @@
 
 package org.postgresql.test.extensions;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import org.postgresql.jdbc.PreferQueryMode;
 import org.postgresql.test.TestUtil;
+import org.postgresql.test.jdbc2.BaseTest4;
 
-import junit.framework.TestCase;
+import org.junit.Assume;
+import org.junit.Test;
 
 import java.sql.Connection;
 import java.sql.PreparedStatement;
@@ -24,22 +31,24 @@
 // SELECT 'hstore'::regtype::oid
 // SELECT 'hstore[]'::regtype::oid
 
-public class HStoreTest extends TestCase {
+public class HStoreTest extends BaseTest4 {
 
   private Connection _conn;
 
-  public HStoreTest(String name) {
-    super(name);
-  }
-
-  protected void setUp() throws Exception {
-    _conn = TestUtil.openDB();
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    _conn = con;
+    Assume.assumeFalse("hstore is not supported in simple protocol only mode",
+        preferQueryMode == PreferQueryMode.SIMPLE);
   }
 
-  protected void tearDown() throws SQLException {
+  @Override
+  public void tearDown() throws SQLException {
     TestUtil.closeDB(_conn);
   }
 
+  @Test
   public void testHStoreSelect() throws SQLException {
     PreparedStatement pstmt = _conn.prepareStatement("SELECT 'a=>1,b=>2'::hstore");
     ResultSet rs = pstmt.executeQuery();
@@ -55,6 +64,7 @@ public void testHStoreSelect() throws SQLException {
     assertEquals(correct, rs.getObject(1));
   }
 
+  @Test
   public void testHStoreSelectNullValue() throws SQLException {
     PreparedStatement pstmt = _conn.prepareStatement("SELECT 'a=>NULL'::hstore");
     ResultSet rs = pstmt.executeQuery();
@@ -65,6 +75,7 @@ public void testHStoreSelectNullValue() throws SQLException {
     assertEquals(correct, rs.getObject(1));
   }
 
+  @Test
   public void testHStoreSend() throws SQLException {
     Map<String, Integer> correct = Collections.singletonMap("a", 1);
     PreparedStatement pstmt = _conn.prepareStatement("SELECT ?::text");
@@ -75,6 +86,7 @@ public void testHStoreSend() throws SQLException {
     assertEquals("\"a\"=>\"1\"", rs.getString(1));
   }
 
+  @Test
   public void testHStoreUsingPSSetObject4() throws SQLException {
     Map<String, Integer> correct = Collections.singletonMap("a", 1);
     PreparedStatement pstmt = _conn.prepareStatement("SELECT ?::text");
@@ -85,6 +97,7 @@ public void testHStoreUsingPSSetObject4() throws SQLException {
     assertEquals("\"a\"=>\"1\"", rs.getString(1));
   }
 
+  @Test
   public void testHStoreSendEscaped() throws SQLException {
     Map<String, String> correct = Collections.singletonMap("a", "t'e\ns\"t");
     PreparedStatement pstmt = _conn.prepareStatement("SELECT ?");
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ArrayTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ArrayTest.java
index 82cc44b675..672338fcde 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ArrayTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ArrayTest.java
@@ -12,6 +12,7 @@
 import org.postgresql.geometric.PGbox;
 import org.postgresql.geometric.PGpoint;
 import org.postgresql.jdbc.PgArray;
+import org.postgresql.jdbc.PreferQueryMode;
 import org.postgresql.test.TestUtil;
 
 import org.junit.Assert;
@@ -404,7 +405,7 @@ public void testWriteMultiDimensional() throws SQLException {
     stmt.close();
 
     String sql = "SELECT ?";
-    if (TestUtil.isProtocolVersion(conn, 2)) {
+    if (preferQueryMode == PreferQueryMode.SIMPLE) {
       sql = "SELECT ?::int[]";
     }
     PreparedStatement pstmt = conn.prepareStatement(sql);
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/AutoRollbackTestSuite.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/AutoRollbackTestSuite.java
new file mode 100644
index 0000000000..4a3ea6e51f
--- /dev/null
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/AutoRollbackTestSuite.java
@@ -0,0 +1,339 @@
+package org.postgresql.test.jdbc2;
+
+import org.postgresql.PGConnection;
+import org.postgresql.PGProperty;
+import org.postgresql.core.BaseConnection;
+import org.postgresql.core.ResultHandler;
+import org.postgresql.core.TransactionState;
+import org.postgresql.jdbc.AutoSave;
+import org.postgresql.jdbc.PgConnection;
+import org.postgresql.jdbc.PreferQueryMode;
+import org.postgresql.test.TestUtil;
+import org.postgresql.util.PSQLState;
+
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Statement;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.EnumSet;
+import java.util.Properties;
+
+@RunWith(Parameterized.class)
+public class AutoRollbackTestSuite extends BaseTest4 {
+
+  private enum FailMode {
+    /**
+     * Executes "select 1/0" and causes transaction failure (if autocommit=no).
+     * Mitigation: "autosave=always" or "autocommit=true"
+     */
+    SELECT,
+    /**
+     * Executes "alter table rollbacktest", thus it breaks a prepared select over that table
+     * Mitigation: "autosave in (always, conservative)"
+     */
+    ALTER,
+    /**
+     * Executes DEALLOCATE ALL
+     * Mitigation:
+     *  1) QueryExecutor tracks "DEALLOCATE ALL" responses ({@see org.postgresql.core.QueryExecutor#setFlushCacheOnDeallocate(boolean)}
+     *  2) QueryExecutor tracks "prepared statement name is invalid" and unprepares relevant statements ({@link org.postgresql.core.v3.QueryExecutorImpl#processResults(ResultHandler, int)}
+     *  3) "autosave in (always, conservative)"
+     *  4) Non-transactional cases are healed by retry (when no transaction present, just retry is possible)
+     */
+    DEALLOCATE,
+    /**
+     * Executes DISCARD ALL
+     * Mitigation: the same as for {@link #DEALLOCATE}
+     */
+    DISCARD,
+    /**
+     * Executes "insert ... select 1/0" in a batch statement, thus causing the transaction to fail.
+     */
+    INSERT_BATCH,
+  }
+
+  private final static EnumSet<FailMode> DEALLOCATES =
+      EnumSet.of(FailMode.DEALLOCATE, FailMode.DISCARD);
+
+  private final static EnumSet<FailMode> TRANS_KILLERS =
+      EnumSet.of(FailMode.SELECT, FailMode.INSERT_BATCH);
+
+  private enum ContinueMode {
+    COMMIT,
+    IS_VALID,
+    SELECT,
+  }
+
+  private final AutoSave autoSave;
+  private final AutoCommit autoCommit;
+  private final FailMode failMode;
+  private final ContinueMode continueMode;
+  private final boolean flushCacheOnDeallocate;
+
+  public AutoRollbackTestSuite(AutoSave autoSave, AutoCommit autoCommit,
+      FailMode failMode, ContinueMode continueMode, boolean flushCacheOnDeallocate) {
+    this.autoSave = autoSave;
+    this.autoCommit = autoCommit;
+    this.failMode = failMode;
+    this.continueMode = continueMode;
+    this.flushCacheOnDeallocate = flushCacheOnDeallocate;
+  }
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    TestUtil.createTable(con, "rollbacktest", "a int, str text");
+    con.setAutoCommit(autoCommit == AutoCommit.YES);
+    BaseConnection baseConnection = con.unwrap(BaseConnection.class);
+    baseConnection.setFlushCacheOnDeallocate(flushCacheOnDeallocate);
+  }
+
+  @Override
+  public void tearDown() throws SQLException {
+    try {
+      con.setAutoCommit(true);
+      TestUtil.dropTable(con, "rollbacktest");
+    } catch (Exception e) {
+      e.printStackTrace();
+    }
+    super.tearDown();
+  }
+
+  @Override
+  protected void updateProperties(Properties props) {
+    super.updateProperties(props);
+    PGProperty.AUTOSAVE.set(props, autoSave.value());
+    PGProperty.PREPARE_THRESHOLD.set(props, 1);
+  }
+
+
+  @Parameterized.Parameters(name = "{index}: autorollback(autoSave={0}, autoCommit={1}, failMode={2}, continueMode={3}, flushOnDeallocate={4})")
+  public static Iterable<Object[]> data() {
+    Collection<Object[]> ids = new ArrayList<Object[]>();
+    boolean[] booleans = new boolean[] {true, false};
+    for (AutoSave autoSave : AutoSave.values()) {
+      for (AutoCommit autoCommit : AutoCommit.values()) {
+        for (FailMode failMode : FailMode.values()) {
+          // ERROR: DISCARD ALL cannot run inside a transaction block
+          if (failMode == FailMode.DISCARD && autoCommit == AutoCommit.NO) {
+            continue;
+          }
+          for (ContinueMode continueMode : ContinueMode.values()) {
+            if (failMode == FailMode.ALTER && continueMode != ContinueMode.SELECT) {
+              continue;
+            }
+            for (boolean flushCacheOnDeallocate : booleans) {
+              if (!(flushCacheOnDeallocate || DEALLOCATES.contains(failMode))) {
+                continue;
+              }
+
+              ids.add(new Object[]{autoSave, autoCommit, failMode, continueMode, flushCacheOnDeallocate});
+            }
+          }
+        }
+      }
+    }
+    return ids;
+  }
+
+
+  @Test
+  public void run() throws SQLException {
+    if (continueMode == ContinueMode.IS_VALID) {
+      // make "isValid" a server-prepared statement
+      con.isValid(4);
+    } else if (continueMode == ContinueMode.COMMIT) {
+      doCommit();
+    } else if (continueMode == ContinueMode.SELECT) {
+      assertRows("rollbacktest", 0);
+    }
+
+    Statement statement = con.createStatement();
+    statement.executeUpdate("insert into rollbacktest(a, str) values (0, 'test')");
+
+    PreparedStatement ps = con.prepareStatement("select * from rollbacktest");
+    // Server-prepare the statement
+    ps.executeQuery().close();
+
+    switch (failMode) {
+      case SELECT:
+        try {
+          statement.execute("select 1/0");
+          Assert.fail("select 1/0 should fail");
+        } catch (SQLException e) {
+          Assert.assertEquals("division by zero expected",
+              PSQLState.DIVISION_BY_ZERO.getState(), e.getSQLState());
+        }
+        break;
+      case DEALLOCATE:
+        statement.executeUpdate("DEALLOCATE ALL");
+        break;
+      case DISCARD:
+        statement.executeUpdate("DISCARD ALL");
+        break;
+      case ALTER:
+        statement.executeUpdate("alter table rollbacktest add q int");
+        break;
+      case INSERT_BATCH:
+        try {
+          statement.addBatch("insert into rollbacktest(a, str) values (1/0, 'test')");
+          statement.executeBatch();
+          Assert.fail("select 1/0 should fail");
+        } catch (SQLException e) {
+          Assert.assertEquals("division by zero expected",
+              PSQLState.DIVISION_BY_ZERO.getState(), e.getSQLState());
+        }
+        break;
+      default:
+        Assert.fail("Fail mode " + failMode + " is not implemented");
+    }
+
+    PgConnection pgConnection = con.unwrap(PgConnection.class);
+    if (autoSave == AutoSave.ALWAYS) {
+      Assert.assertNotEquals("In AutoSave.ALWAYS, transaction should not fail",
+          TransactionState.FAILED, pgConnection.getTransactionState());
+    }
+    if (autoCommit == AutoCommit.NO) {
+      Assert.assertNotEquals("AutoCommit == NO, thus transaction should be active (open or failed)",
+          TransactionState.IDLE, pgConnection.getTransactionState());
+    }
+    statement.close();
+
+    switch (continueMode) {
+      case COMMIT:
+        try {
+          doCommit();
+          // No assert here: commit should always succeed with exception of well known failure cases in catch
+        } catch (SQLException e) {
+          if (!flushCacheOnDeallocate && DEALLOCATES.contains(failMode)
+              && autoSave == AutoSave.NEVER) {
+            Assert.assertEquals(
+                "flushCacheOnDeallocate is disabled, thus " + failMode + " should cause 'prepared statement \"...\" does not exist'"
+                    + " error message is " + e.getMessage(),
+                PSQLState.INVALID_SQL_STATEMENT_NAME.getState(), e.getSQLState());
+            return;
+          }
+          throw e;
+        }
+        return;
+      case IS_VALID:
+        if (!flushCacheOnDeallocate && autoSave == AutoSave.NEVER
+            && DEALLOCATES.contains(failMode) && autoCommit == AutoCommit.NO
+            && con.unwrap(PGConnection.class).getPreferQueryMode() != PreferQueryMode.SIMPLE) {
+          Assert.assertFalse("Connection.isValid should return false since failMode=" + failMode
+              + ", flushCacheOnDeallocate=false, and autosave=NEVER",
+              con.isValid(4));
+        } else {
+          Assert.assertTrue("Connection.isValid should return true unless the connection is closed",
+              con.isValid(4));
+        }
+        return;
+      default:
+        break;
+    }
+
+    try {
+      // Try execute server-prepared statement again
+      ps.executeQuery().close();
+      executeSqlSuccess();
+    } catch (SQLException e) {
+      if (autoSave != AutoSave.ALWAYS && TRANS_KILLERS.contains(failMode) && autoCommit == AutoCommit.NO) {
+        Assert.assertEquals(
+            "AutoSave==" + autoSave + ", thus statements should fail with 'current transaction is aborted...', "
+                + " error message is " + e.getMessage(),
+            PSQLState.IN_FAILED_SQL_TRANSACTION.getState(), e.getSQLState());
+        return;
+      }
+
+      if (autoSave == AutoSave.NEVER && autoCommit == AutoCommit.NO) {
+        if (DEALLOCATES.contains(failMode) && !flushCacheOnDeallocate) {
+          Assert.assertEquals(
+              "flushCacheOnDeallocate is disabled, thus " + failMode + " should cause 'prepared statement \"...\" does not exist'"
+                  + " error message is " + e.getMessage(),
+              PSQLState.INVALID_SQL_STATEMENT_NAME.getState(), e.getSQLState());
+        } else if (failMode == FailMode.ALTER) {
+          Assert.assertEquals(
+              "AutoSave==NEVER, autocommit=NO, thus ALTER TABLE causes SELECT * to fail with "
+                  + "'cached plan must not change result type', "
+                  + " error message is " + e.getMessage(),
+              PSQLState.NOT_IMPLEMENTED.getState(), e.getSQLState());
+        } else {
+          throw e;
+        }
+      } else {
+        throw e;
+      }
+    }
+
+
+    try {
+      assertRows("rollbacktest", 1);
+      executeSqlSuccess();
+    } catch (SQLException e) {
+      if (autoSave == AutoSave.NEVER && autoCommit == AutoCommit.NO) {
+        if (DEALLOCATES.contains(failMode) && !flushCacheOnDeallocate
+            || failMode == FailMode.ALTER) {
+          // The above statement failed with "prepared statement does not exist", thus subsequent one should fail with
+          // transaction aborted.
+          Assert.assertEquals(
+              "AutoSave==NEVER, thus statements should fail with 'current transaction is aborted...', "
+                  + " error message is " + e.getMessage(),
+              PSQLState.IN_FAILED_SQL_TRANSACTION.getState(), e.getSQLState());
+        }
+      } else {
+        throw e;
+      }
+    }
+  }
+
+  private void executeSqlSuccess() throws SQLException {
+    if (autoCommit == AutoCommit.YES) {
+      // in autocommit everything should just work
+    } else if (TRANS_KILLERS.contains(failMode)) {
+      if (autoSave != AutoSave.ALWAYS) {
+        Assert.fail(
+            "autosave= " + autoSave + " != ALWAYS, thus the transaction should be killed");
+      }
+    } else if (DEALLOCATES.contains(failMode)) {
+      if (autoSave == AutoSave.NEVER && !flushCacheOnDeallocate
+          && con.unwrap(PGConnection.class).getPreferQueryMode() != PreferQueryMode.SIMPLE) {
+        Assert.fail("flushCacheOnDeallocate == false, thus DEALLOCATE ALL should kill the transaction");
+      }
+    } else if (failMode == FailMode.ALTER) {
+      if (autoSave == AutoSave.NEVER
+          && con.unwrap(PGConnection.class).getPreferQueryMode() != PreferQueryMode.SIMPLE) {
+        Assert.fail("autosave=NEVER, thus the transaction should be killed");
+      }
+    } else {
+      Assert.fail("It is not specified why the test should pass, thus marking a failure");
+    }
+  }
+
+  private void assertRows(String tableName, int nrows) throws SQLException {
+    Statement st = con.createStatement();
+    ResultSet rs = st.executeQuery("select count(*) from " + tableName);
+    rs.next();
+    Assert.assertEquals("Table " + tableName, nrows, rs.getInt(1));
+  }
+
+  private void doCommit() throws SQLException {
+    // Such a dance is required since "commit" checks "current transaction state",
+    // so we need some pending changes, so "commit" query would be sent to the database
+    if (con.getAutoCommit()) {
+      con.setAutoCommit(false);
+      Statement st = con.createStatement();
+      st.executeUpdate(
+          "insert into rollbacktest(a, str) values (42, '" + System.currentTimeMillis() + "')");
+      st.close();
+    }
+    con.commit();
+    con.setAutoCommit(autoCommit == AutoCommit.YES);
+  }
+}
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BaseTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BaseTest.java
index 0db9c202a7..cb3e083e47 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BaseTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BaseTest.java
@@ -1,9 +1,12 @@
 package org.postgresql.test.jdbc2;
 
+import org.postgresql.PGConnection;
 import org.postgresql.PGProperty;
+import org.postgresql.jdbc.PreferQueryMode;
 import org.postgresql.test.TestUtil;
 
 import junit.framework.TestCase;
+import org.junit.Assume;
 
 import java.sql.Connection;
 import java.sql.SQLException;
@@ -11,6 +14,7 @@
 
 public class BaseTest extends TestCase {
   protected Connection con;
+  protected PreferQueryMode preferQueryMode;
 
   public BaseTest(String name) {
     super(name);
@@ -33,9 +37,16 @@ protected void setUp() throws Exception {
     Properties props = new Properties();
     updateProperties(props);
     con = TestUtil.openDB(props);
+    PGConnection pg = con.unwrap(PGConnection.class);
+    preferQueryMode = pg == null ? PreferQueryMode.EXTENDED : pg.getPreferQueryMode();
   }
 
   protected void tearDown() throws SQLException {
     TestUtil.closeDB(con);
   }
+
+  public void assumeByteaSupported() {
+    Assume.assumeTrue("bytea is not supported in simple protocol execution mode",
+        preferQueryMode.compareTo(PreferQueryMode.EXTENDED) >= 0);
+  }
 }
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BaseTest4.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BaseTest4.java
index f1e8fc3bee..ceefee9cd8 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BaseTest4.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BaseTest4.java
@@ -1,9 +1,12 @@
 package org.postgresql.test.jdbc2;
 
+import org.postgresql.PGConnection;
 import org.postgresql.PGProperty;
+import org.postgresql.jdbc.PreferQueryMode;
 import org.postgresql.test.TestUtil;
 
 import org.junit.After;
+import org.junit.Assume;
 import org.junit.Before;
 
 import java.sql.Connection;
@@ -22,6 +25,7 @@ public enum AutoCommit {
 
   protected Connection con;
   private BinaryMode binaryMode;
+  protected PreferQueryMode preferQueryMode;
 
   protected void updateProperties(Properties props) {
     if (binaryMode == BinaryMode.FORCE) {
@@ -42,10 +46,22 @@ public void setUp() throws Exception {
     Properties props = new Properties();
     updateProperties(props);
     con = TestUtil.openDB(props);
+    PGConnection pg = con.unwrap(PGConnection.class);
+    preferQueryMode = pg == null ? PreferQueryMode.EXTENDED : pg.getPreferQueryMode();
   }
 
   @After
   public void tearDown() throws SQLException {
     TestUtil.closeDB(con);
   }
+
+  public void assumeByteaSupported() {
+    Assume.assumeTrue("bytea is not supported in simple protocol execution mode",
+        preferQueryMode.compareTo(PreferQueryMode.EXTENDED) >= 0);
+  }
+
+  public void assumeCallableStatementsSupported() {
+    Assume.assumeTrue("callable statements are not fully supported in simple protocol execution mode",
+        preferQueryMode.compareTo(PreferQueryMode.EXTENDED) >= 0);
+  }
 }
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchExecuteTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchExecuteTest.java
index 7d70d96928..36540e397a 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchExecuteTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchExecuteTest.java
@@ -214,13 +214,16 @@ public void testSelectInBatchThrows() throws Exception {
     }
 
     int newValue = getCol1Value();
-    Assert.assertEquals("testbatch.col1 should not be updated since error happened in batch",
-        oldValue, newValue);
+    boolean firstOk = updateCounts[0] == 1 || updateCounts[0] == Statement.SUCCESS_NO_INFO;
+    boolean lastOk = updateCounts[2] == 1 || updateCounts[2] == Statement.SUCCESS_NO_INFO;
 
-    Assert.assertEquals("All rows should be marked as EXECUTE_FAILED",
-        Arrays.toString(new int[]{Statement.EXECUTE_FAILED, Statement.EXECUTE_FAILED,
-            Statement.EXECUTE_FAILED}),
-        Arrays.toString(updateCounts));
+    Assert.assertEquals("testbatch.col1 should account +1 and +2 for the relevant successful rows: "
+        + Arrays.toString(updateCounts),
+        oldValue + (firstOk ? 1 : 0) + (lastOk ? 2 : 0), newValue);
+
+    Assert.assertEquals("SELECT 0/0 should be marked as Statement.EXECUTE_FAILED",
+        Statement.EXECUTE_FAILED,
+        updateCounts[1]);
 
     stmt.close();
   }
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchedInsertReWriteEnabledTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchedInsertReWriteEnabledTest.java
index b5bef3eb22..ed34060ec0 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchedInsertReWriteEnabledTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/BatchedInsertReWriteEnabledTest.java
@@ -83,6 +83,7 @@ public void testBatchWithReWrittenRepeatedInsertStatementOptimizationEnabled()
       pstmt.setInt(2, 6);
       pstmt.addBatch();
       BatchExecuteTest.assertSimpleInsertBatch(3, pstmt.executeBatch());
+      TestUtil.assertNumberOfRows(con, "testbatch", 3, "3 rows inserted");
 
       /*
        * Now check the ps can be reused. The batched statement should be reset
@@ -104,6 +105,7 @@ public void testBatchWithReWrittenRepeatedInsertStatementOptimizationEnabled()
       pstmt.setInt(2, 8);
       pstmt.addBatch();
       BatchExecuteTest.assertSimpleInsertBatch(4, pstmt.executeBatch());
+      TestUtil.assertNumberOfRows(con, "testbatch", 7, "3+4 rows inserted");
 
       pstmt.setInt(1, 1);
       pstmt.setInt(2, 2);
@@ -118,6 +120,7 @@ public void testBatchWithReWrittenRepeatedInsertStatementOptimizationEnabled()
       pstmt.setInt(2, 8);
       pstmt.addBatch();
       BatchExecuteTest.assertSimpleInsertBatch(4, pstmt.executeBatch());
+      TestUtil.assertNumberOfRows(con, "testbatch", 11, "3+4+4 rows inserted");
 
     } finally {
       TestUtil.closeQuietly(pstmt);
@@ -148,6 +151,32 @@ public void testBatchWithReWrittenBatchStatementWithFixedParameter()
         pstmt.setInt(2, 6);
         pstmt.addBatch();
         BatchExecuteTest.assertSimpleInsertBatch(3, pstmt.executeBatch());
+        TestUtil.assertNumberOfRows(con, "testbatch", 3, "3 rows inserted");
+      } finally {
+        TestUtil.closeQuietly(pstmt);
+      }
+    }
+  }
+
+  /**
+   * Check batching using a statement with fixed parameters only.
+   */
+  @Test
+  public void testBatchWithReWrittenBatchStatementWithFixedParametersOnly()
+      throws SQLException {
+    String[] odd = new String[]{
+        "INSERT INTO testbatch VALUES (9, '1, (, $1234, a''n?d )' /*xxxx)*/, 7) -- xxx",
+        // "INSERT /*xxx*/INTO testbatch VALUES (?, '1, (, $1234, a''n?d )' /*xxxx)*/, ?) -- xxx",
+    };
+    for (String s : odd) {
+      PreparedStatement pstmt = null;
+      try {
+        pstmt = con.prepareStatement(s);
+        pstmt.addBatch();
+        pstmt.addBatch();
+        pstmt.addBatch();
+        BatchExecuteTest.assertSimpleInsertBatch(3, pstmt.executeBatch());
+        TestUtil.assertNumberOfRows(con, "testbatch", 3, "3 rows inserted");
       } finally {
         TestUtil.closeQuietly(pstmt);
       }
@@ -161,6 +190,10 @@ private void simpleRewriteBatch(String values, String suffix)
       throws SQLException {
     PreparedStatement pstmt = null;
     try {
+      PreparedStatement clean = con.prepareStatement("truncate table testbatch");
+      clean.execute();
+      clean.close();
+
       pstmt = con.prepareStatement("INSERT INTO testbatch " +  values + "(?,?,?)" + suffix);
       pstmt.setInt(1, 1);
       pstmt.setString(2, "a");
@@ -175,6 +208,7 @@ private void simpleRewriteBatch(String values, String suffix)
       pstmt.setInt(3, 6);
       pstmt.addBatch();
       BatchExecuteTest.assertSimpleInsertBatch(3, pstmt.executeBatch());
+      TestUtil.assertNumberOfRows(con, "testbatch", 3, "3 rows inserted");
     } finally {
       TestUtil.closeQuietly(pstmt);
     }
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/CallableStmtTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/CallableStmtTest.java
index 746e834f4a..06f920a913 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/CallableStmtTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/CallableStmtTest.java
@@ -8,13 +8,18 @@
 
 package org.postgresql.test.jdbc2;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import org.postgresql.test.TestUtil;
 
-import junit.framework.TestCase;
+import org.junit.Test;
 
 import java.sql.Array;
 import java.sql.CallableStatement;
-import java.sql.Connection;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.SQLWarning;
@@ -26,15 +31,11 @@
  *
  * @author Paul Bethe
  */
-public class CallableStmtTest extends TestCase {
-  private Connection con;
-
-  public CallableStmtTest(String name) {
-    super(name);
-  }
+public class CallableStmtTest extends BaseTest4 {
 
-  protected void setUp() throws Exception {
-    con = TestUtil.openDB();
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
     TestUtil.createTable(con, "int_table", "id int");
     Statement stmt = con.createStatement();
     stmt.execute("CREATE OR REPLACE FUNCTION testspg__getString (varchar) "
@@ -70,7 +71,8 @@ protected void setUp() throws Exception {
     stmt.close();
   }
 
-  protected void tearDown() throws Exception {
+  @Override
+  public void tearDown() throws SQLException {
     Statement stmt = con.createStatement();
     TestUtil.dropTable(con, "int_table");
     stmt.execute("drop FUNCTION testspg__getString (varchar);");
@@ -86,14 +88,16 @@ protected void tearDown() throws Exception {
     stmt.execute("DROP FUNCTION testspg__getarray();");
     stmt.execute("DROP FUNCTION testspg__raisenotice();");
     stmt.execute("DROP FUNCTION testspg__insertInt(int);");
-    TestUtil.closeDB(con);
+    super.tearDown();
   }
 
 
   final String func = "{ ? = call ";
   final String pkgName = "testspg__";
 
+  @Test
   public void testGetUpdateCount() throws SQLException {
+    assumeCallableStatementsSupported();
     CallableStatement call = con.prepareCall(func + pkgName + "getDouble (?) }");
     call.setDouble(2, 3.04);
     call.registerOutParameter(1, Types.DOUBLE);
@@ -120,7 +124,9 @@ public void testGetUpdateCount() throws SQLException {
     call.close();
   }
 
+  @Test
   public void testGetDouble() throws Throwable {
+    assumeCallableStatementsSupported();
     CallableStatement call = con.prepareCall(func + pkgName + "getDouble (?) }");
     call.setDouble(2, 3.04);
     call.registerOutParameter(1, Types.DOUBLE);
@@ -139,7 +145,9 @@ public void testGetDouble() throws Throwable {
     }
   }
 
+  @Test
   public void testGetInt() throws Throwable {
+    assumeCallableStatementsSupported();
     CallableStatement call = con.prepareCall(func + pkgName + "getInt (?) }");
     call.setInt(2, 4);
     call.registerOutParameter(1, Types.INTEGER);
@@ -147,7 +155,9 @@ public void testGetInt() throws Throwable {
     assertEquals(42, call.getInt(1));
   }
 
+  @Test
   public void testGetShort() throws Throwable {
+    assumeCallableStatementsSupported();
     if (TestUtil.isProtocolVersion(con, 3)) {
       CallableStatement call = con.prepareCall(func + pkgName + "getShort (?) }");
       call.setShort(2, (short) 4);
@@ -157,7 +167,9 @@ public void testGetShort() throws Throwable {
     }
   }
 
+  @Test
   public void testGetNumeric() throws Throwable {
+    assumeCallableStatementsSupported();
     CallableStatement call = con.prepareCall(func + pkgName + "getNumeric (?) }");
     call.setBigDecimal(2, new java.math.BigDecimal(4));
     call.registerOutParameter(1, Types.NUMERIC);
@@ -165,14 +177,18 @@ public void testGetNumeric() throws Throwable {
     assertEquals(new java.math.BigDecimal(42), call.getBigDecimal(1));
   }
 
+  @Test
   public void testGetNumericWithoutArg() throws Throwable {
+    assumeCallableStatementsSupported();
     CallableStatement call = con.prepareCall(func + pkgName + "getNumericWithoutArg () }");
     call.registerOutParameter(1, Types.NUMERIC);
     call.execute();
     assertEquals(new java.math.BigDecimal(42), call.getBigDecimal(1));
   }
 
+  @Test
   public void testGetString() throws Throwable {
+    assumeCallableStatementsSupported();
     CallableStatement call = con.prepareCall(func + pkgName + "getString (?) }");
     call.setString(2, "foo");
     call.registerOutParameter(1, Types.VARCHAR);
@@ -181,7 +197,9 @@ public void testGetString() throws Throwable {
 
   }
 
+  @Test
   public void testGetArray() throws SQLException {
+    assumeCallableStatementsSupported();
     CallableStatement call = con.prepareCall(func + pkgName + "getarray()}");
     call.registerOutParameter(1, Types.ARRAY);
     call.execute();
@@ -194,7 +212,9 @@ public void testGetArray() throws SQLException {
     assertTrue(!rs.next());
   }
 
+  @Test
   public void testRaiseNotice() throws SQLException {
+    assumeCallableStatementsSupported();
     Statement statement = con.createStatement();
     statement.execute("SET SESSION client_min_messages = 'NOTICE'");
     CallableStatement call = con.prepareCall(func + pkgName + "raisenotice()}");
@@ -209,6 +229,7 @@ public void testRaiseNotice() throws SQLException {
     assertEquals(1, call.getInt(1));
   }
 
+  @Test
   public void testWasNullBeforeFetch() throws SQLException {
     CallableStatement cs = con.prepareCall("{? = call lower(?)}");
     cs.registerOutParameter(1, Types.VARCHAR);
@@ -221,6 +242,7 @@ public void testWasNullBeforeFetch() throws SQLException {
     }
   }
 
+  @Test
   public void testFetchBeforeExecute() throws SQLException {
     CallableStatement cs = con.prepareCall("{? = call lower(?)}");
     cs.registerOutParameter(1, Types.VARCHAR);
@@ -233,6 +255,7 @@ public void testFetchBeforeExecute() throws SQLException {
     }
   }
 
+  @Test
   public void testFetchWithNoResults() throws SQLException {
     CallableStatement cs = con.prepareCall("{call now()}");
     cs.execute();
@@ -244,6 +267,7 @@ public void testFetchWithNoResults() throws SQLException {
     }
   }
 
+  @Test
   public void testBadStmt() throws Throwable {
     tryOneBadStmt("{ ?= " + pkgName + "getString (?) }");
     tryOneBadStmt("{ ?= call getString (?) ");
@@ -259,6 +283,7 @@ protected void tryOneBadStmt(String sql) throws SQLException {
     }
   }
 
+  @Test
   public void testBatchCall() throws SQLException {
     CallableStatement call = con.prepareCall("{ call " + pkgName + "insertInt(?) }");
     call.setInt(1, 1);
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/Jdbc2TestSuite.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/Jdbc2TestSuite.java
index 1dcc325e42..2712cc9965 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/Jdbc2TestSuite.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/Jdbc2TestSuite.java
@@ -8,12 +8,14 @@
 
 package org.postgresql.test.jdbc2;
 
-import org.postgresql.core.v2.V2ParameterListTests;
+import org.postgresql.core.ParserTest;
 import org.postgresql.core.v3.V3ParameterListTests;
 import org.postgresql.jdbc.DeepBatchedInsertStatementTest;
 import org.postgresql.test.CursorFetchBinaryTest;
 import org.postgresql.test.TestUtil;
 import org.postgresql.test.core.NativeQueryBindLengthTest;
+import org.postgresql.test.util.ServerVersionParseTest;
+import org.postgresql.test.util.ServerVersionTest;
 
 import junit.framework.JUnit4TestAdapter;
 import junit.framework.TestSuite;
@@ -49,35 +51,36 @@ public static TestSuite suite() throws Exception {
     suite.addTestSuite(EncodingTest.class);
     suite.addTestSuite(ColumnSanitiserDisabledTest.class);
     suite.addTestSuite(ColumnSanitiserEnabledTest.class);
-    suite.addTestSuite(VersionTest.class);
+    suite.addTest(new JUnit4TestAdapter(ServerVersionParseTest.class));
+    suite.addTest(new JUnit4TestAdapter(ServerVersionTest.class));
 
     // Connectivity/Protocols
 
     suite.addTest(new JUnit4TestAdapter(TypeCacheDLLStressTest.class));
 
     // ResultSet
-    suite.addTestSuite(ResultSetTest.class);
-    suite.addTestSuite(ResultSetMetaDataTest.class);
+    suite.addTest(new JUnit4TestAdapter(ResultSetTest.class));
+    suite.addTest(new JUnit4TestAdapter(ResultSetMetaDataTest.class));
     suite.addTest(new JUnit4TestAdapter(ArrayTest.class));
-    suite.addTestSuite(RefCursorTest.class);
+    suite.addTest(new JUnit4TestAdapter(RefCursorTest.class));
 
     // Time, Date, Timestamp, PGTime, PGTimestamp
     suite.addTestSuite(DateTest.class);
     suite.addTestSuite(TimeTest.class);
     suite.addTestSuite(TimestampTest.class);
     suite.addTestSuite(TimezoneTest.class);
-    suite.addTestSuite(PGTimeTest.class);
+    suite.addTest(new JUnit4TestAdapter(PGTimeTest.class));
     suite.addTestSuite(PGTimestampTest.class);
     suite.addTest(new JUnit4TestAdapter(TimezoneCachingTest.class));
+    suite.addTestSuite(ParserTest.class);
 
     // PreparedStatement
-    suite.addTestSuite(PreparedStatementTest.class);
-    suite.addTestSuite(PreparedStatementBinaryTest.class);
+    suite.addTest(new JUnit4TestAdapter(PreparedStatementTest.class));
     suite.addTestSuite(StatementTest.class);
     suite.addTest(new JUnit4TestAdapter(QuotationTest.class));
 
     // ServerSide Prepared Statements
-    suite.addTestSuite(ServerPreparedStmtTest.class);
+    suite.addTest(new JUnit4TestAdapter(ServerPreparedStmtTest.class));
 
     // BatchExecute
     suite.addTest(new JUnit4TestAdapter(BatchExecuteTest.class));
@@ -99,12 +102,12 @@ public static TestSuite suite() throws Exception {
     suite.addTestSuite(OID74Test.class);
     suite.addTestSuite(BlobTransactionTest.class);
 
-    suite.addTestSuite(UpdateableResultTest.class);
+    suite.addTest(new JUnit4TestAdapter(UpdateableResultTest.class));
 
-    suite.addTestSuite(CallableStmtTest.class);
+    suite.addTest(new JUnit4TestAdapter(CallableStmtTest.class));
     suite.addTestSuite(CursorFetchTest.class);
     suite.addTestSuite(CursorFetchBinaryTest.class);
-    suite.addTestSuite(ServerCursorTest.class);
+    suite.addTest(new JUnit4TestAdapter(ServerCursorTest.class));
 
     suite.addTestSuite(IntervalTest.class);
     suite.addTestSuite(GeometricTest.class);
@@ -116,7 +119,6 @@ public static TestSuite suite() throws Exception {
 
     suite.addTestSuite(PGPropertyTest.class);
 
-    suite.addTestSuite(V2ParameterListTests.class);
     suite.addTestSuite(V3ParameterListTests.class);
 
     Connection conn = TestUtil.openDB();
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PGTimeTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PGTimeTest.java
index 1f5e02fbf1..7d32136e1e 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PGTimeTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PGTimeTest.java
@@ -8,13 +8,16 @@
 
 package org.postgresql.test.jdbc2;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
 import org.postgresql.test.TestUtil;
 import org.postgresql.util.PGInterval;
 import org.postgresql.util.PGTime;
 
-import junit.framework.TestCase;
+import org.junit.Test;
 
-import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
@@ -28,29 +31,22 @@
  * Tests {@link PGTime} in various scenarios including setTime, setObject for both <code>time with
  * time zone</code> and <code>time without time zone</code> data types.
  */
-public class PGTimeTest extends TestCase {
+public class PGTimeTest extends BaseTest4 {
   /**
    * The name of the test table.
    */
   private static final String TEST_TABLE = "testtime";
 
-  /**
-   * The database connection.
-   */
-  private Connection con;
-
-  public PGTimeTest(String name) {
-    super(name);
-  }
-
-  protected void setUp() throws Exception {
-    con = TestUtil.openDB();
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
     TestUtil.createTempTable(con, TEST_TABLE, "tm time, tz time with time zone");
   }
 
-  protected void tearDown() throws Exception {
+  @Override
+  public void tearDown() throws SQLException {
     TestUtil.dropTable(con, TEST_TABLE);
-    TestUtil.closeDB(con);
+    super.tearDown();
   }
 
   /**
@@ -59,6 +55,7 @@ protected void tearDown() throws Exception {
    *
    * @throws SQLException if a JDBC or database problem occurs.
    */
+  @Test
   public void testTimeWithInterval() throws SQLException {
     Calendar cal = Calendar.getInstance();
     cal.set(1970, 0, 1);
@@ -136,6 +133,7 @@ private void verifyTimeWithInterval(PGTime time, PGInterval interval, boolean us
    *
    * @throws SQLException if a JDBC or database problem occurs.
    */
+  @Test
   public void testTimeInsertAndSelect() throws SQLException {
     Calendar cal = Calendar.getInstance();
     cal.set(1970, 0, 1);
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PreparedStatementBinaryTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PreparedStatementBinaryTest.java
deleted file mode 100644
index f018dfe5fe..0000000000
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PreparedStatementBinaryTest.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package org.postgresql.test.jdbc2;
-
-import java.util.Properties;
-
-public class PreparedStatementBinaryTest extends PreparedStatementTest {
-  public PreparedStatementBinaryTest(String name) {
-    super(name);
-  }
-
-  @Override
-  protected void updateProperties(Properties props) {
-    forceBinary(props);
-  }
-}
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PreparedStatementTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PreparedStatementTest.java
index 715c6a9677..d571bce71b 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PreparedStatementTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/PreparedStatementTest.java
@@ -8,9 +8,20 @@
 
 package org.postgresql.test.jdbc2;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import org.postgresql.jdbc.PreferQueryMode;
 import org.postgresql.test.TestUtil;
 import org.postgresql.test.util.BrokenInputStream;
 
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.InputStream;
@@ -23,29 +34,47 @@
 import java.sql.SQLException;
 import java.sql.Statement;
 import java.sql.Types;
+import java.util.ArrayList;
+import java.util.Collection;
 
 
-public class PreparedStatementTest extends BaseTest {
+@RunWith(Parameterized.class)
+public class PreparedStatementTest extends BaseTest4 {
 
-  public PreparedStatementTest(String name) {
-    super(name);
+  public PreparedStatementTest(BinaryMode binaryMode) {
+    setBinaryMode(binaryMode);
+  }
+
+  @Parameterized.Parameters(name = "binary = {0}")
+  public static Iterable<Object[]> data() {
+    Collection<Object[]> ids = new ArrayList<Object[]>();
+    for (BinaryMode binaryMode : BinaryMode.values()) {
+      ids.add(new Object[]{binaryMode});
+    }
+    return ids;
   }
 
-  protected void setUp() throws Exception {
+  @Override
+  public void setUp() throws Exception {
     super.setUp();
     TestUtil.createTable(con, "streamtable", "bin bytea, str text");
     TestUtil.createTable(con, "texttable", "ch char(3), te text, vc varchar(3)");
     TestUtil.createTable(con, "intervaltable", "i interval");
+    TestUtil.createTable(con, "inttable", "a int");
   }
 
-  protected void tearDown() throws SQLException {
+  @Override
+  public void tearDown() throws SQLException {
     TestUtil.dropTable(con, "streamtable");
     TestUtil.dropTable(con, "texttable");
     TestUtil.dropTable(con, "intervaltable");
+    TestUtil.dropTable(con, "inttable");
     super.tearDown();
   }
 
+  @Test
   public void testSetBinaryStream() throws SQLException {
+    assumeByteaSupported();
     ByteArrayInputStream bais;
     byte buf[] = new byte[10];
     for (int i = 0; i < buf.length; i++) {
@@ -65,6 +94,7 @@ public void testSetBinaryStream() throws SQLException {
     doSetBinaryStream(bais, 10);
   }
 
+  @Test
   public void testSetAsciiStream() throws Exception {
     ByteArrayOutputStream baos = new ByteArrayOutputStream();
     PrintWriter pw = new PrintWriter(new OutputStreamWriter(baos, "ASCII"));
@@ -83,6 +113,7 @@ public void testSetAsciiStream() throws Exception {
     doSetAsciiStream(bais, 100);
   }
 
+  @Test
   public void testExecuteStringOnPreparedStatement() throws Exception {
     PreparedStatement pstmt = con.prepareStatement("SELECT 1");
 
@@ -105,6 +136,7 @@ public void testExecuteStringOnPreparedStatement() throws Exception {
     }
   }
 
+  @Test
   public void testBinaryStreamErrorsRestartable() throws SQLException {
     // The V2 protocol does not have the ability to recover when
     // streaming data to the server. We could potentially try
@@ -177,6 +209,7 @@ private void doSetAsciiStream(InputStream is, int length) throws SQLException {
     pstmt.close();
   }
 
+  @Test
   public void testTrailingSpaces() throws SQLException {
     PreparedStatement pstmt =
         con.prepareStatement("INSERT INTO texttable (ch, te, vc) VALUES (?, ?, ?) ");
@@ -200,6 +233,7 @@ public void testTrailingSpaces() throws SQLException {
     pstmt.close();
   }
 
+  @Test
   public void testSetNull() throws SQLException {
     // valid: fully qualified type to setNull()
     PreparedStatement pstmt = con.prepareStatement("INSERT INTO texttable (te) VALUES (?)");
@@ -232,6 +266,7 @@ public void testSetNull() throws SQLException {
     pstmt.close();
   }
 
+  @Test
   public void testSingleQuotes() throws SQLException {
     String[] testStrings = new String[]{
         "bare ? question mark",
@@ -313,6 +348,7 @@ public void testSingleQuotes() throws SQLException {
     }
   }
 
+  @Test
   public void testDoubleQuotes() throws SQLException {
     String[] testStrings = new String[]{
         "bare ? question mark",
@@ -334,6 +370,7 @@ public void testDoubleQuotes() throws SQLException {
     }
   }
 
+  @Test
   public void testDollarQuotes() throws SQLException {
     // dollar-quotes are supported in the backend since version 8.0
     if (!TestUtil.haveMinimumServerVersion(con, "8.0")) {
@@ -379,6 +416,7 @@ public void testDollarQuotes() throws SQLException {
     st.close();
   }
 
+  @Test
   public void testDollarQuotesAndIdentifiers() throws SQLException {
     // dollar-quotes are supported in the backend since version 8.0
     if (!TestUtil.haveMinimumServerVersion(con, "8.0")) {
@@ -401,6 +439,7 @@ public void testDollarQuotesAndIdentifiers() throws SQLException {
     st.close();
   }
 
+  @Test
   public void testComments() throws SQLException {
     PreparedStatement st;
     ResultSet rs;
@@ -421,6 +460,7 @@ public void testComments() throws SQLException {
     st.close();
   }
 
+  @Test
   public void testDoubleQuestionMark() throws SQLException {
     PreparedStatement st;
     ResultSet rs;
@@ -440,6 +480,7 @@ public void testDoubleQuestionMark() throws SQLException {
     st.close();
   }
 
+  @Test
   public void testDouble() throws SQLException {
     PreparedStatement pstmt = con.prepareStatement(
         "CREATE TEMP TABLE double_tab (max_double float, min_double float, null_value float)");
@@ -466,6 +507,7 @@ public void testDouble() throws SQLException {
 
   }
 
+  @Test
   public void testFloat() throws SQLException {
     PreparedStatement pstmt = con.prepareStatement(
         "CREATE TEMP TABLE float_tab (max_float real, min_float real, null_value real)");
@@ -492,6 +534,7 @@ public void testFloat() throws SQLException {
 
   }
 
+  @Test
   public void testBoolean() throws SQLException {
     PreparedStatement pstmt = con.prepareStatement(
         "CREATE TEMP TABLE bool_tab (max_val boolean, min_val boolean, null_val boolean)");
@@ -518,6 +561,7 @@ public void testBoolean() throws SQLException {
 
   }
 
+  @Test
   public void testSetFloatInteger() throws SQLException {
     PreparedStatement pstmt = con.prepareStatement(
         "CREATE temp TABLE float_tab (max_val float8, min_val float, null_val float8)");
@@ -552,6 +596,7 @@ public void testSetFloatInteger() throws SQLException {
 
   }
 
+  @Test
   public void testSetFloatString() throws SQLException {
     PreparedStatement pstmt = con.prepareStatement(
         "CREATE temp TABLE float_tab (max_val float8, min_val float8, null_val float8)");
@@ -585,6 +630,7 @@ public void testSetFloatString() throws SQLException {
 
   }
 
+  @Test
   public void testSetFloatBigDecimal() throws SQLException {
     PreparedStatement pstmt = con.prepareStatement(
         "CREATE temp TABLE float_tab (max_val float8, min_val float8, null_val float8)");
@@ -618,6 +664,7 @@ public void testSetFloatBigDecimal() throws SQLException {
 
   }
 
+  @Test
   public void testSetTinyIntFloat() throws SQLException {
     PreparedStatement pstmt = con
         .prepareStatement("CREATE temp TABLE tiny_int (max_val int4, min_val int4, null_val int4)");
@@ -673,6 +720,7 @@ public void testSetTinyIntFloat() throws SQLException {
 
   }
 
+  @Test
   public void testSetSmallIntFloat() throws SQLException {
     PreparedStatement pstmt = con.prepareStatement(
         "CREATE temp TABLE small_int (max_val int4, min_val int4, null_val int4)");
@@ -705,6 +753,7 @@ public void testSetSmallIntFloat() throws SQLException {
     pstmt.close();
   }
 
+  @Test
   public void testSetIntFloat() throws SQLException {
     PreparedStatement pstmt = con
         .prepareStatement("CREATE temp TABLE int_TAB (max_val int4, min_val int4, null_val int4)");
@@ -738,6 +787,7 @@ public void testSetIntFloat() throws SQLException {
 
   }
 
+  @Test
   public void testSetBooleanDouble() throws SQLException {
     PreparedStatement pstmt = con.prepareStatement(
         "CREATE temp TABLE double_tab (max_val float, min_val float, null_val float)");
@@ -769,6 +819,7 @@ public void testSetBooleanDouble() throws SQLException {
 
   }
 
+  @Test
   public void testSetBooleanNumeric() throws SQLException {
     PreparedStatement pstmt = con.prepareStatement(
         "CREATE temp TABLE numeric_tab (max_val numeric(30,15), min_val numeric(30,15), null_val numeric(30,15))");
@@ -800,6 +851,7 @@ public void testSetBooleanNumeric() throws SQLException {
 
   }
 
+  @Test
   public void testSetBooleanDecimal() throws SQLException {
     PreparedStatement pstmt = con.prepareStatement(
         "CREATE temp TABLE DECIMAL_TAB (max_val numeric(30,15), min_val numeric(30,15), null_val numeric(30,15))");
@@ -831,6 +883,7 @@ public void testSetBooleanDecimal() throws SQLException {
 
   }
 
+  @Test
   public void testSetObjectBigDecimalUnscaled() throws SQLException {
     TestUtil.createTempTable(con, "decimal_scale",
         "n1 numeric, n2 numeric, n3 numeric, n4 numeric");
@@ -867,6 +920,7 @@ public void testSetObjectBigDecimalUnscaled() throws SQLException {
     pstmt.close();
   }
 
+  @Test
   public void testSetObjectBigDecimalWithScale() throws SQLException {
     TestUtil.createTempTable(con, "decimal_scale",
         "n1 numeric, n2 numeric, n3 numeric, n4 numeric");
@@ -911,6 +965,7 @@ public void testSetObjectBigDecimalWithScale() throws SQLException {
     pstruncate.close();
   }
 
+  @Test
   public void testUnknownSetObject() throws SQLException {
     PreparedStatement pstmt = con.prepareStatement("INSERT INTO intervaltable(i) VALUES (?)");
 
@@ -918,8 +973,10 @@ public void testUnknownSetObject() throws SQLException {
       pstmt.setString(1, "1 week");
       try {
         pstmt.executeUpdate();
-        fail("Should have failed with type mismatch.");
+        assertTrue("When using extended protocol, interval vs character varying type mismatch error is expected",
+            preferQueryMode == PreferQueryMode.SIMPLE);
       } catch (SQLException sqle) {
+        // ERROR: column "i" is of type interval but expression is of type character varying
       }
     }
 
@@ -931,6 +988,7 @@ public void testUnknownSetObject() throws SQLException {
   /**
    * With autoboxing this apparently happens more often now.
    */
+  @Test
   public void testSetObjectCharacter() throws SQLException {
     PreparedStatement ps = con.prepareStatement("INSERT INTO texttable(te) VALUES (?)");
     ps.setObject(1, new Character('z'));
@@ -943,6 +1001,7 @@ public void testSetObjectCharacter() throws SQLException {
    * protocol level statment describe message for the V3 protocol. This test just makes sure that
    * works.
    */
+  @Test
   public void testStatementDescribe() throws SQLException {
     PreparedStatement pstmt = con.prepareStatement("SELECT ?::int");
     pstmt.setObject(1, new Integer(2), Types.OTHER);
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/QuotationTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/QuotationTest.java
index 5ae2575a5e..9b18161eb0 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/QuotationTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/QuotationTest.java
@@ -40,6 +40,13 @@ public QuotationTest(QuoteStyle quoteStyle, String expected, String expr) {
 
   @Parameterized.Parameters(name = "{index}: quotes(style={0}, src={1}, quoted={2})")
   public static Iterable<Object[]> data() {
+    Collection<String> prefix = new ArrayList<String>();
+    // Too many prefixes make test run long
+    prefix.add("");
+    prefix.add("/*\n$\n*//* ? *//*{fn *//* now} */");
+    prefix.add("-- $\n");
+    prefix.add("--\n/* $ */");
+
     Collection<Object[]> ids = new ArrayList<Object[]>();
     Collection<String> garbageValues = new ArrayList<String>();
     garbageValues.add("{fn now}");
@@ -79,7 +86,9 @@ public static Iterable<Object[]> data() {
             continue;
           }
           String expected = unquoted;
-          ids.add(new Object[]{quoteStyle, expected, quoted});
+          for (String p : prefix) {
+            ids.add(new Object[]{quoteStyle, expected, p + quoted});
+          }
           if (unquoted.length() == 1) {
             char ch = unquoted.charAt(0);
             if (ch >= 'a' && ch <= 'z') {
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/RefCursorTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/RefCursorTest.java
index a38a105152..94e21cd2eb 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/RefCursorTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/RefCursorTest.java
@@ -8,33 +8,55 @@
 
 package org.postgresql.test.jdbc2;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
 import org.postgresql.test.TestUtil;
 
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
 
 import java.sql.CallableStatement;
-import java.sql.Connection;
 import java.sql.ResultSet;
 import java.sql.ResultSetMetaData;
 import java.sql.SQLException;
 import java.sql.Statement;
 import java.sql.Types;
+import java.util.Arrays;
 
-/*
+/**
  * RefCursor ResultSet tests. This test case is basically the same as the ResultSet test case.
  *
- * @author Nic Ferrier <nferrier@tapsellferrier.co.uk>
+ * <p>For backwards compatibility reasons we verify that ref cursors can be
+ * registered with both {@link Types#OTHER} and {@link Types#REF_CURSOR}.</p>
+ *
+ * @author Nic Ferrier (nferrier@tapsellferrier.co.uk)
  */
-public class RefCursorTest extends TestCase {
-  private Connection con;
+@RunWith(Parameterized.class)
+public class RefCursorTest extends BaseTest4 {
+
+  final int cursorType;
+
+  public RefCursorTest(String typeName, int cursorType) {
+    this.cursorType = cursorType;
+  }
 
-  public RefCursorTest(String name) {
-    super(name);
+  @Parameterized.Parameters(name = "typeName = {0}, cursorType = {1}")
+  public static Iterable<Object[]> data() {
+    return Arrays.asList(new Object[][]{
+        {"OTHER", Types.OTHER},
+        //#if mvn.project.property.postgresql.jdbc.spec >= "JDBC4.2"
+        {"REF_CURSOR", Types.REF_CURSOR},
+        //#endif
+    });
   }
 
-  protected void setUp() throws Exception {
+  @Override
+  public void setUp() throws Exception {
     // this is the same as the ResultSet setup.
-    con = TestUtil.openDB();
+    super.setUp();
     Statement stmt = con.createStatement();
 
     TestUtil.createTable(con, "testrs", "id integer primary key");
@@ -58,18 +80,21 @@ protected void setUp() throws Exception {
     con.setAutoCommit(false);
   }
 
-  protected void tearDown() throws Exception {
+  @Override
+  public void tearDown() throws SQLException {
     con.setAutoCommit(true);
     Statement stmt = con.createStatement();
     stmt.execute("drop FUNCTION testspg__getRefcursor ();");
     stmt.execute("drop FUNCTION testspg__getEmptyRefcursor ();");
     TestUtil.dropTable(con, "testrs");
-    TestUtil.closeDB(con);
+    super.tearDown();
   }
 
+  @Test
   public void testResult() throws SQLException {
+    assumeCallableStatementsSupported();
     CallableStatement call = con.prepareCall("{ ? = call testspg__getRefcursor () }");
-    call.registerOutParameter(1, Types.OTHER);
+    call.registerOutParameter(1, cursorType);
     call.execute();
     ResultSet rs = (ResultSet) call.getObject(1);
 
@@ -92,29 +117,32 @@ public void testResult() throws SQLException {
     assertTrue(rs.getInt(1) == 9);
 
     assertTrue(!rs.next());
+    rs.close();
 
     call.close();
   }
 
 
+  @Test
   public void testEmptyResult() throws SQLException {
+    assumeCallableStatementsSupported();
     CallableStatement call = con.prepareCall("{ ? = call testspg__getEmptyRefcursor () }");
-    call.registerOutParameter(1, Types.OTHER);
+    call.registerOutParameter(1, cursorType);
     call.execute();
 
     ResultSet rs = (ResultSet) call.getObject(1);
     assertTrue(!rs.next());
+    rs.close();
 
     call.close();
   }
 
+  @Test
   public void testMetaData() throws SQLException {
-    if (!TestUtil.haveMinimumServerVersion(con, "7.4")) {
-      return;
-    }
+    assumeCallableStatementsSupported();
 
     CallableStatement call = con.prepareCall("{ ? = call testspg__getRefcursor () }");
-    call.registerOutParameter(1, Types.OTHER);
+    call.registerOutParameter(1, cursorType);
     call.execute();
 
     ResultSet rs = (ResultSet) call.getObject(1);
@@ -128,10 +156,12 @@ public void testMetaData() throws SQLException {
     call.close();
   }
 
+  @Test
   public void testResultType() throws SQLException {
+    assumeCallableStatementsSupported();
     CallableStatement call = con.prepareCall("{ ? = call testspg__getRefcursor () }",
         ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
-    call.registerOutParameter(1, Types.OTHER);
+    call.registerOutParameter(1, cursorType);
     call.execute();
     ResultSet rs = (ResultSet) call.getObject(1);
 
@@ -140,6 +170,8 @@ public void testResultType() throws SQLException {
 
     assertTrue(rs.last());
     assertEquals(6, rs.getRow());
+    rs.close();
+    call.close();
   }
 
 }
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ResultSetMetaDataTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ResultSetMetaDataTest.java
index 5f8a489d93..b620969869 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ResultSetMetaDataTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ResultSetMetaDataTest.java
@@ -8,10 +8,16 @@
 
 package org.postgresql.test.jdbc2;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
 import org.postgresql.PGResultSetMetaData;
+import org.postgresql.jdbc.PreferQueryMode;
 import org.postgresql.test.TestUtil;
 
-import junit.framework.TestCase;
+import org.junit.Assume;
+import org.junit.Test;
 
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
@@ -22,16 +28,13 @@
 import java.sql.Statement;
 import java.sql.Types;
 
-public class ResultSetMetaDataTest extends TestCase {
-
-  private Connection conn;
-
-  public ResultSetMetaDataTest(String name) {
-    super(name);
-  }
+public class ResultSetMetaDataTest extends BaseTest4 {
+  Connection conn;
 
-  protected void setUp() throws Exception {
-    conn = TestUtil.openDB();
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    conn = con;
     TestUtil.createTable(conn, "rsmd1", "a int primary key, b text, c decimal(10,2)", true);
     TestUtil.createTable(conn, "timetest",
         "tm time(3), tmtz timetz, ts timestamp without time zone, tstz timestamp(6) with time zone");
@@ -46,7 +49,8 @@ protected void setUp() throws Exception {
     TestUtil.createTable(conn, "compositetest", "col rsmd1");
   }
 
-  protected void tearDown() throws Exception {
+  @Override
+  public void tearDown() throws SQLException {
     TestUtil.dropTable(conn, "compositetest");
     TestUtil.dropTable(conn, "rsmd1");
     TestUtil.dropTable(conn, "timetest");
@@ -55,9 +59,10 @@ protected void tearDown() throws Exception {
     TestUtil.dropTable(conn, "sizetest");
     TestUtil.dropSequence(conn, "serialtest_a_seq");
     TestUtil.dropSequence(conn, "serialtest_b_seq");
-    TestUtil.closeDB(conn);
+    super.tearDown();
   }
 
+  @Test
   public void testStandardResultSet() throws SQLException {
     Statement stmt = conn.createStatement();
     ResultSet rs = stmt.executeQuery("SELECT a,b,c,a+c as total,oid,b as d FROM rsmd1");
@@ -66,10 +71,9 @@ public void testStandardResultSet() throws SQLException {
     stmt.close();
   }
 
+  @Test
   public void testPreparedResultSet() throws SQLException {
-    if (!TestUtil.isProtocolVersion(conn, 3)) {
-      return;
-    }
+    assumePreparedStatementMetadataSupported();
 
     PreparedStatement pstmt =
         conn.prepareStatement("SELECT a,b,c,a+c as total,oid,b as d FROM rsmd1 WHERE b = ?");
@@ -126,7 +130,9 @@ private void runStandardTests(ResultSetMetaData rsmd) throws SQLException {
   }
 
   // verify that a prepared update statement returns no metadata and doesn't execute.
+  @Test
   public void testPreparedUpdate() throws SQLException {
+    assumePreparedStatementMetadataSupported();
     PreparedStatement pstmt = conn.prepareStatement("INSERT INTO rsmd1(a,b) VALUES(?,?)");
     pstmt.setInt(1, 1);
     pstmt.setString(2, "hello");
@@ -143,6 +149,7 @@ public void testPreparedUpdate() throws SQLException {
   }
 
 
+  @Test
   public void testDatabaseMetaDataNames() throws SQLException {
     DatabaseMetaData databaseMetaData = conn.getMetaData();
     ResultSet resultSet = databaseMetaData.getTableTypes();
@@ -152,13 +159,14 @@ public void testDatabaseMetaDataNames() throws SQLException {
     resultSet.close();
   }
 
+  @Test
   public void testTimestampInfo() throws SQLException {
     Statement stmt = conn.createStatement();
     ResultSet rs = stmt.executeQuery("SELECT tm, tmtz, ts, tstz FROM timetest");
     ResultSetMetaData rsmd = rs.getMetaData();
 
     // For reference:
-    // TestUtil.createTable(conn, "timetest", "tm time(3), tmtz timetz, ts timestamp without time
+    // TestUtil.createTable(con, "timetest", "tm time(3), tmtz timetz, ts timestamp without time
     // zone, tstz timestamp(6) with time zone");
 
     assertEquals(3, rsmd.getScale(1));
@@ -175,6 +183,7 @@ public void testTimestampInfo() throws SQLException {
     stmt.close();
   }
 
+  @Test
   public void testColumnDisplaySize() throws SQLException {
     Statement stmt = conn.createStatement();
     ResultSet rs = stmt.executeQuery(
@@ -192,6 +201,7 @@ public void testColumnDisplaySize() throws SQLException {
     assertEquals(Integer.MAX_VALUE, rsmd.getColumnDisplaySize(9));
   }
 
+  @Test
   public void testIsAutoIncrement() throws SQLException {
     Statement stmt = conn.createStatement();
     ResultSet rs = stmt.executeQuery("SELECT c,b,a FROM serialtest");
@@ -209,6 +219,7 @@ public void testIsAutoIncrement() throws SQLException {
     stmt.close();
   }
 
+  @Test
   public void testClassesMatch() throws SQLException {
     Statement stmt = conn.createStatement();
     stmt.executeUpdate(
@@ -221,6 +232,7 @@ public void testClassesMatch() throws SQLException {
     }
   }
 
+  @Test
   public void testComposite() throws Exception {
     Statement stmt = conn.createStatement();
     ResultSet rs = stmt.executeQuery("SELECT col FROM compositetest");
@@ -229,7 +241,9 @@ public void testComposite() throws Exception {
     assertEquals("rsmd1", rsmd.getColumnTypeName(1));
   }
 
+  @Test
   public void testUnexecutedStatement() throws Exception {
+    assumePreparedStatementMetadataSupported();
     PreparedStatement pstmt = conn.prepareStatement("SELECT col FROM compositetest");
     // we have not executed the statement but we can still get the metadata
     ResultSetMetaData rsmd = pstmt.getMetaData();
@@ -237,7 +251,9 @@ public void testUnexecutedStatement() throws Exception {
     assertEquals("rsmd1", rsmd.getColumnTypeName(1));
   }
 
+  @Test
   public void testClosedResultSet() throws Exception {
+    assumePreparedStatementMetadataSupported();
     PreparedStatement pstmt = conn.prepareStatement("SELECT col FROM compositetest");
     ResultSet rs = pstmt.executeQuery();
     rs.close();
@@ -247,4 +263,9 @@ public void testClosedResultSet() throws Exception {
     assertEquals("rsmd1", rsmd.getColumnTypeName(1));
   }
 
+  private void assumePreparedStatementMetadataSupported() {
+    Assume.assumeTrue("prepared statement metadata is not supported for simple protocol",
+        preferQueryMode.compareTo(PreferQueryMode.EXTENDED_FOR_PREPARED) >= 0);
+  }
+
 }
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ResultSetTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ResultSetTest.java
index 1bf861cd70..af5dd28460 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ResultSetTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ResultSetTest.java
@@ -8,29 +8,34 @@
 
 package org.postgresql.test.jdbc2;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import org.postgresql.jdbc.PreferQueryMode;
 import org.postgresql.test.TestUtil;
 import org.postgresql.util.PGobject;
 
-import junit.framework.TestCase;
+import org.junit.Assume;
+import org.junit.Test;
 
-import java.sql.Connection;
+import java.lang.reflect.Field;
+import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Statement;
 import java.util.Locale;
+import java.util.Map;
 
 /*
  * ResultSet tests.
  */
-public class ResultSetTest extends TestCase {
-  private Connection con;
-
-  public ResultSetTest(String name) {
-    super(name);
-  }
-
-  protected void setUp() throws Exception {
-    con = TestUtil.openDB();
+public class ResultSetTest extends BaseTest4 {
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
     Statement stmt = con.createStatement();
 
     TestUtil.createTable(con, "testrs", "id integer");
@@ -96,11 +101,10 @@ protected void setUp() throws Exception {
     stmt.execute("INSERT INTO testpgobject VALUES(1, '2010-11-3')");
 
     stmt.close();
-
-
   }
 
-  protected void tearDown() throws SQLException {
+  @Override
+  public void tearDown() throws SQLException {
     TestUtil.dropTable(con, "testrs");
     TestUtil.dropTable(con, "teststring");
     TestUtil.dropTable(con, "testint");
@@ -109,9 +113,10 @@ protected void tearDown() throws SQLException {
     TestUtil.dropTable(con, "testboolstring");
     TestUtil.dropTable(con, "testnumeric");
     TestUtil.dropTable(con, "testpgobject");
-    TestUtil.closeDB(con);
+    super.tearDown();
   }
 
+  @Test
   public void testBackward() throws SQLException {
     Statement stmt =
         con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
@@ -122,6 +127,7 @@ public void testBackward() throws SQLException {
     stmt.close();
   }
 
+  @Test
   public void testAbsolute() throws SQLException {
     Statement stmt =
         con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
@@ -149,6 +155,7 @@ public void testAbsolute() throws SQLException {
     stmt.close();
   }
 
+  @Test
   public void testEmptyResult() throws SQLException {
     Statement stmt =
         con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
@@ -160,6 +167,7 @@ public void testEmptyResult() throws SQLException {
     assertTrue(!rs.next());
   }
 
+  @Test
   public void testMaxFieldSize() throws SQLException {
     Statement stmt = con.createStatement();
     stmt.setMaxFieldSize(2);
@@ -234,11 +242,13 @@ public void booleanTests(boolean useServerPrepare) throws SQLException {
     }
   }
 
+  @Test
   public void testBoolean() throws SQLException {
     booleanTests(true);
     booleanTests(false);
   }
 
+  @Test
   public void testgetByte() throws SQLException {
     ResultSet rs = con.createStatement().executeQuery("select * from testnumeric");
 
@@ -267,6 +277,7 @@ public void testgetByte() throws SQLException {
     rs.close();
   }
 
+  @Test
   public void testgetShort() throws SQLException {
     ResultSet rs = con.createStatement().executeQuery("select * from testnumeric");
 
@@ -295,6 +306,7 @@ public void testgetShort() throws SQLException {
     rs.close();
   }
 
+  @Test
   public void testgetInt() throws SQLException {
     ResultSet rs = con.createStatement().executeQuery("select * from testnumeric");
 
@@ -341,6 +353,7 @@ public void testgetInt() throws SQLException {
     rs.close();
   }
 
+  @Test
   public void testgetLong() throws SQLException {
     ResultSet rs = con.createStatement().executeQuery("select * from testnumeric");
 
@@ -399,6 +412,7 @@ public void testgetLong() throws SQLException {
     rs.close();
   }
 
+  @Test
   public void testParameters() throws SQLException {
     Statement stmt =
         con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
@@ -421,6 +435,7 @@ public void testParameters() throws SQLException {
     stmt.close();
   }
 
+  @Test
   public void testZeroRowResultPositioning() throws SQLException {
     Statement stmt =
         con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
@@ -447,6 +462,7 @@ public void testZeroRowResultPositioning() throws SQLException {
     stmt.close();
   }
 
+  @Test
   public void testRowResultPositioning() throws SQLException {
     Statement stmt =
         con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
@@ -504,6 +520,7 @@ public void testRowResultPositioning() throws SQLException {
     stmt.close();
   }
 
+  @Test
   public void testForwardOnlyExceptions() throws SQLException {
     // Test that illegal operations on a TYPE_FORWARD_ONLY resultset
     // correctly result in throwing an exception.
@@ -565,6 +582,7 @@ public void testForwardOnlyExceptions() throws SQLException {
     stmt.close();
   }
 
+  @Test
   public void testCaseInsensitiveFindColumn() throws SQLException {
     Statement stmt = con.createStatement();
     ResultSet rs = stmt.executeQuery("SELECT id, id AS \"ID2\" FROM testrs");
@@ -581,6 +599,7 @@ public void testCaseInsensitiveFindColumn() throws SQLException {
     }
   }
 
+  @Test
   public void testGetOutOfBounds() throws SQLException {
     Statement stmt = con.createStatement();
     ResultSet rs = stmt.executeQuery("SELECT id FROM testrs");
@@ -597,6 +616,7 @@ public void testGetOutOfBounds() throws SQLException {
     }
   }
 
+  @Test
   public void testClosedResult() throws SQLException {
     Statement stmt =
         con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
@@ -669,6 +689,7 @@ public void testClosedResult() throws SQLException {
   /*
    * The JDBC spec says when you have duplicate column names, the first one should be returned.
    */
+  @Test
   public void testDuplicateColumnNameOrder() throws SQLException {
     Statement stmt = con.createStatement();
     ResultSet rs = stmt.executeQuery("SELECT 1 AS a, 2 AS a");
@@ -676,6 +697,7 @@ public void testDuplicateColumnNameOrder() throws SQLException {
     assertEquals(1, rs.getInt("a"));
   }
 
+  @Test
   public void testTurkishLocale() throws SQLException {
     Locale current = Locale.getDefault();
     try {
@@ -693,6 +715,7 @@ public void testTurkishLocale() throws SQLException {
     }
   }
 
+  @Test
   public void testUpdateWithPGobject() throws SQLException {
     Statement stmt =
         con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
@@ -716,4 +739,106 @@ public void testUpdateWithPGobject() throws SQLException {
     stmt.close();
   }
 
+  /**
+   * Test the behavior of the result set column mapping cache for simple statements.
+   */
+  @Test
+  public void testStatementResultSetColumnMappingCache() throws SQLException {
+    Statement stmt = con.createStatement();
+    ResultSet rs = stmt.executeQuery("select * from testrs");
+    Map<String, Integer> columnNameIndexMap;
+    columnNameIndexMap = getResultSetColumnNameIndexMap(rs);
+    assertEquals(null, columnNameIndexMap);
+    assertTrue(rs.next());
+    columnNameIndexMap = getResultSetColumnNameIndexMap(rs);
+    assertEquals(null, columnNameIndexMap);
+    rs.getInt("ID");
+    columnNameIndexMap = getResultSetColumnNameIndexMap(rs);
+    assertNotNull(columnNameIndexMap);
+    rs.getInt("id");
+    assertSame(columnNameIndexMap, getResultSetColumnNameIndexMap(rs));
+    rs.close();
+    rs = stmt.executeQuery("select * from testrs");
+    columnNameIndexMap = getResultSetColumnNameIndexMap(rs);
+    assertEquals(null, columnNameIndexMap);
+    assertTrue(rs.next());
+    rs.getInt("Id");
+    columnNameIndexMap = getResultSetColumnNameIndexMap(rs);
+    assertNotNull(columnNameIndexMap);
+    rs.close();
+    stmt.close();
+  }
+
+  /**
+   * Test the behavior of the result set column mapping cache for prepared statements.
+   */
+  @Test
+  public void testPreparedStatementResultSetColumnMappingCache() throws SQLException {
+    PreparedStatement pstmt = con.prepareStatement("SELECT id FROM testrs");
+    ResultSet rs = pstmt.executeQuery();
+    Map<String, Integer> columnNameIndexMap;
+    columnNameIndexMap = getResultSetColumnNameIndexMap(rs);
+    assertEquals(null, columnNameIndexMap);
+    assertTrue(rs.next());
+    columnNameIndexMap = getResultSetColumnNameIndexMap(rs);
+    assertEquals(null, columnNameIndexMap);
+    rs.getInt("id");
+    columnNameIndexMap = getResultSetColumnNameIndexMap(rs);
+    assertNotNull(columnNameIndexMap);
+    rs.close();
+    rs = pstmt.executeQuery();
+    assertTrue(rs.next());
+    columnNameIndexMap = getResultSetColumnNameIndexMap(rs);
+    assertEquals(null, columnNameIndexMap);
+    rs.getInt("id");
+    columnNameIndexMap = getResultSetColumnNameIndexMap(rs);
+    assertNotNull(columnNameIndexMap);
+    rs.close();
+    pstmt.close();
+  }
+
+  /**
+   * Test the behavior of the result set column mapping cache for prepared statements once the
+   * statement is named.
+   */
+  @Test
+  public void testNamedPreparedStatementResultSetColumnMappingCache() throws SQLException {
+    Assume.assumeTrue("Simple protocol only mode does not support server-prepared statements",
+        preferQueryMode != PreferQueryMode.SIMPLE);
+    PreparedStatement pstmt = con.prepareStatement("SELECT id FROM testrs");
+    ResultSet rs;
+    // Make sure the prepared statement is named.
+    // This ensures column mapping cache is reused across different result sets.
+    for (int i = 0; i < 5; i++) {
+      rs = pstmt.executeQuery();
+      rs.close();
+    }
+    rs = pstmt.executeQuery();
+    assertTrue(rs.next());
+    rs.getInt("id");
+    Map<String, Integer> columnNameIndexMap;
+    columnNameIndexMap = getResultSetColumnNameIndexMap(rs);
+    assertNotNull(columnNameIndexMap);
+    rs.close();
+    rs = pstmt.executeQuery();
+    assertTrue(rs.next());
+    rs.getInt("id");
+    assertSame(
+        "Cached mapping should be same between different result sets of same named prepared statement",
+        columnNameIndexMap, getResultSetColumnNameIndexMap(rs));
+    rs.close();
+    pstmt.close();
+  }
+
+  @SuppressWarnings("unchecked")
+  private Map<String, Integer> getResultSetColumnNameIndexMap(ResultSet stmt) {
+    try {
+      Field columnNameIndexMapField = stmt.getClass().getDeclaredField("columnNameIndexMap");
+      columnNameIndexMapField.setAccessible(true);
+      return (Map<String, Integer>) columnNameIndexMapField.get(stmt);
+    } catch (Exception e) {
+    }
+    return null;
+  }
+
 }
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ServerCursorTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ServerCursorTest.java
index f1daca36e0..b5cf552fb0 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ServerCursorTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ServerCursorTest.java
@@ -8,35 +8,34 @@
 
 package org.postgresql.test.jdbc2;
 
+import static org.junit.Assert.assertEquals;
+
 import org.postgresql.test.TestUtil;
 
-import junit.framework.TestCase;
+import org.junit.Test;
 
-import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
+import java.sql.SQLException;
 
 /*
  * Tests for using non-zero setFetchSize().
  */
-public class ServerCursorTest extends TestCase {
-  private Connection con;
-
-  public ServerCursorTest(String name) {
-    super(name);
-  }
+public class ServerCursorTest extends BaseTest4 {
 
-  protected void setUp() throws Exception {
-    con = TestUtil.openDB();
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
     TestUtil.createTable(con, "test_fetch", "value integer,data bytea");
     con.setAutoCommit(false);
   }
 
-  protected void tearDown() throws Exception {
+  @Override
+  public void tearDown() throws SQLException {
     con.rollback();
     con.setAutoCommit(true);
     TestUtil.dropTable(con, "test_fetch");
-    TestUtil.closeDB(con);
+    super.tearDown();
   }
 
   protected void createRows(int count) throws Exception {
@@ -50,7 +49,9 @@ protected void createRows(int count) throws Exception {
   }
 
   // Test regular cursor fetching
+  @Test
   public void testBasicFetch() throws Exception {
+    assumeByteaSupported();
     createRows(1);
 
     PreparedStatement stmt =
@@ -69,7 +70,9 @@ public void testBasicFetch() throws Exception {
   }
 
   // Test binary cursor fetching
+  @Test
   public void testBinaryFetch() throws Exception {
+    assumeByteaSupported();
     createRows(1);
 
     PreparedStatement stmt =
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ServerPreparedStmtTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ServerPreparedStmtTest.java
index c4f294d79b..e5af362cd6 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ServerPreparedStmtTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/ServerPreparedStmtTest.java
@@ -8,28 +8,34 @@
 
 package org.postgresql.test.jdbc2;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
 import org.postgresql.PGStatement;
+import org.postgresql.jdbc.PreferQueryMode;
 import org.postgresql.test.TestUtil;
 
-import junit.framework.TestCase;
+import org.junit.Assume;
+import org.junit.Test;
 
-import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
+import java.sql.SQLException;
 import java.sql.Statement;
 
 /*
  * Tests for using server side prepared statements
  */
-public class ServerPreparedStmtTest extends TestCase {
-  private Connection con;
+public class ServerPreparedStmtTest extends BaseTest4 {
 
-  public ServerPreparedStmtTest(String name) {
-    super(name);
-  }
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+
+    Assume.assumeTrue("Server-prepared statements are not supported in simple protocol, thus ignoring the tests",
+        preferQueryMode != PreferQueryMode.SIMPLE);
 
-  protected void setUp() throws Exception {
-    con = TestUtil.openDB();
     Statement stmt = con.createStatement();
 
     TestUtil.createTable(con, "testsps", "id integer, value boolean");
@@ -44,11 +50,13 @@ protected void setUp() throws Exception {
     stmt.close();
   }
 
-  protected void tearDown() throws Exception {
+  @Override
+  public void tearDown() throws SQLException {
     TestUtil.dropTable(con, "testsps");
-    TestUtil.closeDB(con);
+    super.tearDown();
   }
 
+  @Test
   public void testEmptyResults() throws Exception {
     PreparedStatement pstmt = con.prepareStatement("SELECT * FROM testsps WHERE id = ?");
     ((PGStatement) pstmt).setUseServerPrepare(true);
@@ -61,6 +69,7 @@ public void testEmptyResults() throws Exception {
     pstmt.close();
   }
 
+  @Test
   public void testPreparedExecuteCount() throws Exception {
     PreparedStatement pstmt = con.prepareStatement("UPDATE testsps SET id = id + 44");
     ((PGStatement) pstmt).setUseServerPrepare(true);
@@ -70,6 +79,7 @@ public void testPreparedExecuteCount() throws Exception {
   }
 
 
+  @Test
   public void testPreparedStatementsNoBinds() throws Exception {
     PreparedStatement pstmt = con.prepareStatement("SELECT * FROM testsps WHERE id = 2");
     ((PGStatement) pstmt).setUseServerPrepare(true);
@@ -104,6 +114,7 @@ public void testPreparedStatementsNoBinds() throws Exception {
     pstmt.close();
   }
 
+  @Test
   public void testPreparedStatementsWithOneBind() throws Exception {
     PreparedStatement pstmt = con.prepareStatement("SELECT * FROM testsps WHERE id = ?");
     ((PGStatement) pstmt).setUseServerPrepare(true);
@@ -140,6 +151,7 @@ public void testPreparedStatementsWithOneBind() throws Exception {
   }
 
   // Verify we can bind booleans-as-objects ok.
+  @Test
   public void testBooleanObjectBind() throws Exception {
     PreparedStatement pstmt = con.prepareStatement("SELECT * FROM testsps WHERE value = ?");
     ((PGStatement) pstmt).setUseServerPrepare(true);
@@ -153,6 +165,7 @@ public void testBooleanObjectBind() throws Exception {
   }
 
   // Verify we can bind booleans-as-integers ok.
+  @Test
   public void testBooleanIntegerBind() throws Exception {
     PreparedStatement pstmt = con.prepareStatement("SELECT * FROM testsps WHERE id = ?");
     ((PGStatement) pstmt).setUseServerPrepare(true);
@@ -166,6 +179,7 @@ public void testBooleanIntegerBind() throws Exception {
   }
 
   // Verify we can bind booleans-as-native-types ok.
+  @Test
   public void testBooleanBind() throws Exception {
     PreparedStatement pstmt = con.prepareStatement("SELECT * FROM testsps WHERE value = ?");
     ((PGStatement) pstmt).setUseServerPrepare(true);
@@ -178,6 +192,7 @@ public void testBooleanBind() throws Exception {
     rs.close();
   }
 
+  @Test
   public void testPreparedStatementsWithBinds() throws Exception {
     PreparedStatement pstmt = con.prepareStatement("SELECT * FROM testsps WHERE id = ? or id = ?");
     ((PGStatement) pstmt).setUseServerPrepare(true);
@@ -201,6 +216,7 @@ public void testPreparedStatementsWithBinds() throws Exception {
     pstmt.close();
   }
 
+  @Test
   public void testSPSToggle() throws Exception {
     // Verify we can toggle UseServerPrepare safely before a query is executed.
     PreparedStatement pstmt = con.prepareStatement("SELECT * FROM testsps WHERE id = 2");
@@ -208,6 +224,7 @@ public void testSPSToggle() throws Exception {
     ((PGStatement) pstmt).setUseServerPrepare(false);
   }
 
+  @Test
   public void testBytea() throws Exception {
     // Verify we can use setBytes() with a server-prepared update.
     try {
@@ -223,6 +240,7 @@ public void testBytea() throws Exception {
   }
 
   // Check statements are not transformed when they shouldn't be.
+  @Test
   public void testCreateTable() throws Exception {
     // CREATE TABLE isn't supported by PREPARE; the driver should realize this and
     // still complete without error.
@@ -232,6 +250,7 @@ public void testCreateTable() throws Exception {
     TestUtil.dropTable(con, "testsps_bad");
   }
 
+  @Test
   public void testMultistatement() throws Exception {
     // Shouldn't try to PREPARE this one, if we do we get:
     // PREPARE x(int,int) AS INSERT .... $1 ; INSERT ... $2 -- syntax error
@@ -256,6 +275,7 @@ public void testMultistatement() throws Exception {
     }
   }
 
+  @Test
   public void testTypeChange() throws Exception {
     PreparedStatement pstmt = con.prepareStatement("SELECT CAST (? AS TEXT)");
     ((PGStatement) pstmt).setUseServerPrepare(true);
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/StatementTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/StatementTest.java
index bbd280b4d3..382f5dba0c 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/StatementTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/StatementTest.java
@@ -76,7 +76,7 @@ public void testDoubleClose() throws SQLException {
 
   public void testMultiExecute() throws SQLException {
     Statement stmt = con.createStatement();
-    assertTrue(stmt.execute("SELECT 1; UPDATE test_statement SET i=1; SELECT 2"));
+    assertTrue(stmt.execute("SELECT 1 as a; UPDATE test_statement SET i=1; SELECT 2 as b, 3 as c"));
 
     ResultSet rs = stmt.getResultSet();
     assertTrue(rs.next());
@@ -180,6 +180,20 @@ public void testPreparedFunction() throws SQLException {
     assertEquals("a5", rs.getString(1));
   }
 
+  public void testDollarInComment() throws SQLException {
+    PreparedStatement pstmt = con.prepareStatement("SELECT /* $ */ {fn curdate()}");
+    ResultSet rs = pstmt.executeQuery();
+    assertTrue(rs.next());
+    assertNotNull("{fn curdate()} should be not null", rs.getString(1));
+  }
+
+  public void testDollarInCommentTwoComments() throws SQLException {
+    PreparedStatement pstmt = con.prepareStatement("SELECT /* $ *//* $ */ {fn curdate()}");
+    ResultSet rs = pstmt.executeQuery();
+    assertTrue(rs.next());
+    assertNotNull("{fn curdate()} should be not null", rs.getString(1));
+  }
+
   public void testNumericFunctions() throws SQLException {
     Statement stmt = con.createStatement();
 
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/UpdateableResultTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/UpdateableResultTest.java
index 9eb3852f99..f36457d243 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/UpdateableResultTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/UpdateableResultTest.java
@@ -8,15 +8,20 @@
 
 package org.postgresql.test.jdbc2;
 
+import static junit.framework.TestCase.assertNull;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import org.postgresql.test.TestUtil;
 
-import junit.framework.TestCase;
+import org.junit.Test;
 
 import java.io.ByteArrayInputStream;
 import java.io.StringReader;
 import java.io.UnsupportedEncodingException;
 import java.sql.Array;
-import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
@@ -26,20 +31,11 @@
 import java.util.Arrays;
 import java.util.TimeZone;
 
-public class UpdateableResultTest extends TestCase {
-  private Connection con;
-
-  public UpdateableResultTest(String name) {
-    super(name);
-    try {
-      Class.forName("org.postgresql.Driver");
-    } catch (Exception ex) {
-    }
-
-  }
+public class UpdateableResultTest extends BaseTest4 {
 
-  protected void setUp() throws Exception {
-    con = TestUtil.openDB();
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
     TestUtil.createTable(con, "updateable",
         "id int primary key, name text, notselected text, ts timestamp with time zone, intarr int[]",
         true);
@@ -56,13 +52,15 @@ protected void setUp() throws Exception {
 
   }
 
-  protected void tearDown() throws Exception {
+  @Override
+  public void tearDown() throws SQLException {
     TestUtil.dropTable(con, "updateable");
     TestUtil.dropTable(con, "second");
     TestUtil.dropTable(con, "stream");
-    TestUtil.closeDB(con);
+    super.tearDown();
   }
 
+  @Test
   public void testDeleteRows() throws SQLException {
     Statement st = con.createStatement();
     st.executeUpdate("INSERT INTO second values (2,'two')");
@@ -89,6 +87,7 @@ public void testDeleteRows() throws SQLException {
   }
 
 
+  @Test
   public void testCancelRowUpdates() throws Exception {
     Statement st =
         con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
@@ -155,6 +154,7 @@ private void checkPositioning(ResultSet rs) throws SQLException {
     }
   }
 
+  @Test
   public void testPositioning() throws SQLException {
     Statement stmt =
         con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
@@ -183,6 +183,7 @@ public void testPositioning() throws SQLException {
     stmt.close();
   }
 
+  @Test
   public void testUpdateTimestamp() throws SQLException {
     TimeZone origTZ = TimeZone.getDefault();
     try {
@@ -205,7 +206,9 @@ public void testUpdateTimestamp() throws SQLException {
     }
   }
 
+  @Test
   public void testUpdateStreams() throws SQLException, UnsupportedEncodingException {
+    assumeByteaSupported();
     String string = "Hello";
     byte[] bytes = new byte[]{0, '\\', (byte) 128, (byte) 255};
 
@@ -264,6 +267,7 @@ public void testUpdateStreams() throws SQLException, UnsupportedEncodingExceptio
     stmt.close();
   }
 
+  @Test
   public void testZeroRowResult() throws SQLException {
     Statement st =
         con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
@@ -273,6 +277,7 @@ public void testZeroRowResult() throws SQLException {
     rs.moveToCurrentRow();
   }
 
+  @Test
   public void testUpdateable() throws SQLException {
     Statement st =
         con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
@@ -358,6 +363,7 @@ public void testUpdateable() throws SQLException {
     st.close();
   }
 
+  @Test
   public void testInsertRowIllegalMethods() throws Exception {
     Statement st =
         con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
@@ -393,6 +399,7 @@ public void testInsertRowIllegalMethods() throws Exception {
     st.close();
   }
 
+  @Test
   public void testUpdateablePreparedStatement() throws Exception {
     // No args.
     PreparedStatement st = con.prepareStatement("select * from updateable",
@@ -412,6 +419,7 @@ public void testUpdateablePreparedStatement() throws Exception {
     st.close();
   }
 
+  @Test
   public void testUpdateSelectOnly() throws Exception {
     Statement st =
         con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
@@ -422,6 +430,7 @@ public void testUpdateSelectOnly() throws Exception {
     rs.updateRow();
   }
 
+  @Test
   public void testUpdateReadOnlyResultSet() throws Exception {
     Statement st =
         con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
@@ -433,6 +442,7 @@ public void testUpdateReadOnlyResultSet() throws Exception {
     }
   }
 
+  @Test
   public void testBadColumnIndexes() throws Exception {
     Statement st =
         con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
@@ -455,6 +465,7 @@ public void testBadColumnIndexes() throws Exception {
     }
   }
 
+  @Test
   public void testArray() throws SQLException {
     Statement stmt =
         con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
@@ -487,6 +498,7 @@ public void testArray() throws SQLException {
     stmt.close();
   }
 
+  @Test
   public void testMultiColumnUpdateWithoutAllColumns() throws Exception {
     Statement st =
         con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
@@ -499,6 +511,7 @@ public void testMultiColumnUpdateWithoutAllColumns() throws Exception {
     }
   }
 
+  @Test
   public void testMultiColumnUpdate() throws Exception {
     Statement st =
         con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/VersionTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc2/VersionTest.java
deleted file mode 100644
index 544f060ecd..0000000000
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc2/VersionTest.java
+++ /dev/null
@@ -1,80 +0,0 @@
-package org.postgresql.test.jdbc2;
-
-import org.postgresql.core.ServerVersion;
-import org.postgresql.core.Utils;
-
-import junit.framework.TestCase;
-
-public class VersionTest extends TestCase {
-
-  @Override
-  protected void setUp() throws Exception {
-    super.setUp();
-  }
-
-  public void testVersionParsing() {
-    assertNotNull(Utils.class);
-    System.out.println(Utils.class.getProtectionDomain().getCodeSource().getLocation());
-    /* Boring versions */
-    assertEquals(70400, Utils.parseServerVersionStr("7.4.0"));
-    assertEquals(ServerVersion.v7_4.getVersionNum(), Utils.parseServerVersionStr("7.4.0"));
-    assertEquals(90001, Utils.parseServerVersionStr("9.0.1"));
-    assertEquals(90000, Utils.parseServerVersionStr("9.0.0"));
-    assertEquals(ServerVersion.v9_0.getVersionNum(), Utils.parseServerVersionStr("9.0.0"));
-    assertEquals(90201, Utils.parseServerVersionStr("9.2.1"));
-
-    /* Major-only versions */
-    assertEquals(70400, Utils.parseServerVersionStr("7.4"));
-    assertEquals(90000, Utils.parseServerVersionStr("9.0"));
-    assertEquals(90000, Utils.parseServerVersionStr("9.0"));
-    assertEquals(ServerVersion.v9_0.getVersionNum(), Utils.parseServerVersionStr("9.0"));
-    assertEquals(90200, Utils.parseServerVersionStr("9.2"));
-    assertEquals(ServerVersion.v9_2.getVersionNum(), Utils.parseServerVersionStr("9.2"));
-
-    /* Multi-digit versions */
-    assertEquals(90410, Utils.parseServerVersionStr("9.4.10"));
-    assertEquals(92010, Utils.parseServerVersionStr("9.20.10"));
-    assertEquals(100000, Utils.parseServerVersionStr("10.0.0"));
-    assertEquals(100103, Utils.parseServerVersionStr("10.1.3"));
-    assertEquals(102010, Utils.parseServerVersionStr("10.20.10"));
-
-    /* Out-of-range versions */
-    try {
-      Utils.parseServerVersionStr("9.20.100");
-      fail("Should've rejected three-digit minor version");
-    } catch (NumberFormatException ex) {
-    }
-
-    try {
-      Utils.parseServerVersionStr("10.100.10");
-      fail("Should've rejected three-digit second part of major version");
-    } catch (NumberFormatException ex) {
-    }
-
-    /* Big first part is OK */
-    assertEquals(1232010, Utils.parseServerVersionStr("123.20.10"));
-
-    /* But not too big */
-    try {
-      Utils.parseServerVersionStr("12345.1.1");
-      fail("Should've rejected five-digit second part of major version");
-    } catch (NumberFormatException ex) {
-    }
-
-    /* Large numeric inputs are taken as already parsed */
-    assertEquals(90104, Utils.parseServerVersionStr("90104"));
-    assertEquals(90104, Utils.parseServerVersionStr("090104"));
-    assertEquals(70400, Utils.parseServerVersionStr("070400"));
-    assertEquals(100104, Utils.parseServerVersionStr("100104"));
-    assertEquals(10000, Utils.parseServerVersionStr("10000"));
-
-    /* --with-extra-version or beta/devel tags */
-    assertEquals(90400, Utils.parseServerVersionStr("9.4devel"));
-    assertEquals(90400, Utils.parseServerVersionStr("9.4beta1"));
-    assertEquals(100000, Utils.parseServerVersionStr("10.0devel"));
-    assertEquals(100000, Utils.parseServerVersionStr("10.0beta1"));
-    assertEquals(90401, Utils.parseServerVersionStr("9.4.1bobs"));
-    assertEquals(90401, Utils.parseServerVersionStr("9.4.1bobspatched9.4"));
-    assertEquals(90401, Utils.parseServerVersionStr("9.4.1-bobs-patched-postgres-v2.2"));
-  }
-}
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc3/CompositeQueryParseTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc3/CompositeQueryParseTest.java
index 92855b9c1b..46b4d1f869 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc3/CompositeQueryParseTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc3/CompositeQueryParseTest.java
@@ -6,6 +6,7 @@
 
 import junit.framework.TestCase;
 
+import java.sql.SQLException;
 import java.util.List;
 
 public class CompositeQueryParseTest extends TestCase {
@@ -68,64 +69,71 @@ public void testMultipleTrailingSemicolons() {
     assertEquals("select 1", reparse("select 1;;;", true, false, true));
   }
 
-  public void testHasReturning() {
+  public void testHasReturning() throws SQLException {
 
-    List<NativeQuery> queries = Parser.parseJdbcSql("insert into foo (a,b,c) values (?,?,?) RetuRning a", true, true, false, true, true);
+    List<NativeQuery> queries = Parser.parseJdbcSql("insert into foo (a,b,c) values (?,?,?) RetuRning a", true, true, false,
+        true);
     NativeQuery query = queries.get(0);
     assertTrue("The parser should find the word returning", query.command.isReturningKeywordPresent());
 
-    queries = Parser.parseJdbcSql("insert into foo (a,b,c) values (?,?,?)", true, true, false, true, true);
+    queries = Parser.parseJdbcSql("insert into foo (a,b,c) values (?,?,?)", true, true, false, true);
     query = queries.get(0);
     assertFalse("The parser should not find the word returning", query.command.isReturningKeywordPresent());
 
-    queries = Parser.parseJdbcSql("insert into foo (a,b,c) values ('returning',?,?)", true, true, false, true, true);
+    queries = Parser.parseJdbcSql("insert into foo (a,b,c) values ('returning',?,?)", true, true, false,
+        true);
     query = queries.get(0);
     assertFalse("The parser should not find the word returning as it is in quotes ", query.command.isReturningKeywordPresent());
+  }
 
-    queries = Parser.parseJdbcSql("select 1 as returning", true, true, false, true, true);
+  public void testSelect() throws SQLException {
+    List<NativeQuery> queries;
+    NativeQuery query;
+    queries = Parser.parseJdbcSql("select 1 as returning from (update table)", true, true, false, true);
     query = queries.get(0);
-    assertFalse("This is not an insert command", query.command.getType() == SqlCommandType.INSERT);
+    assertEquals("This is a select ", SqlCommandType.SELECT, query.command.getType());
     assertTrue("Returning is OK here as it is not an insert command ", query.command.isReturningKeywordPresent());
-
   }
 
-  public void testHasDelete() {
-    List<NativeQuery> queries = Parser.parseJdbcSql("DeLeTe from foo where a=1", true, true, false, true, true);
+  public void testDelete() throws SQLException {
+    List<NativeQuery> queries = Parser.parseJdbcSql("DeLeTe from foo where a=1", true, true, false,
+        true);
     NativeQuery query = queries.get(0);
-    assertTrue("This is a delete command", query.command.getType() == SqlCommandType.DELETE);
-
-    queries = Parser.parseJdbcSql("update foo set (a=?,b=?,c=?)", true, true, false, true, true);
-    query = queries.get(0);
-    assertFalse("This is not a delete command", query.command.getType() == SqlCommandType.DELETE);
-
+    assertEquals("This is a delete command", SqlCommandType.DELETE, query.command.getType());
   }
 
 
-  public void testisMove() {
-
-    List<NativeQuery> queries = Parser.parseJdbcSql("MoVe NEXT FROM FOO", true, true, false, true, true);
+  public void testMove() throws SQLException {
+    List<NativeQuery> queries = Parser.parseJdbcSql("MoVe NEXT FROM FOO", true, true, false, true);
     NativeQuery query = queries.get(0);
-    assertTrue("This is a move command", query.command.getType() == SqlCommandType.MOVE);
+    assertEquals("This is a move command", SqlCommandType.MOVE, query.command.getType());
+  }
 
-    queries = Parser.parseJdbcSql("update foo set (a=?,b=?,c=?)", true, true, false, true, true);
+  public void testUpdate() throws SQLException {
+    List<NativeQuery> queries;
+    NativeQuery query;
+    queries = Parser.parseJdbcSql("update foo set (a=?,b=?,c=?)", true, true, false, true);
     query = queries.get(0);
-    assertFalse("This is not a move command", query.command.getType() == SqlCommandType.MOVE);
-
+    assertEquals("This is an UPDATE command", SqlCommandType.UPDATE, query.command.getType());
   }
 
-  public void testIsInsert() {
-
-    List<NativeQuery> queries = Parser.parseJdbcSql("InSeRt into foo (a,b,c) values (?,?,?) returning a", true, true, false, true, true);
+  public void testInsert() throws SQLException {
+    List<NativeQuery> queries = Parser.parseJdbcSql("InSeRt into foo (a,b,c) values (?,?,?) returning a", true, true, false,
+        true);
     NativeQuery query = queries.get(0);
-    assertTrue("This is an insert command", query.command.getType() == SqlCommandType.INSERT);
+    assertEquals("This is an INSERT command", SqlCommandType.INSERT, query.command.getType());
 
-    queries = Parser.parseJdbcSql("update foo set (a=?,b=?,c=?)", true, true, false, true, true);
+    queries = Parser.parseJdbcSql("select 1 as insert", true, true, false, true);
     query = queries.get(0);
-    assertFalse("This is not an insert command", query.command.getType() == SqlCommandType.INSERT);
+    assertEquals("This is a SELECT command", SqlCommandType.SELECT, query.command.getType());
+  }
 
-    queries = Parser.parseJdbcSql("select 1 as insert", true, true, false, true, true);
+  public void testWith() throws SQLException {
+    List<NativeQuery> queries;
+    NativeQuery query;
+    queries = Parser.parseJdbcSql("with update as insert (update foo set (a=?,b=?,c=?)) select * from update", true, true, false, true);
     query = queries.get(0);
-    assertFalse("This is not insert command", query.command.getType() == SqlCommandType.INSERT);
+    assertEquals("This is a WITH command", SqlCommandType.WITH, query.command.getType());
   }
 
   public void testMultipleEmptyQueries() {
@@ -140,8 +148,12 @@ public void testCompositeWithComments() {
 
   private String reparse(String query, boolean standardConformingStrings, boolean withParameters,
       boolean splitStatements) {
-    return toString(
-        Parser.parseJdbcSql(query, standardConformingStrings, withParameters, splitStatements, true, false));
+    try {
+      return toString(
+          Parser.parseJdbcSql(query, standardConformingStrings, withParameters, splitStatements, false));
+    } catch (SQLException e) {
+      throw new IllegalStateException("Parser.parseJdbcSql: " + e.getMessage(), e);
+    }
   }
 
   private String toString(List<NativeQuery> queries) {
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc3/GeneratedKeysTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc3/GeneratedKeysTest.java
index 0fa4ac7b9c..8412232908 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc3/GeneratedKeysTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc3/GeneratedKeysTest.java
@@ -8,67 +8,140 @@
 
 package org.postgresql.test.jdbc3;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import org.postgresql.test.TestUtil;
+import org.postgresql.test.jdbc2.BaseTest4;
 
-import junit.framework.TestCase;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
 
-import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
+import java.sql.ResultSetMetaData;
 import java.sql.SQLException;
 import java.sql.Statement;
+import java.util.ArrayList;
+import java.util.Collection;
+
+@RunWith(Parameterized.class)
+public class GeneratedKeysTest extends BaseTest4 {
+  public enum ReturningInQuery {
+    A("a"),
+    AB("a", "b"),
+    STAR("*"),
+    NO();
+    final String[] columns;
 
-public class GeneratedKeysTest extends TestCase {
+    ReturningInQuery(String... columns) {
+      this.columns = columns;
+    }
 
-  private Connection _conn;
+    public int columnsReturned() {
+      if (columns.length == 1 && columns[0].charAt(0) == '*') {
+        return 100500; // does not matter much, the meaning is "every possible column"
+      }
+      return columns.length;
+    }
 
-  public GeneratedKeysTest(String name) throws Exception {
-    super(name);
+    public String getClause() {
+      if (columnsReturned() == 0) {
+        return "";
+      }
+      StringBuilder sb = new StringBuilder(" returning ");
+      for (int i = 0; i < columns.length; i++) {
+        String column = columns[i];
+        if (i != 0) {
+          sb.append(", ");
+        }
+        sb.append(column);
+      }
+      return sb.toString();
+    }
   }
 
-  protected void setUp() throws Exception {
-    _conn = TestUtil.openDB();
-    Statement stmt = _conn.createStatement();
-    stmt.execute("CREATE TEMP TABLE genkeys(a serial, b text, c int)");
-    stmt.close();
+  private final ReturningInQuery returningInQuery;
+  private final String returningClause;
+
+  public GeneratedKeysTest(ReturningInQuery returningInQuery) throws Exception {
+    this.returningInQuery = returningInQuery;
+    this.returningClause = returningInQuery.getClause();
   }
 
-  protected void tearDown() throws SQLException {
-    Statement stmt = _conn.createStatement();
-    stmt.execute("DROP TABLE genkeys");
-    stmt.close();
-    TestUtil.closeDB(_conn);
+  @Parameterized.Parameters(name = "returningInQuery = {0}")
+  public static Iterable<Object[]> data() {
+    Collection<Object[]> ids = new ArrayList<Object[]>();
+    for (ReturningInQuery returningInQuery : ReturningInQuery.values()) {
+      ids.add(new Object[]{returningInQuery});
+    }
+    return ids;
+  }
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    TestUtil.createTempTable(con, "genkeys", "a serial, b text, c int");
+  }
+
+  @Override
+  public void tearDown() throws SQLException {
+    TestUtil.dropTable(con, "genkeys");
+    super.tearDown();
+  }
+
+  @Test
+  public void testGeneratedKeys() throws SQLException {
+    testGeneratedKeysWithSuffix("");
   }
 
-  public void testExecuteUpdateAllColumns() throws SQLException {
-    Statement stmt = _conn.createStatement();
-    int count = stmt.executeUpdate("INSERT INTO genkeys VALUES (1, 'a', 2)",
+  private void testGeneratedKeysWithSuffix(String suffix) throws SQLException {
+    Statement stmt = con.createStatement();
+    int count = stmt.executeUpdate("INSERT INTO genkeys VALUES (1, 'a', 2)" + returningClause + suffix,
         Statement.RETURN_GENERATED_KEYS);
     assertEquals(1, count);
     ResultSet rs = stmt.getGeneratedKeys();
+    assert1a2(rs);
+  }
+
+  private void assert1a2(ResultSet rs) throws SQLException {
     assertTrue(rs.next());
     assertEquals(1, rs.getInt(1));
-    assertEquals("a", rs.getString(2));
-    assertEquals(2, rs.getInt(3));
     assertEquals(1, rs.getInt("a"));
-    assertEquals("a", rs.getString("b"));
-    assertEquals(2, rs.getInt("c"));
+    if (returningInQuery.columnsReturned() >= 2) {
+      assertEquals("a", rs.getString(2));
+      assertEquals("a", rs.getString("b"));
+    }
+    if (returningInQuery.columnsReturned() >= 3) {
+      assertEquals("2", rs.getString(3));
+      assertEquals(2, rs.getInt("c"));
+    }
     assertTrue(!rs.next());
   }
 
+  @Test
   public void testStatementUpdateCount() throws SQLException {
-    Statement stmt = _conn.createStatement();
-    stmt.executeUpdate("INSERT INTO genkeys VALUES (1, 'a', 2)", Statement.RETURN_GENERATED_KEYS);
+    Statement stmt = con.createStatement();
+    stmt.executeUpdate("INSERT INTO genkeys VALUES (1, 'a', 2)" + returningClause,
+        Statement.RETURN_GENERATED_KEYS);
     assertEquals(1, stmt.getUpdateCount());
     assertNull(stmt.getResultSet());
     assertTrue(!stmt.getMoreResults());
   }
 
+  @Test
   public void testCloseStatementClosesRS() throws SQLException {
-    Statement stmt = _conn.createStatement();
-    stmt.executeUpdate("INSERT INTO genkeys VALUES (1, 'a', 2)", Statement.RETURN_GENERATED_KEYS);
+    Statement stmt = con.createStatement();
+    stmt.executeUpdate("INSERT INTO genkeys VALUES (1, 'a', 2)" + returningClause,
+        Statement.RETURN_GENERATED_KEYS);
     ResultSet rs = stmt.getGeneratedKeys();
     stmt.close();
+    assertTrue("statement was closed, thus the resultset should be closed as well", rs.isClosed());
     try {
       rs.next();
       fail("Can't operate on a closed result set.");
@@ -76,54 +149,54 @@ public void testCloseStatementClosesRS() throws SQLException {
     }
   }
 
+  @Test
   public void testReturningWithTrailingSemicolon() throws SQLException {
-    Statement stmt = _conn.createStatement();
-    stmt.executeUpdate("INSERT INTO genkeys VALUES (1, 'a', 2); ", Statement.RETURN_GENERATED_KEYS);
-    ResultSet rs = stmt.getGeneratedKeys();
-    assertTrue(rs.next());
-    assertEquals("a", rs.getString(2));
-    assertTrue(!rs.next());
+    testGeneratedKeysWithSuffix("; ");
   }
 
+  @Test
   public void testEmptyRSWithoutReturning() throws SQLException {
-    Statement stmt = _conn.createStatement();
-    int count =
-        stmt.executeUpdate("INSERT INTO genkeys VALUES (1, 'a', 2); ", Statement.NO_GENERATED_KEYS);
-    assertEquals(1, count);
-    ResultSet rs = stmt.getGeneratedKeys();
-    assertTrue(!rs.next());
-  }
-
-  public void testColumnsByName() throws SQLException {
-    Statement stmt = _conn.createStatement();
-    int count =
-        stmt.executeUpdate("INSERT INTO genkeys VALUES (1, 'a', 2); ", new String[]{"c", "a"});
-    assertEquals(1, count);
+    Statement stmt = con.createStatement();
+    try {
+      int count =
+          stmt.executeUpdate("INSERT INTO genkeys VALUES (1, 'a', 2)" + returningClause + "; ",
+              Statement.NO_GENERATED_KEYS);
+      assertEquals(1, count);
+      if (returningInQuery.columnsReturned() > 0) {
+        fail(
+            "A result was returned when none was expected error should happen when executing executeUpdate('... returning ...')");
+      }
+    } catch (SQLException e) {
+      if (returningInQuery.columnsReturned() > 0 && "0100E".equals(e.getSQLState())) {
+        // A result was returned when none was expected
+        return; // just as expected
+      }
+      throw e;
+    }
     ResultSet rs = stmt.getGeneratedKeys();
-    assertTrue(rs.next());
-    assertEquals(2, rs.getInt(1));
-    assertEquals(1, rs.getInt(2));
-    assertEquals(1, rs.getInt("a"));
-    assertEquals(2, rs.getInt("c"));
-    assertTrue(!rs.next());
+    assertFalse("Statement.NO_GENERATED_KEYS => stmt.getGeneratedKeys() should be empty", rs.next());
   }
 
+  @Test
   public void testMultipleRows() throws SQLException {
-    Statement stmt = _conn.createStatement();
-    int count = stmt.executeUpdate("INSERT INTO genkeys VALUES (1, 'a', 2), (3, 'b', 4); ",
-        new String[]{"c"});
+    Statement stmt = con.createStatement();
+    int count = stmt.executeUpdate(
+        "INSERT INTO genkeys VALUES (1, 'a', 2), (2, 'b', 4)" + returningClause + "; ",
+        new String[]{"c", "b"});
     assertEquals(2, count);
     ResultSet rs = stmt.getGeneratedKeys();
     assertTrue(rs.next());
-    assertEquals(2, rs.getInt(1));
+    assertCB1(rs);
     assertTrue(rs.next());
-    assertEquals(4, rs.getInt(1));
+    assertCB2(rs);
     assertTrue(!rs.next());
   }
 
+  @Test
   public void testSerialWorks() throws SQLException {
-    Statement stmt = _conn.createStatement();
-    int count = stmt.executeUpdate("INSERT INTO genkeys (b,c) VALUES ('a', 2), ('b', 4); ",
+    Statement stmt = con.createStatement();
+    int count = stmt.executeUpdate(
+        "INSERT INTO genkeys (b,c) VALUES ('a', 2), ('b', 4)" + returningClause + "; ",
         new String[]{"a"});
     assertEquals(2, count);
     ResultSet rs = stmt.getGeneratedKeys();
@@ -134,86 +207,179 @@ public void testSerialWorks() throws SQLException {
     assertTrue(!rs.next());
   }
 
+  @Test
   public void testUpdate() throws SQLException {
-    Statement stmt = _conn.createStatement();
-    stmt.executeUpdate("INSERT INTO genkeys VALUES (1, 'a', 2)");
+    Statement stmt = con.createStatement();
+    stmt.executeUpdate("INSERT INTO genkeys VALUES (1, 'a', 3)");
     stmt.executeUpdate("INSERT INTO genkeys VALUES (2, 'b', 4)");
-    stmt.executeUpdate("UPDATE genkeys SET c=3 WHERE a = 1", new String[]{"c", "b"});
+    stmt.executeUpdate("UPDATE genkeys SET c=2 WHERE a = 1" + returningClause,
+        new String[]{"c", "b"});
     ResultSet rs = stmt.getGeneratedKeys();
     assertTrue(rs.next());
-    assertEquals(3, rs.getInt(1));
-    assertEquals("a", rs.getString(2));
+    assertCB1(rs);
     assertTrue(!rs.next());
   }
 
+  @Test
   public void testDelete() throws SQLException {
-    Statement stmt = _conn.createStatement();
+    Statement stmt = con.createStatement();
     stmt.executeUpdate("INSERT INTO genkeys VALUES (1, 'a', 2)");
     stmt.executeUpdate("INSERT INTO genkeys VALUES (2, 'b', 4)");
-    stmt.executeUpdate("DELETE FROM genkeys WHERE a = 1", new String[]{"c", "b"});
+    stmt.executeUpdate("DELETE FROM genkeys WHERE a = 1" + returningClause,
+        new String[]{"c", "b"});
     ResultSet rs = stmt.getGeneratedKeys();
     assertTrue(rs.next());
-    assertEquals(2, rs.getInt(1));
-    assertEquals("a", rs.getString(2));
+    assertCB1(rs);
     assertTrue(!rs.next());
   }
 
+  @Test
   public void testPSUpdate() throws SQLException {
-    Statement stmt = _conn.createStatement();
-    stmt.executeUpdate("INSERT INTO genkeys VALUES (1, 'a', 2)");
+    Statement stmt = con.createStatement();
+    stmt.executeUpdate("INSERT INTO genkeys VALUES (1, 'a', -3)");
     stmt.executeUpdate("INSERT INTO genkeys VALUES (2, 'b', 4)");
     stmt.close();
 
     PreparedStatement ps =
-        _conn.prepareStatement("UPDATE genkeys SET c=? WHERE a = ?", new String[]{"c", "b"});
-    ps.setInt(1, 3);
+        con.prepareStatement("UPDATE genkeys SET c=? WHERE a = ?" + returningClause, new String[]{"c", "b"});
+    ps.setInt(1, 2);
     ps.setInt(2, 1);
     assertEquals(1, ps.executeUpdate());
     ResultSet rs = ps.getGeneratedKeys();
     assertTrue(rs.next());
-    assertEquals(3, rs.getInt(1));
-    assertEquals("a", rs.getString(2));
+    assertCB1(rs);
     assertTrue(!rs.next());
   }
 
+  @Test
   public void testPSDelete() throws SQLException {
-    Statement stmt = _conn.createStatement();
+    Statement stmt = con.createStatement();
     stmt.executeUpdate("INSERT INTO genkeys VALUES (1, 'a', 2)");
     stmt.executeUpdate("INSERT INTO genkeys VALUES (2, 'b', 4)");
     stmt.close();
 
     PreparedStatement ps =
-        _conn.prepareStatement("DELETE FROM genkeys WHERE a = ?", new String[]{"c", "b"});
+        con.prepareStatement("DELETE FROM genkeys WHERE a = ?" + returningClause, new String[]{"c", "b"});
 
     ps.setInt(1, 1);
     assertEquals(1, ps.executeUpdate());
     ResultSet rs = ps.getGeneratedKeys();
     assertTrue(rs.next());
-    assertEquals(2, rs.getInt(1));
-    assertEquals("a", rs.getString(2));
+    assertCB1(rs);
     assertTrue(!rs.next());
 
     ps.setInt(1, 2);
     assertEquals(1, ps.executeUpdate());
     rs = ps.getGeneratedKeys();
     assertTrue(rs.next());
-    assertEquals(4, rs.getInt(1));
-    assertEquals("b", rs.getString(2));
+    assertCB2(rs);
     assertTrue(!rs.next());
   }
 
+  private void assertCB1(ResultSet rs) throws SQLException {
+    ResultSetMetaData rsmd = rs.getMetaData();
+    StringBuilder sb = new StringBuilder();
+    for (int i = 1; i <= rsmd.getColumnCount(); i++) {
+      if (i > 1) {
+        sb.append(", ");
+      }
+      sb.append(rsmd.getColumnName(i));
+    }
+    String columnNames = sb.toString();
+    switch (returningInQuery) {
+      case NO:
+        assertEquals("Two columns should be returned since returning clause was empty and {c, b} was requested via API",
+            "c, b", columnNames);
+        assertEquals(2, rs.getInt(1));
+        assertEquals("a", rs.getString(2));
+        assertEquals(2, rs.getInt("c"));
+        assertEquals("a", rs.getString("b"));
+        break;
+      case A:
+        assertEquals("Just one column should be returned since returning clause was " + returningClause,
+            "a", columnNames);
+        assertEquals(1, rs.getInt(1));
+        assertEquals(1, rs.getInt("a"));
+        break;
+      case AB:
+        assertEquals("Two columns should be returned since returning clause was " + returningClause,
+            "a, b", columnNames);
+        assertEquals(1, rs.getInt(1));
+        assertEquals("a", rs.getString(2));
+        assertEquals(1, rs.getInt("a"));
+        assertEquals("a", rs.getString("b"));
+        break;
+      case STAR:
+        assertEquals("Three columns should be returned since returning clause was " + returningClause,
+            "a, b, c", columnNames);
+        assertEquals(1, rs.getInt(1));
+        assertEquals("a", rs.getString(2));
+        assertEquals(2, rs.getInt(3));
+        assertEquals(1, rs.getInt("a"));
+        assertEquals("a", rs.getString("b"));
+        assertEquals(2, rs.getInt("c"));
+        break;
+      default:
+        fail("Unexpected test kind: " + returningInQuery);
+    }
+  }
+
+  private void assertCB2(ResultSet rs) throws SQLException {
+    switch (returningInQuery) {
+      case NO:
+        assertEquals("Two columns should be returned since returning clause was empty and {c, b} was requested via API",
+            2, rs.getMetaData().getColumnCount());
+        assertEquals(4, rs.getInt(1));
+        assertEquals("b", rs.getString(2));
+        break;
+      case A:
+        assertEquals("Just one column should be returned since returning clause was " + returningClause,
+            1, rs.getMetaData().getColumnCount());
+        assertEquals(2, rs.getInt(1));
+        break;
+      case AB:
+        assertEquals("Two columns should be returned since returning clause was " + returningClause,
+            2, rs.getMetaData().getColumnCount());
+        assertEquals(2, rs.getInt(1));
+        assertEquals("b", rs.getString(2));
+        break;
+      case STAR:
+        assertEquals("Three columns should be returned since returning clause was " + returningClause,
+            3, rs.getMetaData().getColumnCount());
+        assertEquals(2, rs.getInt(1));
+        assertEquals("b", rs.getString(2));
+        assertEquals(4, rs.getInt(3));
+        break;
+      default:
+        fail("Unexpected test kind: " + returningInQuery);
+    }
+  }
+
+  @Test
   public void testGeneratedKeysCleared() throws SQLException {
-    Statement stmt = _conn.createStatement();
-    stmt.executeUpdate("INSERT INTO genkeys VALUES (1, 'a', 2); ", Statement.RETURN_GENERATED_KEYS);
+    Statement stmt = con.createStatement();
+    stmt.executeUpdate("INSERT INTO genkeys VALUES (1, 'a', 2)" + returningClause + "; ", Statement.RETURN_GENERATED_KEYS);
     ResultSet rs = stmt.getGeneratedKeys();
     assertTrue(rs.next());
-    stmt.executeUpdate("INSERT INTO genkeys VALUES (2, 'b', 3)");
+    try {
+      stmt.executeUpdate("INSERT INTO genkeys VALUES (2, 'b', 3)" + returningClause);
+      if (returningInQuery.columnsReturned() > 0) {
+        fail("A result was returned when none was expected error should happen when executing executeUpdate('... returning ...')");
+      }
+    } catch (SQLException e) {
+      if (returningInQuery.columnsReturned() > 0 && "0100E".equals(e.getSQLState())) {
+        // A result was returned when none was expected
+        return; // just as expected
+      }
+      throw e;
+    }
     rs = stmt.getGeneratedKeys();
     assertTrue(!rs.next());
   }
 
+  @Test
   public void testBatchGeneratedKeys() throws SQLException {
-    PreparedStatement ps = _conn.prepareStatement("INSERT INTO genkeys(c) VALUES (?)",
+    PreparedStatement ps = con.prepareStatement("INSERT INTO genkeys(c) VALUES (?)" + returningClause + "",
         Statement.RETURN_GENERATED_KEYS);
     ps.setInt(1, 4);
     ps.addBatch();
@@ -221,12 +387,68 @@ public void testBatchGeneratedKeys() throws SQLException {
     ps.addBatch();
     ps.executeBatch();
     ResultSet rs = ps.getGeneratedKeys();
-    assertTrue(rs.next());
+    assertTrue("getGeneratedKeys.next() should be non-empty", rs.next());
     assertEquals(1, rs.getInt("a"));
     assertTrue(rs.next());
     assertEquals(2, rs.getInt("a"));
     assertTrue(!rs.next());
   }
 
+  private PreparedStatement prepareSelect() throws SQLException {
+    PreparedStatement ps;
+    String sql = "select c from genkeys";
+    switch (returningInQuery) {
+      case NO:
+        ps = con.prepareStatement(sql);
+        break;
+      case STAR:
+        ps = con.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
+        break;
+      default:
+        ps = con.prepareStatement(sql, returningInQuery.columns);
+    }
+    return ps;
+  }
+
+  @Test
+  public void selectWithGeneratedKeysViaPreparedExecuteQuery() throws SQLException {
+    PreparedStatement ps = prepareSelect();
+    ResultSet rs = ps.executeQuery();
+    assertFalse("genkeys table is empty, thus rs.next() should return false", rs.next());
+    ps.close();
+  }
+
+  @Test
+  public void selectWithGeneratedKeysViaPreparedExecute() throws SQLException {
+    PreparedStatement ps = prepareSelect();
+    ps.execute();
+    ResultSet rs = ps.getResultSet();
+    assertFalse("genkeys table is empty, thus rs.next() should return false", rs.next());
+    ps.close();
+  }
+
+  @Test
+  public void selectWithGeneratedKeysViaNonPrepared() throws SQLException {
+    Statement s = con.createStatement();
+    String sql = "select c from genkeys";
+    ResultSet rs;
+    switch (returningInQuery) {
+      case NO:
+        s.execute(sql);
+        rs = s.getResultSet();
+        break;
+      case STAR:
+        s.execute(sql, Statement.RETURN_GENERATED_KEYS);
+        rs = s.getResultSet();
+        break;
+      default:
+        s.execute(sql, returningInQuery.columns);
+        rs = s.getResultSet();
+    }
+    assertNotNull("SELECT statement should return results via getResultSet, not getGeneratedKeys", rs);
+    assertFalse("genkeys table is empty, thus rs.next() should return false", rs.next());
+    s.close();
+  }
+
 }
 
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc3/Jdbc3CallableStatementTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc3/Jdbc3CallableStatementTest.java
index 9b7cc46e3e..3d23bd0d96 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc3/Jdbc3CallableStatementTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc3/Jdbc3CallableStatementTest.java
@@ -8,14 +8,18 @@
 
 package org.postgresql.test.jdbc3;
 
-import org.postgresql.test.TestUtil;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import org.postgresql.test.jdbc2.BaseTest4;
 import org.postgresql.util.PSQLState;
 
-import junit.framework.TestCase;
+import org.junit.Test;
 
 import java.math.BigDecimal;
 import java.sql.CallableStatement;
-import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
@@ -25,17 +29,15 @@
 /**
  * @author davec
  */
-public class Jdbc3CallableStatementTest extends TestCase {
-
-  private Connection con;
+public class Jdbc3CallableStatementTest extends BaseTest4 {
 
   /*
    * (non-Javadoc)
    *
    * @see junit.framework.TestCase#setUp()
    */
-  protected void setUp() throws Exception {
-    con = TestUtil.openDB();
+  public void setUp() throws Exception {
+    super.setUp();
     Statement stmt = con.createStatement();
     stmt.execute(
         "create temp table numeric_tab (MAX_VAL NUMERIC(30,15), MIN_VAL NUMERIC(30,15), NULL_VAL NUMERIC(30,15) NULL)");
@@ -93,7 +95,7 @@ protected void setUp() throws Exception {
    *
    * @see junit.framework.TestCase#tearDown()
    */
-  protected void tearDown() throws Exception {
+  public void tearDown() throws SQLException {
     Statement stmt = con.createStatement();
     stmt.execute("drop function Numeric_Proc(out decimal, out decimal, out decimal)");
     stmt.execute("drop function test_somein_someout(int4)");
@@ -102,10 +104,12 @@ protected void tearDown() throws Exception {
     stmt.execute("drop function myiofunc(a INOUT int, b OUT int) ");
     stmt.execute("drop function myif(a INOUT int, b IN int)");
     stmt.close();
-    TestUtil.closeDB(con);
+    super.tearDown();
   }
 
+  @Test
   public void testSomeInOut() throws Throwable {
+    assumeCallableStatementsSupported();
     CallableStatement call = con.prepareCall("{ call test_somein_someout(?,?,?) }");
 
     call.registerOutParameter(2, Types.VARCHAR);
@@ -115,8 +119,10 @@ public void testSomeInOut() throws Throwable {
 
   }
 
+  @Test
   public void testNotEnoughParameters() throws Throwable {
 
+    assumeCallableStatementsSupported();
     CallableStatement cs = con.prepareCall("{call myiofunc(?,?)}");
     cs.setInt(1, 2);
     cs.registerOutParameter(2, Types.INTEGER);
@@ -129,6 +135,7 @@ public void testNotEnoughParameters() throws Throwable {
 
   }
 
+  @Test
   public void testTooManyParameters() throws Throwable {
 
     CallableStatement cs = con.prepareCall("{call myif(?,?)}");
@@ -145,6 +152,7 @@ public void testTooManyParameters() throws Throwable {
 
   }
 
+  @Test
   public void testAllInOut() throws Throwable {
 
     CallableStatement call = con.prepareCall("{ call test_allinout(?,?,?) }");
@@ -162,7 +170,9 @@ public void testAllInOut() throws Throwable {
 
   }
 
+  @Test
   public void testNumeric() throws Throwable {
+    assumeCallableStatementsSupported();
 
     CallableStatement call = con.prepareCall("{ call Numeric_Proc(?,?,?) }");
 
@@ -189,7 +199,9 @@ public void testNumeric() throws Throwable {
 
   }
 
+  @Test
   public void testGetObjectDecimal() throws Throwable {
+    assumeCallableStatementsSupported();
     try {
       Statement stmt = con.createStatement();
       stmt.execute(
@@ -233,6 +245,7 @@ public void testGetObjectDecimal() throws Throwable {
     }
   }
 
+  @Test
   public void testVarcharBool() throws Throwable {
     try {
       Statement stmt = con.createStatement();
@@ -276,6 +289,7 @@ public void testVarcharBool() throws Throwable {
     }
   }
 
+  @Test
   public void testInOut() throws Throwable {
     try {
       Statement stmt = con.createStatement();
@@ -321,6 +335,7 @@ public void testInOut() throws Throwable {
       "create temp table bit_tab ( max_val boolean, min_val boolean, null_val boolean )";
   private final String insertBitTab = "insert into bit_tab values (true,false,null)";
 
+  @Test
   public void testSetObjectBit() throws Throwable {
     try {
       Statement stmt = con.createStatement();
@@ -364,7 +379,9 @@ public void testSetObjectBit() throws Throwable {
     }
   }
 
+  @Test
   public void testGetObjectLongVarchar() throws Throwable {
+    assumeCallableStatementsSupported();
     try {
       Statement stmt = con.createStatement();
       stmt.execute("create temp table longvarchar_tab ( t text, null_val text )");
@@ -421,7 +438,9 @@ public void testGetObjectLongVarchar() throws Throwable {
     }
   }
 
+  @Test
   public void testGetBytes01() throws Throwable {
+    assumeByteaSupported();
     byte[] testdata = "TestData".getBytes();
     try {
       Statement stmt = con.createStatement();
@@ -507,6 +526,7 @@ public void testGetBytes01() throws Throwable {
   private final float[] realValues = {(float) 1.0E37, (float) 1.0E-37};
   private final int[] intValues = {2147483647, -2147483648};
 
+  @Test
   public void testUpdateReal() throws Throwable {
     try {
       Statement stmt = con.createStatement();
@@ -551,6 +571,7 @@ public void testUpdateReal() throws Throwable {
     }
   }
 
+  @Test
   public void testUpdateDecimal() throws Throwable {
     try {
       Statement stmt = con.createStatement();
@@ -590,7 +611,9 @@ public void testUpdateDecimal() throws Throwable {
     }
   }
 
+  @Test
   public void testGetBytes02() throws Throwable {
+    assumeByteaSupported();
     byte[] testdata = "TestData".getBytes();
     try {
       Statement stmt = con.createStatement();
@@ -638,7 +661,9 @@ public void testGetBytes02() throws Throwable {
   }
 
 
+  @Test
   public void testGetObjectFloat() throws Throwable {
+    assumeCallableStatementsSupported();
     try {
       Statement stmt = con.createStatement();
       stmt.execute(createDecimalTab);
@@ -673,7 +698,9 @@ public void testGetObjectFloat() throws Throwable {
     }
   }
 
+  @Test
   public void testGetDouble01() throws Throwable {
+    assumeCallableStatementsSupported();
     try {
       Statement stmt = con.createStatement();
       stmt.execute("create temp table d_tab ( max_val float, min_val float, null_val float )");
@@ -712,7 +739,9 @@ public void testGetDouble01() throws Throwable {
     }
   }
 
+  @Test
   public void testGetDoubleAsReal() throws Throwable {
+    assumeCallableStatementsSupported();
     try {
       Statement stmt = con.createStatement();
       stmt.execute("create temp table d_tab ( max_val float, min_val float, null_val float )");
@@ -751,7 +780,9 @@ public void testGetDoubleAsReal() throws Throwable {
     }
   }
 
+  @Test
   public void testGetShort01() throws Throwable {
+    assumeCallableStatementsSupported();
     try {
       Statement stmt = con.createStatement();
       stmt.execute("create temp table short_tab ( max_val int2, min_val int2, null_val int2 )");
@@ -790,7 +821,9 @@ public void testGetShort01() throws Throwable {
     }
   }
 
+  @Test
   public void testGetInt01() throws Throwable {
+    assumeCallableStatementsSupported();
     try {
       Statement stmt = con.createStatement();
       stmt.execute("create temp table i_tab ( max_val int, min_val int, null_val int )");
@@ -829,7 +862,9 @@ public void testGetInt01() throws Throwable {
     }
   }
 
+  @Test
   public void testGetLong01() throws Throwable {
+    assumeCallableStatementsSupported();
     try {
       Statement stmt = con.createStatement();
       stmt.execute("create temp table l_tab ( max_val int8, min_val int8, null_val int8 )");
@@ -868,7 +903,9 @@ public void testGetLong01() throws Throwable {
     }
   }
 
+  @Test
   public void testGetBoolean01() throws Throwable {
+    assumeCallableStatementsSupported();
     try {
       Statement stmt = con.createStatement();
       stmt.execute(createBitTab);
@@ -907,7 +944,9 @@ public void testGetBoolean01() throws Throwable {
     }
   }
 
+  @Test
   public void testGetByte01() throws Throwable {
+    assumeCallableStatementsSupported();
     try {
       Statement stmt = con.createStatement();
       stmt.execute("create temp table byte_tab ( max_val int2, min_val int2, null_val int2 )");
@@ -946,7 +985,9 @@ public void testGetByte01() throws Throwable {
     }
   }
 
+  @Test
   public void testMultipleOutExecutions() throws SQLException {
+    assumeCallableStatementsSupported();
     CallableStatement cs = con.prepareCall("{call myiofunc(?, ?)}");
     for (int i = 0; i < 10; i++) {
       cs.registerOutParameter(1, Types.INTEGER);
@@ -959,7 +1000,9 @@ public void testMultipleOutExecutions() throws SQLException {
     }
   }
 
+  @Test
   public void testSum() throws SQLException {
+    assumeCallableStatementsSupported();
     CallableStatement cs = con.prepareCall("{?= call mysum(?, ?)}");
     cs.registerOutParameter(1, Types.INTEGER);
     cs.setInt(2, 2);
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc3/Jdbc3TestSuite.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc3/Jdbc3TestSuite.java
index 5119f03b17..66f78d80f0 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc3/Jdbc3TestSuite.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc3/Jdbc3TestSuite.java
@@ -10,6 +10,7 @@
 
 import org.postgresql.test.TestUtil;
 
+import junit.framework.JUnit4TestAdapter;
 import junit.framework.TestSuite;
 
 /*
@@ -27,10 +28,10 @@ public static TestSuite suite() throws Exception {
       java.sql.Connection con = TestUtil.openDB();
 
       if (TestUtil.haveMinimumServerVersion(con, "8.1") && TestUtil.isProtocolVersion(con, 3)) {
-        suite.addTestSuite(Jdbc3CallableStatementTest.class);
+        suite.addTest(new JUnit4TestAdapter(Jdbc3CallableStatementTest.class));
       }
       if (TestUtil.haveMinimumServerVersion(con, "8.2")) {
-        suite.addTestSuite(GeneratedKeysTest.class);
+        suite.addTest(new JUnit4TestAdapter(GeneratedKeysTest.class));
       }
       con.close();
     } catch (Exception ex) {
@@ -38,9 +39,9 @@ public static TestSuite suite() throws Exception {
     }
     suite.addTestSuite(CompositeQueryParseTest.class);
     suite.addTestSuite(Jdbc3SavepointTest.class);
-    suite.addTestSuite(TypesTest.class);
+    suite.addTest(new JUnit4TestAdapter(TypesTest.class));
     suite.addTestSuite(ResultSetTest.class);
-    suite.addTestSuite(ParameterMetaDataTest.class);
+    suite.addTest(new JUnit4TestAdapter(ParameterMetaDataTest.class));
     suite.addTestSuite(Jdbc3BlobTest.class);
     suite.addTestSuite(DatabaseMetaDataTest.class);
     suite.addTestSuite(SendRecvBufferSizeTest.class);
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc3/ParameterMetaDataTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc3/ParameterMetaDataTest.java
index 9ecd051fad..74cbcb833d 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc3/ParameterMetaDataTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc3/ParameterMetaDataTest.java
@@ -8,11 +8,16 @@
 
 package org.postgresql.test.jdbc3;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+import org.postgresql.jdbc.PreferQueryMode;
 import org.postgresql.test.TestUtil;
+import org.postgresql.test.jdbc2.BaseTest4;
 
-import junit.framework.TestCase;
+import org.junit.Assume;
+import org.junit.Test;
 
-import java.sql.Connection;
 import java.sql.ParameterMetaData;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
@@ -20,32 +25,31 @@
 import java.sql.Timestamp;
 import java.sql.Types;
 
-public class ParameterMetaDataTest extends TestCase {
-
-  private Connection _conn;
-
-  public ParameterMetaDataTest(String name) {
-    super(name);
-  }
+public class ParameterMetaDataTest extends BaseTest4 {
 
-  protected void setUp() throws Exception {
-    _conn = TestUtil.openDB();
-    TestUtil.createTable(_conn, "parametertest",
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    Assume.assumeTrue("simple protocol only does not support describe statement requests",
+        preferQueryMode != PreferQueryMode.SIMPLE);
+    TestUtil.createTable(con, "parametertest",
         "a int4, b float8, c text, d point, e timestamp with time zone");
   }
 
-  protected void tearDown() throws SQLException {
-    TestUtil.dropTable(_conn, "parametertest");
-    TestUtil.closeDB(_conn);
+  @Override
+  public void tearDown() throws SQLException {
+    TestUtil.dropTable(con, "parametertest");
+    super.tearDown();
   }
 
+  @Test
   public void testParameterMD() throws SQLException {
-    if (!TestUtil.isProtocolVersion(_conn, 3)) {
+    if (!TestUtil.isProtocolVersion(con, 3)) {
       return;
     }
 
     PreparedStatement pstmt =
-        _conn.prepareStatement("SELECT a FROM parametertest WHERE b = ? AND c = ? AND d >^ ? ");
+        con.prepareStatement("SELECT a FROM parametertest WHERE b = ? AND c = ? AND d >^ ? ");
     ParameterMetaData pmd = pstmt.getParameterMetaData();
 
     assertEquals(3, pmd.getParameterCount());
@@ -62,13 +66,14 @@ public void testParameterMD() throws SQLException {
     pstmt.close();
   }
 
+  @Test
   public void testFailsOnBadIndex() throws SQLException {
-    if (!TestUtil.isProtocolVersion(_conn, 3)) {
+    if (!TestUtil.isProtocolVersion(con, 3)) {
       return;
     }
 
     PreparedStatement pstmt =
-        _conn.prepareStatement("SELECT a FROM parametertest WHERE b = ? AND c = ?");
+        con.prepareStatement("SELECT a FROM parametertest WHERE b = ? AND c = ?");
     ParameterMetaData pmd = pstmt.getParameterMetaData();
     try {
       pmd.getParameterType(0);
@@ -83,12 +88,13 @@ public void testFailsOnBadIndex() throws SQLException {
   }
 
   // Make sure we work when mashing two queries into a single statement.
+  @Test
   public void testMultiStatement() throws SQLException {
-    if (!TestUtil.isProtocolVersion(_conn, 3)) {
+    if (!TestUtil.isProtocolVersion(con, 3)) {
       return;
     }
 
-    PreparedStatement pstmt = _conn.prepareStatement(
+    PreparedStatement pstmt = con.prepareStatement(
         "SELECT a FROM parametertest WHERE b = ? AND c = ? ; SELECT b FROM parametertest WHERE a = ?");
     ParameterMetaData pmd = pstmt.getParameterMetaData();
 
@@ -108,13 +114,14 @@ public void testMultiStatement() throws SQLException {
   // from text to varchar with the complicating factor that there
   // is also an unknown parameter.
   //
+  @Test
   public void testTypeChangeWithUnknown() throws SQLException {
-    if (!TestUtil.isProtocolVersion(_conn, 3)) {
+    if (!TestUtil.isProtocolVersion(con, 3)) {
       return;
     }
 
     PreparedStatement pstmt =
-        _conn.prepareStatement("SELECT a FROM parametertest WHERE c = ? AND e = ?");
+        con.prepareStatement("SELECT a FROM parametertest WHERE c = ? AND e = ?");
     ParameterMetaData pmd = pstmt.getParameterMetaData();
 
     pstmt.setString(1, "Hi");
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc3/TypesTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc3/TypesTest.java
index a623d8d8b7..69bf555a65 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc3/TypesTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc3/TypesTest.java
@@ -8,9 +8,15 @@
 
 package org.postgresql.test.jdbc3;
 
-import org.postgresql.test.TestUtil;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
 
-import junit.framework.TestCase;
+import org.postgresql.jdbc.PreferQueryMode;
+import org.postgresql.test.jdbc2.BaseTest4;
+
+import org.junit.Test;
 
 import java.sql.CallableStatement;
 import java.sql.Connection;
@@ -20,34 +26,29 @@
 import java.sql.Statement;
 import java.sql.Types;
 
-public class TypesTest extends TestCase {
+public class TypesTest extends BaseTest4 {
 
   private Connection _conn;
 
-  public TypesTest(String name) {
-    super(name);
-    try {
-      Class.forName("org.postgresql.Driver");
-    } catch (Exception ex) {
-
-    }
-  }
-
-  protected void setUp() throws Exception {
-    _conn = TestUtil.openDB();
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    _conn = con;
     Statement stmt = _conn.createStatement();
     stmt.execute(
         "CREATE OR REPLACE FUNCTION return_bool(boolean) RETURNS boolean AS 'BEGIN RETURN $1; END;' LANGUAGE plpgsql");
     stmt.close();
   }
 
-  protected void tearDown() throws SQLException {
+  @Override
+  public void tearDown() throws SQLException {
     Statement stmt = _conn.createStatement();
     stmt.execute("DROP FUNCTION return_bool(boolean)");
     stmt.close();
-    TestUtil.closeDB(_conn);
+    super.tearDown();
   }
 
+  @Test
   public void testPreparedBoolean() throws SQLException {
     PreparedStatement pstmt = _conn.prepareStatement("SELECT ?,?,?,?");
     pstmt.setNull(1, Types.BOOLEAN);
@@ -63,11 +64,12 @@ public void testPreparedBoolean() throws SQLException {
     // Only the V3 protocol return will be strongly typed.
     // The V2 path will return a String because it doesn't know
     // any better.
-    if (TestUtil.isProtocolVersion(_conn, 3)) {
+    if (preferQueryMode != PreferQueryMode.SIMPLE) {
       assertTrue(!((Boolean) rs.getObject(4)).booleanValue());
     }
   }
 
+  @Test
   public void testPreparedByte() throws SQLException {
     PreparedStatement pstmt = _conn.prepareStatement("SELECT ?,?");
     pstmt.setByte(1, (byte) 1);
@@ -82,7 +84,9 @@ public void testPreparedByte() throws SQLException {
     pstmt.close();
   }
 
+  @Test
   public void testCallableBoolean() throws SQLException {
+    assumeCallableStatementsSupported();
     CallableStatement cs = _conn.prepareCall("{? = call return_bool(?)}");
     cs.registerOutParameter(1, Types.BOOLEAN);
     cs.setBoolean(2, true);
@@ -91,6 +95,7 @@ public void testCallableBoolean() throws SQLException {
     cs.close();
   }
 
+  @Test
   public void testUnknownType() throws SQLException {
     Statement stmt = _conn.createStatement();
 
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc4/ArrayTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc4/ArrayTest.java
index 5bc63142ee..b828a8dbf1 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc4/ArrayTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc4/ArrayTest.java
@@ -9,12 +9,14 @@
 package org.postgresql.test.jdbc4;
 
 import org.postgresql.geometric.PGbox;
+import org.postgresql.jdbc.PreferQueryMode;
 import org.postgresql.test.TestUtil;
 import org.postgresql.test.jdbc2.BaseTest4;
 import org.postgresql.util.PGobject;
 import org.postgresql.util.PGtokenizer;
 
 import org.junit.Assert;
+import org.junit.Assume;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -113,6 +115,33 @@ public void testCreateArrayOfMultiString() throws SQLException {
     Assert.assertEquals("\"\\'z", out[1][1]);
   }
 
+  @Test
+  public void testCreateArrayOfMultiJson() throws SQLException {
+    if (!TestUtil.haveMinimumServerVersion(_conn, "9.2")) {
+      return;
+    }
+    PreparedStatement pstmt = _conn.prepareStatement("SELECT ?::json[]");
+    PGobject p1 = new PGobject();
+    p1.setType("json");
+    p1.setValue("{\"x\": 10}");
+
+    PGobject p2 = new PGobject();
+    p2.setType("json");
+    p2.setValue("{\"x\": 20}");
+    PGobject in[] = new PGobject[] { p1, p2 };
+    pstmt.setArray(1, _conn.createArrayOf("json", in));
+
+    ResultSet rs = pstmt.executeQuery();
+    Assert.assertTrue(rs.next());
+    Array arr = rs.getArray(1);
+    ResultSet arrRs = arr.getResultSet();
+    Assert.assertTrue(arrRs.next());
+    Assert.assertEquals(in[0].getValue(), arrRs.getObject(2));
+
+    Assert.assertTrue(arrRs.next());
+    Assert.assertEquals(in[1].getValue(), arrRs.getObject(2));
+  }
+
   @Test
   public void testCreateArrayWithNonStandardDelimiter() throws SQLException {
     PGbox in[] = new PGbox[2];
@@ -140,7 +169,7 @@ public void testCreateArrayOfNull() throws SQLException {
 
     String sql = "SELECT ?";
     // We must provide the type information for V2 protocol
-    if (TestUtil.isProtocolVersion(_conn, 2)) {
+    if (preferQueryMode == PreferQueryMode.SIMPLE) {
       sql = "SELECT ?::int8[]";
     }
 
@@ -217,6 +246,9 @@ public void testCreatePrimitiveArray() throws SQLException {
 
   @Test
   public void testUUIDArray() throws SQLException {
+    Assume.assumeTrue("UUID is not supported in PreferQueryMode.SIMPLE",
+        preferQueryMode != PreferQueryMode.SIMPLE);
+
     UUID uuid1 = UUID.randomUUID();
     UUID uuid2 = UUID.randomUUID();
     UUID uuid3 = UUID.randomUUID();
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc4/BinaryStreamTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc4/BinaryStreamTest.java
index c6138e5e23..905b6ac49a 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc4/BinaryStreamTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc4/BinaryStreamTest.java
@@ -1,27 +1,27 @@
 package org.postgresql.test.jdbc4;
 
 import org.postgresql.test.TestUtil;
+import org.postgresql.test.jdbc2.BaseTest4;
 
-import junit.framework.TestCase;
 import org.junit.Assert;
+import org.junit.Test;
 
 import java.io.ByteArrayInputStream;
 import java.nio.ByteBuffer;
-import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.Random;
 
-public class BinaryStreamTest extends TestCase {
-
-  private Connection _conn;
+public class BinaryStreamTest extends BaseTest4 {
 
   private ByteBuffer _testData;
 
-  protected void setUp() throws Exception {
-    _conn = TestUtil.openDB();
-    TestUtil.createTable(_conn, "images", "img bytea");
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    assumeByteaSupported();
+    TestUtil.createTable(con, "images", "img bytea");
 
     Random random = new Random(31459);
     _testData = ByteBuffer.allocate(200 * 1024);
@@ -30,13 +30,14 @@ protected void setUp() throws Exception {
     }
   }
 
-  protected void tearDown() throws SQLException {
-    TestUtil.dropTable(_conn, "images");
-    TestUtil.closeDB(_conn);
+  @Override
+  public void tearDown() throws SQLException {
+    TestUtil.dropTable(con, "images");
+    super.tearDown();
   }
 
   private void insertStreamKownLength(byte[] data) throws Exception {
-    PreparedStatement updatePS = _conn.prepareStatement(TestUtil.insertSQL("images", "img", "?"));
+    PreparedStatement updatePS = con.prepareStatement(TestUtil.insertSQL("images", "img", "?"));
     try {
       updatePS.setBinaryStream(1, new ByteArrayInputStream(data), data.length);
       updatePS.executeUpdate();
@@ -46,7 +47,7 @@ private void insertStreamKownLength(byte[] data) throws Exception {
   }
 
   private void insertStreamUnkownLength(byte[] data) throws Exception {
-    PreparedStatement updatePS = _conn.prepareStatement(TestUtil.insertSQL("images", "img", "?"));
+    PreparedStatement updatePS = con.prepareStatement(TestUtil.insertSQL("images", "img", "?"));
     try {
       updatePS.setBinaryStream(1, new ByteArrayInputStream(data));
       updatePS.executeUpdate();
@@ -56,7 +57,7 @@ private void insertStreamUnkownLength(byte[] data) throws Exception {
   }
 
   private void validateContent(byte[] data) throws Exception {
-    PreparedStatement selectPS = _conn.prepareStatement(TestUtil.selectSQL("images", "img"));
+    PreparedStatement selectPS = con.prepareStatement(TestUtil.selectSQL("images", "img"));
     try {
       ResultSet rs = selectPS.executeQuery();
       try {
@@ -70,7 +71,7 @@ private void validateContent(byte[] data) throws Exception {
       selectPS.close();
     }
 
-    PreparedStatement deletePS = _conn.prepareStatement("DELETE FROM images");
+    PreparedStatement deletePS = con.prepareStatement("DELETE FROM images");
     try {
       deletePS.executeUpdate();
     } finally {
@@ -85,60 +86,70 @@ private byte[] getTestData(int size) {
     return data;
   }
 
+  @Test
   public void testKnownLengthEmpty() throws Exception {
     byte[] data = new byte[0];
     insertStreamKownLength(data);
     validateContent(data);
   }
 
+  @Test
   public void testKnownLength2Kb() throws Exception {
     byte[] data = getTestData(2 * 1024);
     insertStreamKownLength(data);
     validateContent(data);
   }
 
+  @Test
   public void testKnownLength10Kb() throws Exception {
     byte[] data = getTestData(10 * 1024);
     insertStreamKownLength(data);
     validateContent(data);
   }
 
+  @Test
   public void testKnownLength100Kb() throws Exception {
     byte[] data = getTestData(100 * 1024);
     insertStreamKownLength(data);
     validateContent(data);
   }
 
+  @Test
   public void testKnownLength200Kb() throws Exception {
     byte[] data = getTestData(200 * 1024);
     insertStreamKownLength(data);
     validateContent(data);
   }
 
+  @Test
   public void testUnknownLengthEmpty() throws Exception {
     byte[] data = getTestData(2 * 1024);
     insertStreamUnkownLength(data);
     validateContent(data);
   }
 
+  @Test
   public void testUnknownLength2Kb() throws Exception {
     byte[] data = getTestData(2 * 1024);
     insertStreamUnkownLength(data);
     validateContent(data);
   }
 
+  @Test
   public void testUnknownLength10Kb() throws Exception {
     byte[] data = getTestData(10 * 1024);
     insertStreamUnkownLength(data);
     validateContent(data);
   }
 
+  @Test
   public void testUnknownLength100Kb() throws Exception {
     byte[] data = getTestData(100 * 1024);
     insertStreamUnkownLength(data);
     validateContent(data);
   }
 
+  @Test
   public void testUnknownLength200Kb() throws Exception {
     byte[] data = getTestData(200 * 1024);
     insertStreamUnkownLength(data);
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc4/BinaryTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc4/BinaryTest.java
index 145710d980..7dfeca66fb 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc4/BinaryTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc4/BinaryTest.java
@@ -1,14 +1,17 @@
 package org.postgresql.test.jdbc4;
 
+import static org.junit.Assert.assertEquals;
+
 import org.postgresql.PGConnection;
 import org.postgresql.PGResultSetMetaData;
 import org.postgresql.PGStatement;
 import org.postgresql.core.Field;
-import org.postgresql.test.TestUtil;
+import org.postgresql.jdbc.PreferQueryMode;
+import org.postgresql.test.jdbc2.BaseTest4;
 
-import junit.framework.TestCase;
+import org.junit.Assume;
+import org.junit.Test;
 
-import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
@@ -19,28 +22,21 @@
  * {@link PGConnection#setPrepareThreshold(int)} then we'll change to using the binary protocol to
  * save bandwidth and reduce decoding time.
  */
-public class BinaryTest extends TestCase {
-  private Connection connection;
+public class BinaryTest extends BaseTest4 {
   private ResultSet results;
   private PreparedStatement statement;
 
-  public BinaryTest(String name) {
-    super(name);
-  }
-
   @Override
-  protected void setUp() throws Exception {
-    connection = TestUtil.openDB();
-    statement = connection.prepareStatement("select 1");
+  public void setUp() throws Exception {
+    super.setUp();
+    Assume.assumeTrue("Server-prepared statements are not supported in 'simple protocol only'",
+        preferQueryMode != PreferQueryMode.SIMPLE);
+    statement = con.prepareStatement("select 1");
 
     ((PGStatement) statement).setPrepareThreshold(5);
   }
 
-  @Override
-  protected void tearDown() throws Exception {
-    TestUtil.closeDB(connection);
-  }
-
+  @Test
   public void testPreparedStatement_3() throws Exception {
     ((PGStatement) statement).setPrepareThreshold(3);
 
@@ -59,6 +55,7 @@ public void testPreparedStatement_3() throws Exception {
     ((PGStatement) statement).setPrepareThreshold(5);
   }
 
+  @Test
   public void testPreparedStatement_1() throws Exception {
     ((PGStatement) statement).setPrepareThreshold(1);
 
@@ -77,6 +74,7 @@ public void testPreparedStatement_1() throws Exception {
     ((PGStatement) statement).setPrepareThreshold(5);
   }
 
+  @Test
   public void testPreparedStatement_0() throws Exception {
     ((PGStatement) statement).setPrepareThreshold(0);
 
@@ -95,6 +93,7 @@ public void testPreparedStatement_0() throws Exception {
     ((PGStatement) statement).setPrepareThreshold(5);
   }
 
+  @Test
   public void testPreparedStatement_negative1() throws Exception {
     ((PGStatement) statement).setPrepareThreshold(-1);
 
@@ -113,8 +112,9 @@ public void testPreparedStatement_negative1() throws Exception {
     ((PGStatement) statement).setPrepareThreshold(5);
   }
 
+  @Test
   public void testReceiveBinary() throws Exception {
-    PreparedStatement ps = connection.prepareStatement("select ?");
+    PreparedStatement ps = con.prepareStatement("select ?");
     for (int i = 0; i < 10; i++) {
       ps.setInt(1, 42 + i);
       ResultSet rs = ps.executeQuery();
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc4/IsValidTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc4/IsValidTest.java
index 72449e1b22..d8b958db59 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc4/IsValidTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc4/IsValidTest.java
@@ -1,6 +1,7 @@
 package org.postgresql.test.jdbc4;
 
 import org.postgresql.core.BaseConnection;
+import org.postgresql.core.TransactionState;
 import org.postgresql.test.TestUtil;
 
 import junit.framework.TestCase;
@@ -11,7 +12,7 @@
 
 public class IsValidTest extends TestCase {
 
-  private int getTransactionState(Connection conn) {
+  private TransactionState getTransactionState(Connection conn) {
     return ((BaseConnection) conn).getTransactionState();
   }
 
@@ -31,7 +32,7 @@ public void testIsValid() throws Exception {
   public void testTransactionState() throws Exception {
     Connection conn = TestUtil.openDB();
     try {
-      int transactionState;
+      TransactionState transactionState;
       transactionState = getTransactionState(conn);
       conn.isValid(0);
       Assert.assertEquals("Transaction state has been changed", transactionState,
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc4/Jdbc4TestSuite.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc4/Jdbc4TestSuite.java
index b042a322b3..8acc61b607 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc4/Jdbc4TestSuite.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc4/Jdbc4TestSuite.java
@@ -33,17 +33,17 @@ public static TestSuite suite() throws Exception {
     suite.addTestSuite(DatabaseMetaDataTest.class);
     suite.addTest(new JUnit4TestAdapter(ArrayTest.class));
     suite.addTestSuite(WrapperTest.class);
-    suite.addTestSuite(BinaryTest.class);
+    suite.addTest(new JUnit4TestAdapter(BinaryTest.class));
     suite.addTestSuite(IsValidTest.class);
     suite.addTestSuite(ClientInfoTest.class);
     suite.addTestSuite(PGCopyInputStreamTest.class);
     suite.addTestSuite(BlobTest.class);
-    suite.addTestSuite(BinaryStreamTest.class);
+    suite.addTest(new JUnit4TestAdapter(BinaryStreamTest.class));
 
     Connection connection = TestUtil.openDB();
     try {
       if (TestUtil.haveMinimumServerVersion(connection, "8.3")) {
-        suite.addTestSuite(UUIDTest.class);
+        suite.addTest(new JUnit4TestAdapter(UUIDTest.class));
         if (isXmlEnabled(connection)) {
           suite.addTestSuite(XmlTest.class);
         }
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc4/UUIDTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc4/UUIDTest.java
index f2fec5b06e..a7dc01171e 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc4/UUIDTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc4/UUIDTest.java
@@ -8,11 +8,13 @@
 
 package org.postgresql.test.jdbc4;
 
-import org.postgresql.test.TestUtil;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
-import junit.framework.TestCase;
+import org.postgresql.test.jdbc2.BaseTest4;
+
+import org.junit.Test;
 
-import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
@@ -20,36 +22,33 @@
 import java.sql.Types;
 import java.util.UUID;
 
-public class UUIDTest extends TestCase {
-
-  private Connection _conn;
-
-  public UUIDTest(String name) {
-    super(name);
-  }
+public class UUIDTest extends BaseTest4 {
 
-  protected void setUp() throws Exception {
-    _conn = TestUtil.openDB();
-    Statement stmt = _conn.createStatement();
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    Statement stmt = con.createStatement();
     stmt.execute("CREATE TEMP TABLE uuidtest(id uuid)");
     stmt.close();
   }
 
-  protected void tearDown() throws SQLException {
-    Statement stmt = _conn.createStatement();
+  @Override
+  public void tearDown() throws SQLException {
+    Statement stmt = con.createStatement();
     stmt.execute("DROP TABLE uuidtest");
     stmt.close();
-    TestUtil.closeDB(_conn);
+    super.tearDown();
   }
 
+  @Test
   public void testUUID() throws SQLException {
     UUID uuid = UUID.randomUUID();
-    PreparedStatement ps = _conn.prepareStatement("INSERT INTO uuidtest VALUES (?)");
+    PreparedStatement ps = con.prepareStatement("INSERT INTO uuidtest VALUES (?)");
     ps.setObject(1, uuid, Types.OTHER);
     ps.executeUpdate();
     ps.close();
 
-    Statement stmt = _conn.createStatement();
+    Statement stmt = con.createStatement();
     ResultSet rs = stmt.executeQuery("SELECT id FROM uuidtest");
     assertTrue(rs.next());
 
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc4/jdbc41/SchemaTest.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc4/jdbc41/SchemaTest.java
index 975a32fa82..25d5daa560 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc4/jdbc41/SchemaTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc4/jdbc41/SchemaTest.java
@@ -13,8 +13,12 @@
 import junit.framework.TestCase;
 
 import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.ResultSetMetaData;
 import java.sql.SQLException;
 import java.sql.Statement;
+import java.sql.Types;
 import java.util.Properties;
 
 public class SchemaTest extends TestCase {
@@ -46,9 +50,12 @@ protected void setUp() throws Exception {
     TestUtil.createTable(_conn, "schema1.table1", "id integer");
     TestUtil.createTable(_conn, "schema2.table2", "id integer");
     TestUtil.createTable(_conn, "\"UpperCase\".table3", "id integer");
+    TestUtil.createTable(_conn, "schema1.sptest", "id integer");
+    TestUtil.createTable(_conn, "schema2.sptest", "id varchar");
   }
 
   protected void tearDown() throws SQLException {
+    _conn.setAutoCommit(true);
     _conn.setSchema(null);
     Statement stmt = _conn.createStatement();
     if (dropUserSchema) {
@@ -179,4 +186,38 @@ private void execute(String sql) throws SQLException {
     }
   }
 
+  public void testSearchPathPreparedStatementAutoCommitFalse() throws SQLException {
+    _conn.setAutoCommit(false);
+    testSearchPathPreparedStatement();
+  }
+
+  public void testSearchPathPreparedStatementAutoCommitTrue() throws SQLException {
+    testSearchPathPreparedStatement();
+  }
+
+  public void testSearchPathPreparedStatement() throws SQLException {
+    execute("set search_path to schema1,public");
+    PreparedStatement ps = _conn.prepareStatement("select * from sptest");
+    for (int i = 0; i < 10; i++) {
+      ps.execute();
+    }
+    assertColType(ps, "sptest should point to schema1.sptest, thus column type should be INT",
+        Types.INTEGER);
+    ps.close();
+    execute("set search_path to schema2,public");
+    ps = _conn.prepareStatement("select * from sptest");
+    assertColType(ps, "sptest should point to schema2.sptest, thus column type should be VARCHAR",
+        Types.VARCHAR);
+    ps.close();
+  }
+
+  private void assertColType(PreparedStatement ps, String message, int expected) throws SQLException {
+    ResultSet rs = ps.executeQuery();
+    ResultSetMetaData md = rs.getMetaData();
+    int columnType = md.getColumnType(1);
+    assertEquals(message,
+        expected, columnType);
+    rs.close();
+  }
+
 }
diff --git a/pgjdbc/src/test/java/org/postgresql/test/jdbc42/SimpleJdbc42Test.java b/pgjdbc/src/test/java/org/postgresql/test/jdbc42/SimpleJdbc42Test.java
index 46b80ae3df..ae169c5b83 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/jdbc42/SimpleJdbc42Test.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/jdbc42/SimpleJdbc42Test.java
@@ -8,6 +8,8 @@
 
 package org.postgresql.test.jdbc42;
 
+import static org.junit.Assert.assertTrue;
+
 import org.postgresql.test.TestUtil;
 
 import org.junit.After;
@@ -37,7 +39,7 @@ public void tearDown() throws Exception {
    * Test presence of JDBC 4.2 specific methods
    */
   @Test
-  public void testDatabaseMetaData() throws Exception {
-    _conn.getMetaData().supportsRefCursors();
+  public void testSupportsRefCursors() throws Exception {
+    assertTrue(_conn.getMetaData().supportsRefCursors());
   }
 }
diff --git a/pgjdbc/src/test/java/org/postgresql/test/util/LruCacheTest.java b/pgjdbc/src/test/java/org/postgresql/test/util/LruCacheTest.java
index e3da341050..54ded3abb3 100644
--- a/pgjdbc/src/test/java/org/postgresql/test/util/LruCacheTest.java
+++ b/pgjdbc/src/test/java/org/postgresql/test/util/LruCacheTest.java
@@ -48,7 +48,7 @@ public String toString() {
 
   @Override
   protected void setUp() throws Exception {
-    cache = new LruCache<Integer, Entry>(3, 1000, false, new LruCache.CreateAction<Integer, Entry>() {
+    cache = new LruCache<Integer, Entry>(4, 1000, false, new LruCache.CreateAction<Integer, Entry>() {
       @Override
       public Entry create(Integer key) throws SQLException {
         assertEquals("Unexpected create", expectCreate[0], key);
@@ -57,6 +57,9 @@ public Entry create(Integer key) throws SQLException {
     }, new LruCache.EvictAction<Entry>() {
       @Override
       public void evict(Entry entry) throws SQLException {
+        if (expectEvict.isEmpty()) {
+          fail("Unexpected entry was evicted: " + entry);
+        }
         Entry expected = expectEvict.removeFirst();
         assertEquals("Unexpected evict", expected, entry);
       }
@@ -68,25 +71,24 @@ public void testEvictsByNumberOfEntries() throws SQLException {
     Entry b;
     Entry c;
     Entry d;
+    Entry e;
 
-    a = use(1, dummy);
-    b = use(2, dummy);
-    c = use(3, dummy);
-    d = use(4, a);
+    a = use(1);
+    b = use(2);
+    c = use(3);
+    d = use(4);
+    e = use(5, a);
   }
 
   public void testEvictsBySize() throws SQLException {
     Entry a;
     Entry b;
     Entry c;
-    Entry d;
 
-    a = use(3, dummy);
-    b = use(5, dummy);
-    c = use((int) (1000 - a.getSize() - b.getSize()), dummy);
-    // Now cache holds exactly 1000 bytes.
-    // a and b should be evicted
-    d = use(4, a, b);
+    a = use(330);
+    b = use(331);
+    c = use(332);
+    use(400, a, b);
   }
 
   public void testEvictsLeastRecentlyUsed() throws SQLException {
@@ -95,10 +97,11 @@ public void testEvictsLeastRecentlyUsed() throws SQLException {
     Entry c;
     Entry d;
 
-    a = use(1, dummy);
-    b = use(2, dummy);
-    c = use(3, dummy);
-    a = use(1, dummy); // reuse a
+    a = use(1);
+    b = use(2);
+    c = use(3);
+    a = use(1); // reuse a
+    use(5);
     d = use(4, b); // expect b to be evicted
   }
 
@@ -107,37 +110,55 @@ public void testCyclicReplacement() throws SQLException {
     Entry b;
     Entry c;
     Entry d;
+    Entry e;
 
-    a = use(1, dummy);
-    b = use(2, dummy);
-    c = use(3, dummy);
-    d = use(4, a);
+    a = use(1);
+    b = use(2);
+    c = use(3);
+    d = use(4);
+    e = use(5, a);
 
-    for (int i = 0; i < 100000; i++) {
+    for (int i = 0; i < 1000; i++) {
       a = use(1, b);
       b = use(2, c);
       c = use(3, d);
-      d = use(4, a);
+      d = use(4, e);
+      e = use(5, a);
     }
   }
 
+  public void testDuplicateKey() throws SQLException {
+    Entry a;
+
+    a = use(1);
+    expectEvict.clear();
+    expectEvict.add(a);
+    // This overwrites the cache, evicting previous entry with exactly the same key
+    cache.put(1, new Entry(1));
+    assertEvict();
+  }
+
   public void testCaching() throws SQLException {
     Entry a;
     Entry b;
     Entry c;
     Entry d;
-
-    a = use(1, dummy);
-    b = use(2, dummy);
-    c = use(3, dummy);
-
-    for (int i = 0; i < 100000; i++) {
-      b = use(-2, dummy);
-      a = use(-1, dummy);
-      d = use(4, c);
-      b = use(-2, dummy);
-      a = use(-1, dummy);
-      c = use(3, d);
+    Entry e;
+
+    a = use(1);
+    b = use(2);
+    c = use(3);
+    d = use(4);
+
+    for (int i = 0; i < 10000; i++) {
+      c = use(-3);
+      b = use(-2);
+      a = use(-1);
+      e = use(5, d);
+      c = use(-3);
+      b = use(-2);
+      a = use(-1);
+      d = use(4, e);
     }
   }
 
@@ -147,6 +168,14 @@ private Entry use(int expectCreate, Entry... expectEvict) throws SQLException {
     this.expectEvict.addAll(Arrays.asList(expectEvict));
     Entry a = cache.borrow(Math.abs(expectCreate));
     cache.put(a.id, a); // a
+    assertEvict();
     return a;
   }
+
+  private void assertEvict() {
+    if (expectEvict.isEmpty()) {
+      return;
+    }
+    fail("Some of the expected evictions not happened: " + expectEvict.toString());
+  }
 }
diff --git a/pgjdbc/src/test/java/org/postgresql/test/util/ServerVersionParseTest.java b/pgjdbc/src/test/java/org/postgresql/test/util/ServerVersionParseTest.java
new file mode 100644
index 0000000000..6aa00763a1
--- /dev/null
+++ b/pgjdbc/src/test/java/org/postgresql/test/util/ServerVersionParseTest.java
@@ -0,0 +1,90 @@
+package org.postgresql.test.util;
+
+import org.postgresql.core.ServerVersion;
+import org.postgresql.core.Version;
+
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.Arrays;
+
+@RunWith(Parameterized.class)
+public class ServerVersionParseTest {
+
+  private final String versionString;
+  private final int versionNum;
+  private final String rejectReason;
+
+  public ServerVersionParseTest(String versionString, int versionNum, String rejectReason) {
+    this.versionString = versionString;
+    this.versionNum = versionNum;
+    this.rejectReason = rejectReason;
+  }
+
+  @Parameterized.Parameters(name = "str = {0}, expected = {1}")
+  public static Iterable<Object[]> data() {
+    return Arrays.asList(new Object[][]{
+        {"7.4.0", 70400, null},
+        {"9.0.0", 90000, null},
+        {"9.0.1", 90001, null},
+        {"9.2.1", 90201, null},
+        /* Major only */
+        {"7.4", 70400, null},
+        {"9.0", 90000, null},
+        {"9.2", 90200, null},
+        {"9.6", 90600, null},
+        {"10", 100000, null},
+        {"11", 110000, null},
+        /* Multidigit */
+        {"9.4.10", 90410, null},
+        {"9.20.10", 92010, null},
+        /* After 10 */
+        {"10.1", 100001, null},
+        {"10.10", 100010, null},
+        {"11.1", 110001, null},
+        {"123.20", 1230020, null},
+        /* Fail cases */
+        {"9.20.100", -1, "Should've rejected three-digit minor version"},
+        {"9.100.10", -1, "Should've rejected three-digit second part of major version"},
+        {"10.100.10", -1, "10+ version should have 2 components only"},
+        {"12345.1", -1, "Too big version number"},
+        /* Preparsed */
+        {"90104", 90104, null},
+        {"090104", 90104, null},
+        {"070400", 70400, null},
+        {"100004", 100004, null},
+        {"10000", 10000, null},
+        /* --with-extra-version or beta/devel tags */
+        {"9.4devel", 90400, null},
+        {"9.4beta1", 90400, null},
+        {"10devel", 100000, null},
+        {"10beta1", 100000, null},
+        {"10.1devel", 100001, null},
+        {"10.1beta1", 100001, null},
+        {"9.4.1bobs", 90401, null},
+        {"9.4.1bobspatched9.4", 90401, null},
+        {"9.4.1-bobs-patched-postgres-v2.2", 90401, null},
+
+    });
+  }
+
+  @Test
+  public void run() {
+    try {
+      Version version = ServerVersion.from(versionString);
+      if (rejectReason == null) {
+        Assert.assertEquals("Parsing " + versionString, versionNum, version.getVersionNum());
+      } else {
+        Assert.fail("Should fail to parse " + versionString + ", " + rejectReason);
+      }
+    } catch (NumberFormatException e) {
+      if (rejectReason != null) {
+        return;
+      }
+      throw e;
+    }
+  }
+
+}
diff --git a/pgjdbc/src/test/java/org/postgresql/test/util/ServerVersionTest.java b/pgjdbc/src/test/java/org/postgresql/test/util/ServerVersionTest.java
new file mode 100644
index 0000000000..3315e2010b
--- /dev/null
+++ b/pgjdbc/src/test/java/org/postgresql/test/util/ServerVersionTest.java
@@ -0,0 +1,19 @@
+package org.postgresql.test.util;
+
+import org.postgresql.core.ServerVersion;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+public class ServerVersionTest {
+  @Test
+  public void versionIncreases() {
+    ServerVersion prev = null;
+    for (ServerVersion serverVersion : ServerVersion.values()) {
+      if (prev != null) {
+        Assert.assertTrue(prev + " should be less than " + serverVersion,
+            prev.getVersionNum() < serverVersion.getVersionNum());
+      }
+    }
+  }
+}
diff --git a/pom.xml b/pom.xml
index 70e9b2d3e3..425cdd806a 100644
--- a/pom.xml
+++ b/pom.xml
@@ -3,13 +3,13 @@
   <parent>
     <groupId>org.postgresql</groupId>
     <artifactId>pgjdbc-versions</artifactId>
-    <version>1.0.8</version>
+    <version>1.1.1</version>
   </parent>
 
   <artifactId>pgjdbc-aggregate</artifactId>
   <packaging>pom</packaging>
   <name>PostgreSQL JDBC Driver aggregate</name>
-  <version>9.4.1209</version>
+  <version>9.4.1210</version>
   <description>PgJDBC aggregate project</description>
   <url>https://github.com/pgjdbc/pgjdbc</url>
 
@@ -23,7 +23,7 @@
     <url>https://github.com/pgjdbc/pgjdbc</url>
     <connection>scm:git:https://github.com/pgjdbc/pgjdbc.git</connection>
     <developerConnection>scm:git:git@github.com:pgjdbc/pgjdbc.git</developerConnection>
-    <tag>REL9.4.1209</tag>
+    <tag>REL9.4.1210</tag>
   </scm>
 
 </project>
diff --git a/release_notes.sh b/release_notes.sh
index ede514d99d..e60933cbbd 100755
--- a/release_notes.sh
+++ b/release_notes.sh
@@ -1,3 +1,15 @@
 #!/bin/sh
 
-git shortlog --format="%s@@@%H@@@%h@@@" --no-merges $1 | perl release_notes_filter.pl
+
+CURRENT_VERSION=`mvn -B -N org.apache.maven.plugins:maven-help-plugin:2.1.1:evaluate -Dexpression=project.version | grep -v '\['`
+VERS=${CURRENT_VERSION/-SNAPSHOT}
+
+PREV_VERSION=`git describe --match 'REL*' --abbrev=0`
+
+echo "<a name=\"version_${VERS}\"></a>"
+echo "## Version ${VERS} (2016-16-16)"
+echo
+echo Notable changes:
+echo
+
+git shortlog --format="%s@@@%H@@@%h@@@" --grep="maven-release-plugin|update versions in readme.md" --extended-regexp --invert-grep --no-merges $PREV_VERSION..HEAD | perl release_notes_filter.pl
diff --git a/release_notes_filter.pl b/release_notes_filter.pl
index a5a1d61b48..ed5285a59b 100644
--- a/release_notes_filter.pl
+++ b/release_notes_filter.pl
@@ -4,6 +4,9 @@
 while(<>) {
   if ($_ !~ /@@@/) {
     print $_;
+    if ($_ =~ /:/) {
+      print "\n";
+    }
     next;
   }
   my @c = split('@@@', $_);
diff --git a/travis_install_dependencies.sh b/travis_install_dependencies.sh
deleted file mode 100755
index 7633b86ff2..0000000000
--- a/travis_install_dependencies.sh
+++ /dev/null
@@ -1,26 +0,0 @@
-#!/usr/bin/env bash
-# Adapted from https://github.com/dockyard/reefpoints/blob/master/source/posts/2013-03-29-running-postgresql-9-2-on-travis-ci.md
-set -x -e
-
-sudo service postgresql stop
-sudo cp /etc/postgresql/9.1/main/pg_hba.conf ./
-sudo apt-get remove postgresql libpq-dev libpq5 postgresql-client-common postgresql-common -qq --purge
-source /etc/lsb-release
-echo "deb http://apt.postgresql.org/pub/repos/apt/ $DISTRIB_CODENAME-pgdg main ${PG_VERSION}" > pgdg.list
-sudo mv pgdg.list /etc/apt/sources.list.d/
-wget --quiet -O - https://apt.postgresql.org/pub/repos/apt/ACCC4CF8.asc | sudo apt-key add -
-sudo apt-get update
-sudo apt-get -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confnew" install postgresql-${PG_VERSION} postgresql-contrib-${PG_VERSION} -qq
-
-if [ ${PG_VERSION} = '8.4' ]
-then
-  sudo sed -i -e 's/port = 5433/port = 5432/g' /etc/postgresql/8.4/main/postgresql.conf
-fi
-
-sudo sed -i -e 's/#max_prepared_transactions = 0/max_prepared_transactions = 64/g' /etc/postgresql/${PG_VERSION}/main/postgresql.conf
-
-sudo cp ./pg_hba.conf /etc/postgresql/${PG_VERSION}/main
-
-sudo service postgresql restart ${PG_VERSION}
-
-sudo tail /var/log/postgresql/postgresql-${PG_VERSION}-main.log
diff --git a/ubenchmark/pom.xml b/ubenchmark/pom.xml
index e94b6c7859..a77b9d3e48 100644
--- a/ubenchmark/pom.xml
+++ b/ubenchmark/pom.xml
@@ -31,14 +31,14 @@ POSSIBILITY OF SUCH DAMAGE.
   <parent>
     <groupId>org.postgresql</groupId>
     <artifactId>pgjdbc-versions</artifactId>
-    <version>1.0.8</version>
+    <version>1.1.1</version>
     <relativePath />
   </parent>
 
   <artifactId>pgjdbc-benchmark</artifactId>
   <packaging>jar</packaging>
   <name>PostgreSQL JDBC Driver - benchmarks</name>
-  <version>9.4.1209</version>
+  <version>9.4.1210</version>
   <description>PostgreSQL JDBC Driver - benchmarks</description>
   <url>https://github.com/pgjdbc/pgjdbc</url>
 
@@ -239,6 +239,6 @@ POSSIBILITY OF SUCH DAMAGE.
   </profiles>
 
   <scm>
-    <tag>REL9.4.1209</tag>
+    <tag>REL9.4.1210</tag>
   </scm>
 </project>
diff --git a/ubenchmark/src/main/java/org/postgresql/benchmark/statement/ParseStatement.java b/ubenchmark/src/main/java/org/postgresql/benchmark/statement/ParseStatement.java
index dfa804e71b..d0caedfb3b 100644
--- a/ubenchmark/src/main/java/org/postgresql/benchmark/statement/ParseStatement.java
+++ b/ubenchmark/src/main/java/org/postgresql/benchmark/statement/ParseStatement.java
@@ -50,6 +50,9 @@ public class ParseStatement {
 
   private Connection connection;
 
+  @Param({"conservative"})
+  private String autoSave;
+
   private String sql;
 
   private int cntr;
@@ -57,8 +60,16 @@ public class ParseStatement {
   @Setup(Level.Trial)
   public void setUp() throws SQLException {
     Properties props = ConnectionUtil.getProperties();
+    props.put("autosave", autoSave);
 
     connection = DriverManager.getConnection(ConnectionUtil.getURL(), props);
+
+    // Start transaction
+    Statement st = connection.createStatement();
+    connection.setAutoCommit(false);
+    st.execute("BEGIN");
+    st.close();
+
     StringBuilder sb = new StringBuilder();
     sb.append("SELECT ");
     for (int i = 0; i < bindCount; i++) {
diff --git a/ubenchmark/src/main/java/org/postgresql/benchmark/statement/ProcessResultSet.java b/ubenchmark/src/main/java/org/postgresql/benchmark/statement/ProcessResultSet.java
index d886429ebe..fb6f0c744a 100644
--- a/ubenchmark/src/main/java/org/postgresql/benchmark/statement/ProcessResultSet.java
+++ b/ubenchmark/src/main/java/org/postgresql/benchmark/statement/ProcessResultSet.java
@@ -51,6 +51,11 @@ public enum FieldType {
     TIMESTAMPTZ,
   }
 
+  public enum ColumnIndexType {
+    INDEX,
+    NAME
+  }
+
   public enum GetterType {
     BEST,
     OBJECT
@@ -71,14 +76,29 @@ public enum GetterType {
   @Param({"BEST"})
   public GetterType getter;
 
+  @Param({"NAME"})
+  public ColumnIndexType columnIndexType;
+
+  // Reuse == false is in line with what most applications do. They never reuse PreparedStatement objects
+  @Param({"false"})
+  public boolean reuseStatement;
+
   private Connection connection;
 
+  private PreparedStatement ps;
+
   private String sql;
 
   private int cntr;
 
+  private String[] columnNames;
+
   @Setup(Level.Trial)
   public void setUp() throws SQLException {
+    if (reuseStatement && unique) {
+      System.out.println("It does not make sense to test reuseStatement && unique combination. Terminating to save time");
+      System.exit(-1);
+    }
     if (type == FieldType.TIMESTAMP) {
       System.out.println(
           "TimeZone.getDefault().getDisplayName() = " + TimeZone.getDefault().getDisplayName());
@@ -88,6 +108,7 @@ public void setUp() throws SQLException {
     connection = DriverManager.getConnection(ConnectionUtil.getURL(), props);
     StringBuilder sb = new StringBuilder();
     sb.append("SELECT ");
+    columnNames = new String[ncols];
     for (int i = 0; i < ncols; i++) {
       if (i > 0) {
         sb.append(", ");
@@ -107,10 +128,15 @@ public void setUp() throws SQLException {
       } else if (type == FieldType.TIMESTAMPTZ) {
         sb.append("current_timestamp");
       }
-      sb.append(" c").append(i);
+      String columnName = "c" + String.valueOf(System.currentTimeMillis()) + String.valueOf(i);
+      columnNames[i] = columnName;
+      sb.append(' ').append(columnName);
     }
     sb.append(" from generate_series(1, ?) as t(x)");
     sql = sb.toString();
+    if (reuseStatement) {
+      this.ps = connection.prepareStatement(sql);
+    }
   }
 
   @TearDown(Level.Trial)
@@ -124,33 +150,62 @@ public Statement bindExecuteFetch(Blackhole b) throws SQLException {
     if (unique) {
       sql += " -- " + cntr++;
     }
-    PreparedStatement ps = connection.prepareStatement(sql);
+
+    PreparedStatement ps = reuseStatement ? this.ps : connection.prepareStatement(sql);
     ps.setInt(1, nrows);
     ResultSet rs = ps.executeQuery();
     while (rs.next()) {
       for (int i = 1; i <= ncols; i++) {
-        if (getter == GetterType.OBJECT) {
-          b.consume(rs.getObject(i));
-        } else if (type == FieldType.INT) {
-          b.consume(rs.getInt(i));
-        } else if (type == FieldType.BIGINT) {
-          b.consume(rs.getBigDecimal(i));
-        } else if (type == FieldType.BIGDECIMAL) {
-          b.consume(rs.getBigDecimal(i));
-        } else if (type == FieldType.STRING) {
-          b.consume(rs.getString(i));
-        } else if (type == FieldType.TIMESTAMP) {
-          b.consume(rs.getTimestamp(i));
-        } else if (type == FieldType.TIMESTAMPTZ) {
-          b.consume(rs.getTimestamp(i));
+        if (columnIndexType == ColumnIndexType.INDEX) {
+          getByIndex(b, rs, i);
+        } else {
+          getByName(b, rs, columnNames[i - 1]);
         }
       }
     }
     rs.close();
-    ps.close();
+    if (!reuseStatement) {
+      ps.close();
+    }
     return ps;
   }
 
+  private void getByIndex(Blackhole b, ResultSet rs, int i) throws SQLException {
+    if (getter == GetterType.OBJECT) {
+      b.consume(rs.getObject(i));
+    } else if (type == FieldType.INT) {
+      b.consume(rs.getInt(i));
+    } else if (type == FieldType.BIGINT) {
+      b.consume(rs.getBigDecimal(i));
+    } else if (type == FieldType.BIGDECIMAL) {
+      b.consume(rs.getBigDecimal(i));
+    } else if (type == FieldType.STRING) {
+      b.consume(rs.getString(i));
+    } else if (type == FieldType.TIMESTAMP) {
+      b.consume(rs.getTimestamp(i));
+    } else if (type == FieldType.TIMESTAMPTZ) {
+      b.consume(rs.getTimestamp(i));
+    }
+  }
+
+  private void getByName(Blackhole b, ResultSet rs, String i) throws SQLException {
+    if (getter == GetterType.OBJECT) {
+      b.consume(rs.getObject(i));
+    } else if (type == FieldType.INT) {
+      b.consume(rs.getInt(i));
+    } else if (type == FieldType.BIGINT) {
+      b.consume(rs.getBigDecimal(i));
+    } else if (type == FieldType.BIGDECIMAL) {
+      b.consume(rs.getBigDecimal(i));
+    } else if (type == FieldType.STRING) {
+      b.consume(rs.getString(i));
+    } else if (type == FieldType.TIMESTAMP) {
+      b.consume(rs.getTimestamp(i));
+    } else if (type == FieldType.TIMESTAMPTZ) {
+      b.consume(rs.getTimestamp(i));
+    }
+  }
+
   public static void main(String[] args) throws RunnerException {
     Options opt = new OptionsBuilder()
         .include(ProcessResultSet.class.getSimpleName())
diff --git a/ubenchmark/src/test/java/readme.txt b/ubenchmark/src/test/java/readme.txt
new file mode 100644
index 0000000000..c8ccb8f511
--- /dev/null
+++ b/ubenchmark/src/test/java/readme.txt
@@ -0,0 +1,4 @@
+No test source yet, however the folder is required for java comment preprocessor
+Otherwise it fails with
+
+[ERROR] Failed to execute goal com.igormaznitsa:jcp:6.0.1:preprocess (preprocessTestSources) on project pgjdbc-benchmark: Can't find a source directory [/home/travis/build/pgjdbc/pgjdbc/ubenchmark/src/test/java] -> [Help 1]